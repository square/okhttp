{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"caching/","text":"Caching \u00b6 OkHttp implements an optional, off by default, Cache. OkHttp aims for RFC correct and pragmatic caching behaviour, following common real-world browser like Firefox/Chrome and server behaviour when ambiguous. Basic Usage \u00b6 private val client : OkHttpClient = OkHttpClient . Builder () . cache ( Cache ( directory = File ( application . cacheDir , \"http_cache\" ), // $0.05 worth of phone storage in 2020 maxSize = 50L * 1024L * 1024L // 50 MiB )) . build () EventListener events \u00b6 Cache Events are exposed via the EventListener API. Typical scenarios are below. Cache Hit \u00b6 In the ideal scenario the cache can fulfill the request without any conditional call to the network. This will skip the normal events such as DNS, connecting to the network, and downloading the response body. As recommended by the HTTP RFC the max age of a document is defaulted to 10% of the document\u2019s age at the time it was served based on \u201cLast-Modified\u201d. Default expiration dates aren\u2019t used for URIs containing a query. CallStart CacheHit CallEnd Cache Miss \u00b6 Under a cache miss the normal request events are seen but an additional event shows the presence of the cache. Cache Miss will be typical if the item has not been read from the network, is uncacheable, or is past it\u2019s lifetime based on Response cache headers. CallStart CacheMiss ProxySelectStart \u2026 Standard Events \u2026 CallEnd Conditional Cache Hit \u00b6 When cache flags require checking the cache results are still valid an early cacheConditionalHit event is received followed by a cache hit or miss. Critically in the cache hit scenario the server won\u2019t send the response body. The response will have non-null cacheResponse and networkResponse . The cacheResponse will be used as the top level response only if the response code is HTTP/1.1 304 Not Modified. CallStart CacheConditionalHit ConnectionAcquired \u2026 Standard Events\u2026 ResponseBodyEnd (0 bytes) CacheHit ConnectionReleased CallEnd Cache directory \u00b6 The cache directory must be exclusively owned by a single instance. Deleting the cache when it is no longer needed can be done. However this may delete the purpose of the cache which is designed to persist between app restarts. cache.delete() Pruning the Cache \u00b6 Pruning the entire Cache to clear space temporarily can be done using evictAll. cache.evictAll() Removing individual items can be done using the urls iterator. This would be typical after a user initiates a force refresh by a pull to refresh type action. val urlIterator = cache.urls() while (urlIterator.hasNext()) { if (urlIterator.next().startsWith(\"https://www.google.com/\")) { urlIterator.remove() } } Troubleshooting \u00b6 Valid cacheable responses are not being cached Make sure you are reading responses fully as unless they are read fully, cancelled or stalled Responses will not be cached. Overriding normal cache behaviour \u00b6 See Cache documentation. https://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache/","title":"Caching"},{"location":"caching/#caching","text":"OkHttp implements an optional, off by default, Cache. OkHttp aims for RFC correct and pragmatic caching behaviour, following common real-world browser like Firefox/Chrome and server behaviour when ambiguous.","title":"Caching"},{"location":"caching/#basic-usage","text":"private val client : OkHttpClient = OkHttpClient . Builder () . cache ( Cache ( directory = File ( application . cacheDir , \"http_cache\" ), // $0.05 worth of phone storage in 2020 maxSize = 50L * 1024L * 1024L // 50 MiB )) . build ()","title":"Basic Usage"},{"location":"caching/#eventlistener-events","text":"Cache Events are exposed via the EventListener API. Typical scenarios are below.","title":"EventListener events"},{"location":"caching/#cache-hit","text":"In the ideal scenario the cache can fulfill the request without any conditional call to the network. This will skip the normal events such as DNS, connecting to the network, and downloading the response body. As recommended by the HTTP RFC the max age of a document is defaulted to 10% of the document\u2019s age at the time it was served based on \u201cLast-Modified\u201d. Default expiration dates aren\u2019t used for URIs containing a query. CallStart CacheHit CallEnd","title":"Cache Hit"},{"location":"caching/#cache-miss","text":"Under a cache miss the normal request events are seen but an additional event shows the presence of the cache. Cache Miss will be typical if the item has not been read from the network, is uncacheable, or is past it\u2019s lifetime based on Response cache headers. CallStart CacheMiss ProxySelectStart \u2026 Standard Events \u2026 CallEnd","title":"Cache Miss"},{"location":"caching/#conditional-cache-hit","text":"When cache flags require checking the cache results are still valid an early cacheConditionalHit event is received followed by a cache hit or miss. Critically in the cache hit scenario the server won\u2019t send the response body. The response will have non-null cacheResponse and networkResponse . The cacheResponse will be used as the top level response only if the response code is HTTP/1.1 304 Not Modified. CallStart CacheConditionalHit ConnectionAcquired \u2026 Standard Events\u2026 ResponseBodyEnd (0 bytes) CacheHit ConnectionReleased CallEnd","title":"Conditional Cache Hit"},{"location":"caching/#cache-directory","text":"The cache directory must be exclusively owned by a single instance. Deleting the cache when it is no longer needed can be done. However this may delete the purpose of the cache which is designed to persist between app restarts. cache.delete()","title":"Cache directory"},{"location":"caching/#pruning-the-cache","text":"Pruning the entire Cache to clear space temporarily can be done using evictAll. cache.evictAll() Removing individual items can be done using the urls iterator. This would be typical after a user initiates a force refresh by a pull to refresh type action. val urlIterator = cache.urls() while (urlIterator.hasNext()) { if (urlIterator.next().startsWith(\"https://www.google.com/\")) { urlIterator.remove() } }","title":"Pruning the Cache"},{"location":"caching/#troubleshooting","text":"Valid cacheable responses are not being cached Make sure you are reading responses fully as unless they are read fully, cancelled or stalled Responses will not be cached.","title":"Troubleshooting"},{"location":"caching/#overriding-normal-cache-behaviour","text":"See Cache documentation. https://square.github.io/okhttp/4.x/okhttp/okhttp3/-cache/","title":"Overriding normal cache behaviour"},{"location":"calls/","text":"Calls \u00b6 The HTTP client\u2019s job is to accept your request and produce its response. This is simple in theory but it gets tricky in practice. Requests \u00b6 Each HTTP request contains a URL, a method (like GET or POST ), and a list of headers. Requests may also contain a body: a data stream of a specific content type. Responses \u00b6 The response answers the request with a code (like 200 for success or 404 for not found), headers, and its own optional body. Rewriting Requests \u00b6 When you provide OkHttp with an HTTP request, you\u2019re describing the request at a high-level: \u201cfetch me this URL with these headers.\u201d For correctness and efficiency, OkHttp rewrites your request before transmitting it. OkHttp may add headers that are absent from the original request, including Content-Length , Transfer-Encoding , User-Agent , Host , Connection , and Content-Type . It will add an Accept-Encoding header for transparent response compression unless the header is already present. If you\u2019ve got cookies, OkHttp will add a Cookie header with them. Some requests will have a cached response. When this cached response isn\u2019t fresh, OkHttp can do a conditional GET to download an updated response if it\u2019s newer than what\u2019s cached. This requires headers like If-Modified-Since and If-None-Match to be added. Rewriting Responses \u00b6 If transparent compression was used, OkHttp will drop the corresponding response headers Content-Encoding and Content-Length because they don\u2019t apply to the decompressed response body. If a conditional GET was successful, responses from the network and cache are merged as directed by the spec. Follow-up Requests \u00b6 When your requested URL has moved, the webserver will return a response code like 302 to indicate the document\u2019s new URL. OkHttp will follow the redirect to retrieve a final response. If the response issues an authorization challenge, OkHttp will ask the Authenticator (if one is configured) to satisfy the challenge. If the authenticator supplies a credential, the request is retried with that credential included. Retrying Requests \u00b6 Sometimes connections fail: either a pooled connection was stale and disconnected, or the webserver itself couldn\u2019t be reached. OkHttp will retry the request with a different route if one is available. Calls \u00b6 With rewrites, redirects, follow-ups and retries, your simple request may yield many requests and responses. OkHttp uses Call to model the task of satisfying your request through however many intermediate requests and responses are necessary. Typically this isn\u2019t many! But it\u2019s comforting to know that your code will continue to work if your URLs are redirected or if you failover to an alternate IP address. Calls are executed in one of two ways: Synchronous: your thread blocks until the response is readable. Asynchronous: you enqueue the request on any thread, and get called back on another thread when the response is readable. Calls can be canceled from any thread. This will fail the call if it hasn\u2019t yet completed! Code that is writing the request body or reading the response body will suffer an IOException when its call is canceled. Dispatch \u00b6 For synchronous calls, you bring your own thread and are responsible for managing how many simultaneous requests you make. Too many simultaneous connections wastes resources; too few harms latency. For asynchronous calls, Dispatcher implements policy for maximum simultaneous requests. You can set maximums per-webserver (default is 5), and overall (default is 64).","title":"Calls"},{"location":"calls/#calls","text":"The HTTP client\u2019s job is to accept your request and produce its response. This is simple in theory but it gets tricky in practice.","title":"Calls"},{"location":"calls/#requests","text":"Each HTTP request contains a URL, a method (like GET or POST ), and a list of headers. Requests may also contain a body: a data stream of a specific content type.","title":"Requests"},{"location":"calls/#responses","text":"The response answers the request with a code (like 200 for success or 404 for not found), headers, and its own optional body.","title":"Responses"},{"location":"calls/#rewriting-requests","text":"When you provide OkHttp with an HTTP request, you\u2019re describing the request at a high-level: \u201cfetch me this URL with these headers.\u201d For correctness and efficiency, OkHttp rewrites your request before transmitting it. OkHttp may add headers that are absent from the original request, including Content-Length , Transfer-Encoding , User-Agent , Host , Connection , and Content-Type . It will add an Accept-Encoding header for transparent response compression unless the header is already present. If you\u2019ve got cookies, OkHttp will add a Cookie header with them. Some requests will have a cached response. When this cached response isn\u2019t fresh, OkHttp can do a conditional GET to download an updated response if it\u2019s newer than what\u2019s cached. This requires headers like If-Modified-Since and If-None-Match to be added.","title":"Rewriting Requests"},{"location":"calls/#rewriting-responses","text":"If transparent compression was used, OkHttp will drop the corresponding response headers Content-Encoding and Content-Length because they don\u2019t apply to the decompressed response body. If a conditional GET was successful, responses from the network and cache are merged as directed by the spec.","title":"Rewriting Responses"},{"location":"calls/#follow-up-requests","text":"When your requested URL has moved, the webserver will return a response code like 302 to indicate the document\u2019s new URL. OkHttp will follow the redirect to retrieve a final response. If the response issues an authorization challenge, OkHttp will ask the Authenticator (if one is configured) to satisfy the challenge. If the authenticator supplies a credential, the request is retried with that credential included.","title":"Follow-up Requests"},{"location":"calls/#retrying-requests","text":"Sometimes connections fail: either a pooled connection was stale and disconnected, or the webserver itself couldn\u2019t be reached. OkHttp will retry the request with a different route if one is available.","title":"Retrying Requests"},{"location":"calls/#calls_1","text":"With rewrites, redirects, follow-ups and retries, your simple request may yield many requests and responses. OkHttp uses Call to model the task of satisfying your request through however many intermediate requests and responses are necessary. Typically this isn\u2019t many! But it\u2019s comforting to know that your code will continue to work if your URLs are redirected or if you failover to an alternate IP address. Calls are executed in one of two ways: Synchronous: your thread blocks until the response is readable. Asynchronous: you enqueue the request on any thread, and get called back on another thread when the response is readable. Calls can be canceled from any thread. This will fail the call if it hasn\u2019t yet completed! Code that is writing the request body or reading the response body will suffer an IOException when its call is canceled.","title":"Calls"},{"location":"calls/#dispatch","text":"For synchronous calls, you bring your own thread and are responsible for managing how many simultaneous requests you make. Too many simultaneous connections wastes resources; too few harms latency. For asynchronous calls, Dispatcher implements policy for maximum simultaneous requests. You can set maximums per-webserver (default is 5), and overall (default is 64).","title":"Dispatch"},{"location":"changelog_1x/","text":"OkHttp 1.x Change Log \u00b6 Version 1.6.0 \u00b6 2014-05-23 Offer bridges to make it easier to migrate from OkHttp 1.x to OkHttp 2.0. This adds OkUrlFactory , Cache , and @Deprecated annotations for APIs dropped in 2.0. Version 1.5.4 \u00b6 2014-04-14 Drop ALPN support in Android. There\u2019s a concurrency bug in all currently-shipping versions. Support asynchronous disconnects by breaking the socket only. This should prevent flakiness from multiple threads concurrently accessing a stream. Version 1.5.3 \u00b6 2014-03-29 Fix bug where the Content-Length header was not always dropped when following a redirect from a POST to a GET. Implement basic support for Thread.interrupt() . OkHttp now checks for an interruption before doing a blocking call. If it is interrupted, it throws an InterruptedIOException . Version 1.5.2 \u00b6 2014-03-17 Fix bug where deleting a file that was absent from the HttpResponseCache caused an IOException. Fix bug in HTTP/2 where our HPACK decoder wasn\u2019t emitting entries in certain eviction scenarios, leading to dropped response headers. Version 1.5.1 \u00b6 2014-03-11 Fix 1.5.0 regression where connections should not have been recycled. Fix 1.5.0 regression where transparent Gzip was broken by attempting to recover from another I/O failure. Fix problems where spdy/3.1 headers may not have been compressed properly. Fix problems with spdy/3.1 and http/2 where the wrong window size was being used. Fix 1.5.0 regression where conditional cache responses could corrupt the connection pool. Version 1.5.0 \u00b6 2014-03-07 OkHttp no longer uses the default SSL context. \u00b6 Applications that want to use the global SSL context with OkHttp should configure their OkHttpClient instances with the following: okHttpClient . setSslSocketFactory ( HttpsURLConnection . getDefaultSSLSocketFactory ()); A simpler solution is to avoid the shared default SSL socket factory. Instead, if you need to customize SSL, do so for your specific OkHttpClient instance only. Synthetic headers have changed \u00b6 Previously OkHttp added a synthetic response header, OkHttp-Selected-Transport . It has been replaced with a new synthetic header, OkHttp-Selected-Protocol . Changes \u00b6 New: Support for HTTP-draft-09/2.0 . New: Support for spdy/3.1 . Dropped support for spdy/3 . New: Use ALPN on Android platforms that support it (4.4+) New: CacheControl model and parser. New: Protocol selection in MockWebServer. Fix: Route selection shouldn\u2019t use TLS modes that we know will fail. Fix: Cache SPDY responses even if the response body is closed prematurely. Fix: Use strict timeouts when aborting a download. Fix: Support Shoutcast HTTP responses like ICY 200 OK . Fix: Don\u2019t unzip if there isn\u2019t a response body. Fix: Don\u2019t leak gzip streams on redirects. Fix: Don\u2019t do DNS lookups on invalid hosts. Fix: Exhaust the underlying stream when reading gzip streams. Fix: Support the PATCH method. Fix: Support request bodies on DELETE method. Fix: Drop the okhttp-protocols module. Internal: Replaced internal byte array buffers with pooled buffers (\u201cOkBuffer\u201d). Version 1.3.0 \u00b6 2014-01-11 New: Support for \u201cPATCH\u201d HTTP method in client and MockWebServer. Fix: Drop Content-Length header when redirected from POST to GET. Fix: Correctly read cached header entries with malformed header names. Fix: Do not directly support any authentication schemes other than \u201cBasic\u201d. Fix: Respect read timeouts on recycled connections. Fix: Transmit multiple cookie values as a single header with delimiter. Fix: Ensure null is never returned from a connection\u2019s getHeaderFields() . Fix: Persist proper Content-Encoding header to cache for GZip responses. Fix: Eliminate rare race condition in SPDY streams that would prevent connection reuse. Fix: Change HTTP date formats to UTC to conform to RFC2616 section 3.3. Fix: Support SPDY header blocks with trailing bytes. Fix: Allow ; as separator for Cache-Control header. Fix: Correct bug where HTTPS POST requests were always automatically buffered. Fix: Honor read timeout when parsing SPDY headers. Version 1.2.1 \u00b6 2013-08-23 Resolve issue with \u2018jar-with-dependencies\u2019 artifact creation. Fix: Support empty SPDY header values. Version 1.2.0 \u00b6 2013-08-11 New APIs on OkHttpClient to set default timeouts for connect and read. Fix bug when caching SPDY responses. Fix a bug with SPDY plus half-closed streams. (thanks kwuollett) Fix a bug in Content-Length reporting for gzipped streams in the Apache HTTP client adapter. (thanks kwuollett) Work around the Alcatel getByInetAddress bug (thanks k.kocel) Be more aggressive about testing pooled sockets before reuse. (thanks warpspin) Include Content-Type and Content-Encoding in the Apache HTTP client adapter. (thanks kwuollett) Add a media type class to OkHttp. Change custom header prefix: X-Android-Sent-Millis is now OkHttp-Sent-Millis X-Android-Received-Millis is now OkHttp-Received-Millis X-Android-Response-Source is now OkHttp-Response-Source X-Android-Selected-Transport is now OkHttp-Selected-Transport * Improve cache invalidation for POST-like requests. * Bring MockWebServer into OkHttp and teach it SPDY. Version 1.1.1 \u00b6 2013-06-23 Fix: ClassCastException when caching responses that were redirected from HTTP to HTTPS. Version 1.1.0 \u00b6 2013-06-15 Fix: Connection reuse was broken for most HTTPS connections due to a bug in the way the hostname verifier was selected. Fix: Locking bug in SpdyConnection. Fix: Ignore null header values (for compatibility with HttpURLConnection). Add URLStreamHandlerFactory support so that URL.openConnection() uses OkHttp. Expose the transport (\u201chttp/1.1\u201d, \u201cspdy/3\u201d, etc.) via magic request headers. Use X-Android-Transports to write the preferred transports and X-Android-Selected-Transport to read the negotiated transport. Version 1.0.2 \u00b6 2013-05-11 Fix: Remove use of Java 6-only APIs. Fix: Properly handle exceptions from NetworkInterface when querying MTU. Fix: Ensure MTU has a reasonable default and upper-bound. Version 1.0.1 \u00b6 2013-05-06 Correct casing of SSL in method names ( getSslSocketFactory / setSslSocketFactory ). Version 1.0.0 \u00b6 2013-05-06 Initial release.","title":"Changelog 1x"},{"location":"changelog_1x/#okhttp-1x-change-log","text":"","title":"OkHttp 1.x Change Log"},{"location":"changelog_1x/#version-160","text":"2014-05-23 Offer bridges to make it easier to migrate from OkHttp 1.x to OkHttp 2.0. This adds OkUrlFactory , Cache , and @Deprecated annotations for APIs dropped in 2.0.","title":"Version 1.6.0"},{"location":"changelog_1x/#version-154","text":"2014-04-14 Drop ALPN support in Android. There\u2019s a concurrency bug in all currently-shipping versions. Support asynchronous disconnects by breaking the socket only. This should prevent flakiness from multiple threads concurrently accessing a stream.","title":"Version 1.5.4"},{"location":"changelog_1x/#version-153","text":"2014-03-29 Fix bug where the Content-Length header was not always dropped when following a redirect from a POST to a GET. Implement basic support for Thread.interrupt() . OkHttp now checks for an interruption before doing a blocking call. If it is interrupted, it throws an InterruptedIOException .","title":"Version 1.5.3"},{"location":"changelog_1x/#version-152","text":"2014-03-17 Fix bug where deleting a file that was absent from the HttpResponseCache caused an IOException. Fix bug in HTTP/2 where our HPACK decoder wasn\u2019t emitting entries in certain eviction scenarios, leading to dropped response headers.","title":"Version 1.5.2"},{"location":"changelog_1x/#version-151","text":"2014-03-11 Fix 1.5.0 regression where connections should not have been recycled. Fix 1.5.0 regression where transparent Gzip was broken by attempting to recover from another I/O failure. Fix problems where spdy/3.1 headers may not have been compressed properly. Fix problems with spdy/3.1 and http/2 where the wrong window size was being used. Fix 1.5.0 regression where conditional cache responses could corrupt the connection pool.","title":"Version 1.5.1"},{"location":"changelog_1x/#version-150","text":"2014-03-07","title":"Version 1.5.0"},{"location":"changelog_1x/#okhttp-no-longer-uses-the-default-ssl-context","text":"Applications that want to use the global SSL context with OkHttp should configure their OkHttpClient instances with the following: okHttpClient . setSslSocketFactory ( HttpsURLConnection . getDefaultSSLSocketFactory ()); A simpler solution is to avoid the shared default SSL socket factory. Instead, if you need to customize SSL, do so for your specific OkHttpClient instance only.","title":"OkHttp no longer uses the default SSL context."},{"location":"changelog_1x/#synthetic-headers-have-changed","text":"Previously OkHttp added a synthetic response header, OkHttp-Selected-Transport . It has been replaced with a new synthetic header, OkHttp-Selected-Protocol .","title":"Synthetic headers have changed"},{"location":"changelog_1x/#changes","text":"New: Support for HTTP-draft-09/2.0 . New: Support for spdy/3.1 . Dropped support for spdy/3 . New: Use ALPN on Android platforms that support it (4.4+) New: CacheControl model and parser. New: Protocol selection in MockWebServer. Fix: Route selection shouldn\u2019t use TLS modes that we know will fail. Fix: Cache SPDY responses even if the response body is closed prematurely. Fix: Use strict timeouts when aborting a download. Fix: Support Shoutcast HTTP responses like ICY 200 OK . Fix: Don\u2019t unzip if there isn\u2019t a response body. Fix: Don\u2019t leak gzip streams on redirects. Fix: Don\u2019t do DNS lookups on invalid hosts. Fix: Exhaust the underlying stream when reading gzip streams. Fix: Support the PATCH method. Fix: Support request bodies on DELETE method. Fix: Drop the okhttp-protocols module. Internal: Replaced internal byte array buffers with pooled buffers (\u201cOkBuffer\u201d).","title":"Changes"},{"location":"changelog_1x/#version-130","text":"2014-01-11 New: Support for \u201cPATCH\u201d HTTP method in client and MockWebServer. Fix: Drop Content-Length header when redirected from POST to GET. Fix: Correctly read cached header entries with malformed header names. Fix: Do not directly support any authentication schemes other than \u201cBasic\u201d. Fix: Respect read timeouts on recycled connections. Fix: Transmit multiple cookie values as a single header with delimiter. Fix: Ensure null is never returned from a connection\u2019s getHeaderFields() . Fix: Persist proper Content-Encoding header to cache for GZip responses. Fix: Eliminate rare race condition in SPDY streams that would prevent connection reuse. Fix: Change HTTP date formats to UTC to conform to RFC2616 section 3.3. Fix: Support SPDY header blocks with trailing bytes. Fix: Allow ; as separator for Cache-Control header. Fix: Correct bug where HTTPS POST requests were always automatically buffered. Fix: Honor read timeout when parsing SPDY headers.","title":"Version 1.3.0"},{"location":"changelog_1x/#version-121","text":"2013-08-23 Resolve issue with \u2018jar-with-dependencies\u2019 artifact creation. Fix: Support empty SPDY header values.","title":"Version 1.2.1"},{"location":"changelog_1x/#version-120","text":"2013-08-11 New APIs on OkHttpClient to set default timeouts for connect and read. Fix bug when caching SPDY responses. Fix a bug with SPDY plus half-closed streams. (thanks kwuollett) Fix a bug in Content-Length reporting for gzipped streams in the Apache HTTP client adapter. (thanks kwuollett) Work around the Alcatel getByInetAddress bug (thanks k.kocel) Be more aggressive about testing pooled sockets before reuse. (thanks warpspin) Include Content-Type and Content-Encoding in the Apache HTTP client adapter. (thanks kwuollett) Add a media type class to OkHttp. Change custom header prefix: X-Android-Sent-Millis is now OkHttp-Sent-Millis X-Android-Received-Millis is now OkHttp-Received-Millis X-Android-Response-Source is now OkHttp-Response-Source X-Android-Selected-Transport is now OkHttp-Selected-Transport * Improve cache invalidation for POST-like requests. * Bring MockWebServer into OkHttp and teach it SPDY.","title":"Version 1.2.0"},{"location":"changelog_1x/#version-111","text":"2013-06-23 Fix: ClassCastException when caching responses that were redirected from HTTP to HTTPS.","title":"Version 1.1.1"},{"location":"changelog_1x/#version-110","text":"2013-06-15 Fix: Connection reuse was broken for most HTTPS connections due to a bug in the way the hostname verifier was selected. Fix: Locking bug in SpdyConnection. Fix: Ignore null header values (for compatibility with HttpURLConnection). Add URLStreamHandlerFactory support so that URL.openConnection() uses OkHttp. Expose the transport (\u201chttp/1.1\u201d, \u201cspdy/3\u201d, etc.) via magic request headers. Use X-Android-Transports to write the preferred transports and X-Android-Selected-Transport to read the negotiated transport.","title":"Version 1.1.0"},{"location":"changelog_1x/#version-102","text":"2013-05-11 Fix: Remove use of Java 6-only APIs. Fix: Properly handle exceptions from NetworkInterface when querying MTU. Fix: Ensure MTU has a reasonable default and upper-bound.","title":"Version 1.0.2"},{"location":"changelog_1x/#version-101","text":"2013-05-06 Correct casing of SSL in method names ( getSslSocketFactory / setSslSocketFactory ).","title":"Version 1.0.1"},{"location":"changelog_1x/#version-100","text":"2013-05-06 Initial release.","title":"Version 1.0.0"},{"location":"changelog_2x/","text":"OkHttp 2.x Change Log \u00b6 Version 2.7.5 \u00b6 2016-02-25 Fix: Change the certificate pinner to always build full chains. This prevents a potential crash when using certificate pinning with the Google Play Services security provider. Version 2.7.4 \u00b6 2016-02-07 Fix: Don\u2019t crash when finding the trust manager if the Play Services (GMS) security provider is installed. Fix: The previous release introduced a performance regression on Android, caused by looking up CA certificates. This is now fixed. Version 2.7.3 \u00b6 2016-02-06 Fix: Permit the trusted CA root to be pinned by CertificatePinner . Version 2.7.2 \u00b6 2016-01-07 Fix: Don\u2019t eagerly release stream allocations on cache hits. We might still need them to handle redirects. Version 2.7.1 \u00b6 2016-01-01 Fix: Don\u2019t do a health check on newly-created connections. This is unnecessary work that could put the client in an inconsistent state if the health check fails. Version 2.7.0 \u00b6 2015-12-13 Rewritten connection management. Previously OkHttp\u2019s connection pool managed both idle and active connections for HTTP/2, but only idle connections for HTTP/1.x. With this update the connection pool manages both idle and active connections for everything. OkHttp now detects and warns on connections that were allocated but never released, and will enforce HTTP/2 stream limits. This update also fixes Call.cancel() to not do I/O on the calling thread. Fix: Don\u2019t log gzipped data in the logging interceptor. Fix: Don\u2019t resolve DNS addresses when connecting through a SOCKS proxy. Fix: Drop the synthetic OkHttp-Selected-Protocol response header. Fix: Support 204 and 205 \u2018No Content\u2019 replies in the logging interceptor. New: Add Call.isExecuted() . Version 2.6.0 \u00b6 2015-11-22 New Logging Interceptor. The logging-interceptor subproject offers simple request and response logging. It may be configured to log headers and bodies for debugging. It requires this Maven dependency: <dependency> <groupId> com.squareup.okhttp </groupId> <artifactId> logging-interceptor </artifactId> <version> 2.6.0 </version> </dependency> Configure basic logging like this: HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor (); loggingInterceptor . setLevel ( HttpLoggingInterceptor . Level . BASIC ); client . networkInterceptors (). add ( loggingInterceptor ); Warning: Avoid Level.HEADERS and Level.BODY in production because they could leak passwords and other authentication credentials to insecure logs. WebSocket API now uses RequestBody and ResponseBody for messages. This is a backwards-incompatible API change. The DNS service is now pluggable. In some situations this may be useful to manually prioritize specific IP addresses. Fix: Don\u2019t throw when converting an HttpUrl to a java.net.URI . Previously URLs with special characters like | and [ would break when subjected to URI\u2019s overly-strict validation. Fix: Don\u2019t re-encode + as %20 in encoded URL query strings. OkHttp prefers %20 when doing its own encoding, but will retain + when that is provided. Fix: Enforce that callers call WebSocket.close() on IO errors. Error handling in WebSockets is significantly improved. Fix: Don\u2019t use SPDY/3 style header concatenation for HTTP/2 request headers. This could have corrupted requests where multiple headers had the same name, as in cookies. Fix: Reject bad characters in the URL hostname. Previously characters like \\0 would cause a late crash when building the request. Fix: Allow interceptors to change the request method. Fix: Don\u2019t use the request\u2019s User-Agent or Proxy-Authorization when connecting to an HTTPS server via an HTTP tunnel. The Proxy-Authorization header was being leaked to the origin server. Fix: Digits may be used in a URL scheme. Fix: Improve connection timeout recovery. Fix: Recover from getsockname crashes impacting Android releases prior to 4.2.2. Fix: Drop partial support for HTTP/1.0. Previously OkHttp would send HTTP/1.0 on connections after seeing a response with HTTP/1.0 . The fixed behavior is consistent with Firefox and Chrome. Fix: Allow a body in OPTIONS requests. Fix: Don\u2019t percent-encode non-ASCII characters in URL fragments. Fix: Handle null fragments. Fix: Don\u2019t crash on interceptors that throw IOException before a connection is attempted. New: Support WebDAV HTTP methods. New: Buffer WebSocket frames for better performance. New: Drop support for TLS_DHE_DSS_WITH_AES_128_CBC_SHA , our only remaining DSS cipher suite. This is consistent with Firefox and Chrome which have also dropped these cipher suite. Version 2.5.0 \u00b6 2015-08-25 Timeouts now default to 10 seconds. Previously we defaulted to never timing out, and that was a lousy policy. If establishing a connection, reading the next byte from a connection, or writing the next byte to a connection takes more than 10 seconds to complete, you\u2019ll need to adjust the timeouts manually. OkHttp now rejects request headers that contain invalid characters. This includes potential security problems (newline characters) as well as simple non-ASCII characters (including international characters and emoji). Call canceling is more reliable. We had a bug where a socket being connected wasn\u2019t being closed when the application used Call.cancel() . Changing a HttpUrl\u2019s scheme now tracks the default port. We had a bug where changing a URL from http to https would leave it on port 80. Okio has been updated to 1.6.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.6.0 </version> </dependency> New: Cache.initialize() . Call this on a background thread to eagerly initialize the response cache. New: Fold MockWebServerRule into MockWebServer . This makes it easier to write JUnit tests with MockWebServer . The MockWebServer library now depends on JUnit, though it continues to work with all testing frameworks. Fix: FormEncodingBuilder is now consistent with browsers in which characters it escapes. Previously we weren\u2019t percent-encoding commas, parens, and other characters. Fix: Relax FormEncodingBuilder to support building empty forms. Fix: Timeouts throw SocketTimeoutException , not InterruptedIOException . Fix: Change MockWebServer to use the same logic as OkHttp when determining whether an HTTP request permits a body. Fix: HttpUrl now uses the canonical form for IPv6 addresses. Fix: Use HttpUrl internally. Fix: Recover from Android 4.2.2 EBADF crashes. Fix: Don\u2019t crash with an IllegalStateException if an HTTP/2 or SPDY write fails, leaving the connection in an inconsistent state. Fix: Make sure the default user agent is ASCII. Version 2.4.0 \u00b6 2015-05-22 Forbid response bodies on HTTP 204 and 205 responses. Webservers that return such malformed responses will now trigger a ProtocolException in the client. WebSocketListener has incompatible changes. The onOpen() method is now called on the reader thread, so implementations must return before further websocket messages will be delivered. The onFailure() method now includes an HTTP response if one was returned. Version 2.4.0-RC1 \u00b6 2015-05-16 New HttpUrl API. It\u2019s like java.net.URL but good. Note that Request.Builder.url() now throws IllegalArgumentException on malformed URLs. (Previous releases would throw a MalformedURLException when calling a malformed URL.) We\u2019ve improved connect failure recovery. We now differentiate between setup, connecting, and connected and implement appropriate recovery rules for each. This changes Address to no longer use ConnectionSpec . (This is an incompatible API change). FormEncodingBuilder now uses %20 instead of + for encoded spaces. Both are permitted-by-spec, but %20 requires fewer special cases. Okio has been updated to 1.4.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.4.0 </version> </dependency> Request.Builder no longer accepts null if a request body is required. Passing null will now fail for request methods that require a body. Instead use an empty body such as this one: RequestBody . create ( null , new byte [ 0 ] ); CertificatePinner now supports wildcard hostnames. As always with certificate pinning, you must be very careful to avoid bricking your app. You\u2019ll need to pin both the top-level domain and the *. domain for full coverage. client . setCertificatePinner ( new CertificatePinner . Builder () . add ( \"publicobject.com\" , \"sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=\" ) . add ( \"*.publicobject.com\" , \"sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=\" ) . add ( \"publicobject.com\" , \"sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=\" ) . add ( \"*.publicobject.com\" , \"sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=\" ) . add ( \"publicobject.com\" , \"sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=\" ) . add ( \"*.publicobject.com\" , \"sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=\" ) . add ( \"publicobject.com\" , \"sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=\" ) . add ( \"*.publicobject.com\" , \"sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=\" ) . build ()); Interceptors lists are now deep-copied by OkHttpClient.clone() . Previously clones shared interceptors, which made it difficult to customize the interceptors on a request-by-request basis. New: Headers.toMultimap() . New: RequestBody.create(MediaType, ByteString) . New: ConnectionSpec.isCompatible(SSLSocket) . New: Dispatcher.getQueuedCallCount() and Dispatcher.getRunningCallCount() . These can be useful in diagnostics. Fix: OkHttp no longer shares timeouts between pooled connections. This was causing some applications to crash when connections were reused. Fix: OkApacheClient now allows an empty PUT and POST . Fix: Websockets no longer rebuffer socket streams. Fix: Websockets are now better at handling close frames. Fix: Content type matching is now case insensitive. Fix: Vary headers are not lost with android.net.http.HttpResponseCache . Fix: HTTP/2 wasn\u2019t enforcing stream timeouts when writing the underlying connection. Now it is. Fix: Never return null on call.proceed() . This was a bug in call cancelation. Fix: When a network interceptor mutates a request, that change is now reflected in Response.networkResponse() . Fix: Badly-behaving caches now throw a checked exception instead of a NullPointerException . Fix: Better handling of uncaught exceptions in MockWebServer with HTTP/2. Version 2.3.0 \u00b6 2015-03-16 HTTP/2 support. We\u2019ve done interop testing and haven\u2019t seen any problems. HTTP/2 support has been a big effort and we\u2019re particularly thankful to Adrian Cole who has helped us to reach this milestone. RC4 cipher suites are no longer supported by default. To connect to old, obsolete servers relying on these cipher suites, you must create a custom ConnectionSpec . Beta WebSockets support. . The okhttp-ws subproject offers a new websockets client. Please try it out! When it\u2019s ready we intend to include it with the core OkHttp library. Okio updated to 1.3.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.3.0 </version> </dependency> Fix: improve parallelism of async requests. OkHttp\u2019s Dispatcher had a misconfigured ExecutorService that limited the number of worker threads. If you\u2019re using Call.enqueue() this update should significantly improve request concurrency. Fix: Lazily initialize the response cache. This avoids strict mode warnings when initializing OkHttp on Android\u2018s main thread. Fix: Disable ALPN on Android 4.4. That release of the feature was unstable and prone to native crashes in the underlying OpenSSL code. Fix: Don\u2019t send both If-None-Match and If-Modified-Since cache headers when both are applicable. Fix: Fail early when a port is out of range. Fix: Offer Content-Length headers for multipart request bodies. Fix: Throw UnknownServiceException if a cleartext connection is attempted when explicitly forbidden. Fix: Throw a SSLPeerUnverifiedException when host verification fails. Fix: MockWebServer explicitly closes sockets. (On some Android releases, closing the input stream and output stream of a socket is not sufficient. Fix: Buffer outgoing HTTP/2 frames to limit how many outgoing frames are created. Fix: Avoid crashing when cache writing fails due to a full disk. Fix: Improve caching of private responses. Fix: Update cache-by-default response codes. Fix: Reused Request.Builder instances no longer hold stale URL fields. New: ConnectionSpec can now be configured to use the SSL socket\u2019s default cipher suites. To use, set the cipher suites to null . New: Support DELETE with a request body. New: Headers.of(Map) creates headers from a Map. Version 2.2.0 \u00b6 2014-12-30 RequestBody.contentLength() now throws IOException . This is a source-incompatible change. If you have code that calls RequestBody.contentLength() , your compile will break with this update. The change is binary-compatible, however: code compiled for OkHttp 2.0 and 2.1 will continue to work with this update. COMPATIBLE_TLS no longer supports SSLv3. In response to the POODLE vulnerability, OkHttp no longer offers SSLv3 when negotiation an HTTPS connection. If you continue to need to connect to webservers running SSLv3, you must manually configure your own ConnectionSpec . OkHttp now offers interceptors. Interceptors are a powerful mechanism that can monitor, rewrite, and retry calls. The interceptors doc is a full introduction to this new API. New: APIs to iterate and selectively clear the response cache. New: Support for SOCKS proxies. New: Support for TLS_FALLBACK_SCSV . New: Update HTTP/2 support to h2-16 and hpack-10 . New: APIs to prevent retrying non-idempotent requests. Fix: Drop NPN support. Going forward we support ALPN only. Fix: The hostname verifier is now strict. This is consistent with the hostname verifier in modern browsers. Fix: Improve CONNECT handling for misbehaving HTTP proxies. Fix: Don\u2019t retry requests that failed due to timeouts. Fix: Cache 302s and 308s that include appropriate response headers. Fix: Improve pooling of connections that use proxy selectors. Fix: Don\u2019t leak connections when using ALPN on the desktop. Fix: Update Jetty ALPN to 7.1.2.v20141202 (Java 7) and 8.1.2.v20141202 (Java 8). This fixes a bug in resumed TLS sessions where the wrong protocol could be selected. Fix: Don\u2019t crash in SPDY and HTTP/2 when disconnecting before connecting. Fix: Avoid a reverse DNS-lookup for a numeric proxy address Fix: Resurrect http/2 frame logging. Fix: Limit to 20 authorization attempts. Version 2.1.0 \u00b6 2014-11-11 New: Typesafe APIs for interacting with cipher suites and TLS versions. Fix: Don\u2019t crash when mixing authorization challenges with upload retries. Version 2.1.0-RC1 \u00b6 2014-11-04 OkHttp now caches private responses . We\u2019ve changed from a shared cache to a private cache, and will now store responses that use an Authorization header. This means OkHttp\u2019s cache shouldn\u2019t be used on middleboxes that sit between user agents and the origin server. TLS configuration updated. OkHttp now explicitly enables TLSv1.2, TLSv1.1 and TLSv1.0 where they are supported. It will continue to perform only one fallback, to SSLv3. Applications can now configure this with the ConnectionSpec class. To disable TLS fallback: client . setConnectionSpecs ( Arrays . asList ( ConnectionSpec . MODERN_TLS , ConnectionSpec . CLEARTEXT )); To disable cleartext connections, permitting https URLs only: client . setConnectionSpecs ( Arrays . asList ( ConnectionSpec . MODERN_TLS , ConnectionSpec . COMPATIBLE_TLS )); New cipher suites. Please confirm that your webservers are reachable with this limited set of cipher suites. Android Name Version TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 5.0 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 5.0 TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 5.0 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA 4.0 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA 4.0 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 4.0 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA 4.0 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA 4.0 TLS_ECDHE_RSA_WITH_RC4_128_SHA 4.0 TLS_DHE_RSA_WITH_AES_128_CBC_SHA 2.3 TLS_DHE_DSS_WITH_AES_128_CBC_SHA 2.3 TLS_DHE_RSA_WITH_AES_256_CBC_SHA 2.3 TLS_RSA_WITH_AES_128_GCM_SHA256 5.0 TLS_RSA_WITH_AES_128_CBC_SHA 2.3 TLS_RSA_WITH_AES_256_CBC_SHA 2.3 SSL_RSA_WITH_3DES_EDE_CBC_SHA 2.3 (Deprecated in 5.0) SSL_RSA_WITH_RC4_128_SHA 2.3 SSL_RSA_WITH_RC4_128_MD5 2.3 (Deprecated in 5.0) Okio updated to 1.0.1. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.0.1 </version> </dependency> New APIs to permit easy certificate pinning. Be warned, certificate pinning is dangerous and could prevent your application from trusting your server! Cache improvements. This release fixes some severe cache problems including a bug where the cache could be corrupted upon certain access patterns. We also fixed a bug where the cache was being cleared due to a corrupted journal. We\u2019ve added APIs to configure a request\u2019s Cache-Control headers, and to manually clear the cache. Request cancellation fixes. This update fixes a bug where synchronous requests couldn\u2019t be canceled by tag. This update avoids crashing when onResponse() throws an IOException . That failure will now be logged instead of notifying the thread\u2019s uncaught exception handler. We\u2019ve added a new API, Call.isCanceled() to check if a call has been canceled. New: Update MultipartBuilder to support content length. New: Make it possible to mock OkHttpClient and Call . New: Update to h2-14 and hpack-9. New: OkHttp includes a user-agent by default, like okhttp/2.1.0-RC1 . Fix: Handle response code 308 Permanent Redirect . Fix: Don\u2019t skip the callback if a call is canceled. Fix: Permit hostnames with underscores. Fix: Permit overriding the content-type in OkApacheClient . Fix: Use the socket factory for direct connections. Fix: Honor OkUrlFactory APIs that disable redirects. Fix: Don\u2019t crash on concurrent modification of SPDY SPDY settings. Version 2.0.0 \u00b6 This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x. 2014-06-21 API Change : Use IOException in Callback.onFailure() . This is a source-incompatible change, and is different from OkHttp 2.0.0-RC2 which used Throwable . Fix: Fixed a caching bug where we weren\u2019t storing rewritten request headers like Accept-Encoding . Fix: Fixed bugs in handling the SPDY window size. This was stalling certain large downloads Update the language level to Java 7. (OkHttp requires Android 2.3+ or Java 7+.) Version 2.0.0-RC2 \u00b6 2014-06-11 This update fixes problems in 2.0.0-RC1. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x. Fix: Don\u2019t leak connections! There was a regression in 2.0.0-RC1 where connections were neither closed nor pooled. Fix: Revert builder-style return types from OkHttpClient\u2019s timeout methods for binary compatibility with OkHttp 1.x. Fix: Don\u2019t skip client stream 1 on SPDY/3.1. This fixes SPDY connectivity to https://google.com , which doesn\u2019t follow the SPDY/3.1 spec! Fix: Always configure NPN headers. This fixes connectivity to https://facebook.com when SPDY and HTTP/2 are both disabled. Otherwise an unexpected NPN response is received and OkHttp crashes. Fix: Write continuation frames when HPACK data is larger than 16383 bytes. Fix: Don\u2019t drop uncaught exceptions thrown in async calls. Fix: Throw an exception eagerly when a request body is not legal. Previously we ignored the problem at request-building time, only to crash later with a NullPointerException . Fix: Include a backwards-compatible OkHttp-Response-Source header with OkUrlFactory responses. Fix: Don\u2019t include a default User-Agent header in requests made with the Call API. Requests made with OkUrlFactory will continue to have a default user agent. New: Guava-like API to create headers: Headers headers = Headers . of ( name1 , value1 , name2 , value2 , ...). New: Make the content-type header optional for request bodies. New: Response.isSuccessful() is a convenient API to check response codes. New: The response body can now be read outside of the callback. Response bodies must always be closed, otherwise they will leak connections! New: APIs to create multipart request bodies ( MultipartBuilder ) and form encoding bodies ( FormEncodingBuilder ). Version 2.0.0-RC1 \u00b6 2014-05-23 OkHttp 2 is designed around a new API that is true to HTTP, with classes for requests, responses, headers, and calls. It uses modern Java patterns like immutability and chained builders. The API now offers asynchronous callbacks in addition to synchronous blocking calls. API Changes \u00b6 New Request and Response types, each with their own builder. There\u2019s also a RequestBody class to write the request body to the network and a ResponseBody to read the response body from the network. The standalone Headers class offers full access to the HTTP headers. Okio dependency added. OkHttp now depends on Okio , an I/O library that makes it easier to access, store and process data. Using this library internally makes OkHttp faster while consuming less memory. You can write a RequestBody as an Okio BufferedSink and a ResponseBody as an Okio BufferedSource . Standard InputStream and OutputStream access is also available. New Call and Callback types execute requests and receive their responses. Both types of calls can be canceled via the Call or the OkHttpClient . URLConnection support has moved to the okhttp-urlconnection module. If you\u2019re upgrading from 1.x, this change will impact you. You will need to add the okhttp-urlconnection module to your project and use the OkUrlFactory to create new instances of HttpURLConnection : // OkHttp 1.x: HttpURLConnection connection = client . open ( url ); // OkHttp 2.x: HttpURLConnection connection = new OkUrlFactory ( client ). open ( url ); Custom caches are no longer supported. In OkHttp 1.x it was possible to define your own response cache with the java.net.ResponseCache and OkHttp\u2019s OkResponseCache interfaces. Both of these APIs have been dropped. In OkHttp 2 the built-in disk cache is the only supported response cache. HttpResponseCache has been renamed to Cache. Install it with OkHttpClient.setCache(...) instead of OkHttpClient.setResponseCache(...) . OkAuthenticator has been replaced with Authenticator. This new authenticator has access to the full incoming response and can respond with whichever followup request is appropriate. The Challenge class is now a top-level class and Credential is replaced with a utility class called Credentials . OkHttpClient.getFollowProtocolRedirects() renamed to getFollowSslRedirects() . We reserve the word protocol for the HTTP version being used (HTTP/1.1, HTTP/2). The old name of this method was misleading; it was always used to configure redirects between https:// and http:// schemes. RouteDatabase is no longer public API. OkHttp continues to track which routes have failed but this is no exposed in the API. ResponseSource is gone. This enum exposed whether a response came from the cache, network, or both. OkHttp 2 offers more detail with raw access to the cache and network responses in the new Response class. TunnelRequest is gone. It specified how to connect to an HTTP proxy. OkHttp 2 uses the new Request class for this. Dispatcher is a new class that manages the queue of asynchronous calls. It implements limits on total in-flight calls and in-flight calls per host. Implementation changes \u00b6 Support Android TrafficStats socket tagging. Drop authentication headers on redirect. Added support for compressed data frames. Process push promise callbacks in order. Update to http/2 draft 12. Update to HPACK draft 07. Add ALPN support. Maven will use ALPN on OpenJDK 8. Update NPN dependency to target jdk7u60-b13 and Oracle jdk7u55-b13 . Ensure SPDY variants support zero-length DELETE and POST. Prevent leaking a cache item\u2019s InputStreams when metadata read fails. Use a string to identify TLS versions in routes. Add frame logger for HTTP/2. Replacing httpMinorVersion with Protocol . Expose HTTP/1.0 as a potential protocol. Use Protocol to describe framing. Implement write timeouts for HTTP/1.1 streams. Avoid use of SPDY stream ID 1, as that\u2019s typically used for UPGRADE. Support OAuth in Authenticator . Permit a dangling semicolon in media type parsing. Version 1.x \u00b6 Change log","title":"Changelog 2x"},{"location":"changelog_2x/#okhttp-2x-change-log","text":"","title":"OkHttp 2.x Change Log"},{"location":"changelog_2x/#version-275","text":"2016-02-25 Fix: Change the certificate pinner to always build full chains. This prevents a potential crash when using certificate pinning with the Google Play Services security provider.","title":"Version 2.7.5"},{"location":"changelog_2x/#version-274","text":"2016-02-07 Fix: Don\u2019t crash when finding the trust manager if the Play Services (GMS) security provider is installed. Fix: The previous release introduced a performance regression on Android, caused by looking up CA certificates. This is now fixed.","title":"Version 2.7.4"},{"location":"changelog_2x/#version-273","text":"2016-02-06 Fix: Permit the trusted CA root to be pinned by CertificatePinner .","title":"Version 2.7.3"},{"location":"changelog_2x/#version-272","text":"2016-01-07 Fix: Don\u2019t eagerly release stream allocations on cache hits. We might still need them to handle redirects.","title":"Version 2.7.2"},{"location":"changelog_2x/#version-271","text":"2016-01-01 Fix: Don\u2019t do a health check on newly-created connections. This is unnecessary work that could put the client in an inconsistent state if the health check fails.","title":"Version 2.7.1"},{"location":"changelog_2x/#version-270","text":"2015-12-13 Rewritten connection management. Previously OkHttp\u2019s connection pool managed both idle and active connections for HTTP/2, but only idle connections for HTTP/1.x. With this update the connection pool manages both idle and active connections for everything. OkHttp now detects and warns on connections that were allocated but never released, and will enforce HTTP/2 stream limits. This update also fixes Call.cancel() to not do I/O on the calling thread. Fix: Don\u2019t log gzipped data in the logging interceptor. Fix: Don\u2019t resolve DNS addresses when connecting through a SOCKS proxy. Fix: Drop the synthetic OkHttp-Selected-Protocol response header. Fix: Support 204 and 205 \u2018No Content\u2019 replies in the logging interceptor. New: Add Call.isExecuted() .","title":"Version 2.7.0"},{"location":"changelog_2x/#version-260","text":"2015-11-22 New Logging Interceptor. The logging-interceptor subproject offers simple request and response logging. It may be configured to log headers and bodies for debugging. It requires this Maven dependency: <dependency> <groupId> com.squareup.okhttp </groupId> <artifactId> logging-interceptor </artifactId> <version> 2.6.0 </version> </dependency> Configure basic logging like this: HttpLoggingInterceptor loggingInterceptor = new HttpLoggingInterceptor (); loggingInterceptor . setLevel ( HttpLoggingInterceptor . Level . BASIC ); client . networkInterceptors (). add ( loggingInterceptor ); Warning: Avoid Level.HEADERS and Level.BODY in production because they could leak passwords and other authentication credentials to insecure logs. WebSocket API now uses RequestBody and ResponseBody for messages. This is a backwards-incompatible API change. The DNS service is now pluggable. In some situations this may be useful to manually prioritize specific IP addresses. Fix: Don\u2019t throw when converting an HttpUrl to a java.net.URI . Previously URLs with special characters like | and [ would break when subjected to URI\u2019s overly-strict validation. Fix: Don\u2019t re-encode + as %20 in encoded URL query strings. OkHttp prefers %20 when doing its own encoding, but will retain + when that is provided. Fix: Enforce that callers call WebSocket.close() on IO errors. Error handling in WebSockets is significantly improved. Fix: Don\u2019t use SPDY/3 style header concatenation for HTTP/2 request headers. This could have corrupted requests where multiple headers had the same name, as in cookies. Fix: Reject bad characters in the URL hostname. Previously characters like \\0 would cause a late crash when building the request. Fix: Allow interceptors to change the request method. Fix: Don\u2019t use the request\u2019s User-Agent or Proxy-Authorization when connecting to an HTTPS server via an HTTP tunnel. The Proxy-Authorization header was being leaked to the origin server. Fix: Digits may be used in a URL scheme. Fix: Improve connection timeout recovery. Fix: Recover from getsockname crashes impacting Android releases prior to 4.2.2. Fix: Drop partial support for HTTP/1.0. Previously OkHttp would send HTTP/1.0 on connections after seeing a response with HTTP/1.0 . The fixed behavior is consistent with Firefox and Chrome. Fix: Allow a body in OPTIONS requests. Fix: Don\u2019t percent-encode non-ASCII characters in URL fragments. Fix: Handle null fragments. Fix: Don\u2019t crash on interceptors that throw IOException before a connection is attempted. New: Support WebDAV HTTP methods. New: Buffer WebSocket frames for better performance. New: Drop support for TLS_DHE_DSS_WITH_AES_128_CBC_SHA , our only remaining DSS cipher suite. This is consistent with Firefox and Chrome which have also dropped these cipher suite.","title":"Version 2.6.0"},{"location":"changelog_2x/#version-250","text":"2015-08-25 Timeouts now default to 10 seconds. Previously we defaulted to never timing out, and that was a lousy policy. If establishing a connection, reading the next byte from a connection, or writing the next byte to a connection takes more than 10 seconds to complete, you\u2019ll need to adjust the timeouts manually. OkHttp now rejects request headers that contain invalid characters. This includes potential security problems (newline characters) as well as simple non-ASCII characters (including international characters and emoji). Call canceling is more reliable. We had a bug where a socket being connected wasn\u2019t being closed when the application used Call.cancel() . Changing a HttpUrl\u2019s scheme now tracks the default port. We had a bug where changing a URL from http to https would leave it on port 80. Okio has been updated to 1.6.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.6.0 </version> </dependency> New: Cache.initialize() . Call this on a background thread to eagerly initialize the response cache. New: Fold MockWebServerRule into MockWebServer . This makes it easier to write JUnit tests with MockWebServer . The MockWebServer library now depends on JUnit, though it continues to work with all testing frameworks. Fix: FormEncodingBuilder is now consistent with browsers in which characters it escapes. Previously we weren\u2019t percent-encoding commas, parens, and other characters. Fix: Relax FormEncodingBuilder to support building empty forms. Fix: Timeouts throw SocketTimeoutException , not InterruptedIOException . Fix: Change MockWebServer to use the same logic as OkHttp when determining whether an HTTP request permits a body. Fix: HttpUrl now uses the canonical form for IPv6 addresses. Fix: Use HttpUrl internally. Fix: Recover from Android 4.2.2 EBADF crashes. Fix: Don\u2019t crash with an IllegalStateException if an HTTP/2 or SPDY write fails, leaving the connection in an inconsistent state. Fix: Make sure the default user agent is ASCII.","title":"Version 2.5.0"},{"location":"changelog_2x/#version-240","text":"2015-05-22 Forbid response bodies on HTTP 204 and 205 responses. Webservers that return such malformed responses will now trigger a ProtocolException in the client. WebSocketListener has incompatible changes. The onOpen() method is now called on the reader thread, so implementations must return before further websocket messages will be delivered. The onFailure() method now includes an HTTP response if one was returned.","title":"Version 2.4.0"},{"location":"changelog_2x/#version-240-rc1","text":"2015-05-16 New HttpUrl API. It\u2019s like java.net.URL but good. Note that Request.Builder.url() now throws IllegalArgumentException on malformed URLs. (Previous releases would throw a MalformedURLException when calling a malformed URL.) We\u2019ve improved connect failure recovery. We now differentiate between setup, connecting, and connected and implement appropriate recovery rules for each. This changes Address to no longer use ConnectionSpec . (This is an incompatible API change). FormEncodingBuilder now uses %20 instead of + for encoded spaces. Both are permitted-by-spec, but %20 requires fewer special cases. Okio has been updated to 1.4.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.4.0 </version> </dependency> Request.Builder no longer accepts null if a request body is required. Passing null will now fail for request methods that require a body. Instead use an empty body such as this one: RequestBody . create ( null , new byte [ 0 ] ); CertificatePinner now supports wildcard hostnames. As always with certificate pinning, you must be very careful to avoid bricking your app. You\u2019ll need to pin both the top-level domain and the *. domain for full coverage. client . setCertificatePinner ( new CertificatePinner . Builder () . add ( \"publicobject.com\" , \"sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=\" ) . add ( \"*.publicobject.com\" , \"sha1/DmxUShsZuNiqPQsX2Oi9uv2sCnw=\" ) . add ( \"publicobject.com\" , \"sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=\" ) . add ( \"*.publicobject.com\" , \"sha1/SXxoaOSEzPC6BgGmxAt/EAcsajw=\" ) . add ( \"publicobject.com\" , \"sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=\" ) . add ( \"*.publicobject.com\" , \"sha1/blhOM3W9V/bVQhsWAcLYwPU6n24=\" ) . add ( \"publicobject.com\" , \"sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=\" ) . add ( \"*.publicobject.com\" , \"sha1/T5x9IXmcrQ7YuQxXnxoCmeeQ84c=\" ) . build ()); Interceptors lists are now deep-copied by OkHttpClient.clone() . Previously clones shared interceptors, which made it difficult to customize the interceptors on a request-by-request basis. New: Headers.toMultimap() . New: RequestBody.create(MediaType, ByteString) . New: ConnectionSpec.isCompatible(SSLSocket) . New: Dispatcher.getQueuedCallCount() and Dispatcher.getRunningCallCount() . These can be useful in diagnostics. Fix: OkHttp no longer shares timeouts between pooled connections. This was causing some applications to crash when connections were reused. Fix: OkApacheClient now allows an empty PUT and POST . Fix: Websockets no longer rebuffer socket streams. Fix: Websockets are now better at handling close frames. Fix: Content type matching is now case insensitive. Fix: Vary headers are not lost with android.net.http.HttpResponseCache . Fix: HTTP/2 wasn\u2019t enforcing stream timeouts when writing the underlying connection. Now it is. Fix: Never return null on call.proceed() . This was a bug in call cancelation. Fix: When a network interceptor mutates a request, that change is now reflected in Response.networkResponse() . Fix: Badly-behaving caches now throw a checked exception instead of a NullPointerException . Fix: Better handling of uncaught exceptions in MockWebServer with HTTP/2.","title":"Version 2.4.0-RC1"},{"location":"changelog_2x/#version-230","text":"2015-03-16 HTTP/2 support. We\u2019ve done interop testing and haven\u2019t seen any problems. HTTP/2 support has been a big effort and we\u2019re particularly thankful to Adrian Cole who has helped us to reach this milestone. RC4 cipher suites are no longer supported by default. To connect to old, obsolete servers relying on these cipher suites, you must create a custom ConnectionSpec . Beta WebSockets support. . The okhttp-ws subproject offers a new websockets client. Please try it out! When it\u2019s ready we intend to include it with the core OkHttp library. Okio updated to 1.3.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.3.0 </version> </dependency> Fix: improve parallelism of async requests. OkHttp\u2019s Dispatcher had a misconfigured ExecutorService that limited the number of worker threads. If you\u2019re using Call.enqueue() this update should significantly improve request concurrency. Fix: Lazily initialize the response cache. This avoids strict mode warnings when initializing OkHttp on Android\u2018s main thread. Fix: Disable ALPN on Android 4.4. That release of the feature was unstable and prone to native crashes in the underlying OpenSSL code. Fix: Don\u2019t send both If-None-Match and If-Modified-Since cache headers when both are applicable. Fix: Fail early when a port is out of range. Fix: Offer Content-Length headers for multipart request bodies. Fix: Throw UnknownServiceException if a cleartext connection is attempted when explicitly forbidden. Fix: Throw a SSLPeerUnverifiedException when host verification fails. Fix: MockWebServer explicitly closes sockets. (On some Android releases, closing the input stream and output stream of a socket is not sufficient. Fix: Buffer outgoing HTTP/2 frames to limit how many outgoing frames are created. Fix: Avoid crashing when cache writing fails due to a full disk. Fix: Improve caching of private responses. Fix: Update cache-by-default response codes. Fix: Reused Request.Builder instances no longer hold stale URL fields. New: ConnectionSpec can now be configured to use the SSL socket\u2019s default cipher suites. To use, set the cipher suites to null . New: Support DELETE with a request body. New: Headers.of(Map) creates headers from a Map.","title":"Version 2.3.0"},{"location":"changelog_2x/#version-220","text":"2014-12-30 RequestBody.contentLength() now throws IOException . This is a source-incompatible change. If you have code that calls RequestBody.contentLength() , your compile will break with this update. The change is binary-compatible, however: code compiled for OkHttp 2.0 and 2.1 will continue to work with this update. COMPATIBLE_TLS no longer supports SSLv3. In response to the POODLE vulnerability, OkHttp no longer offers SSLv3 when negotiation an HTTPS connection. If you continue to need to connect to webservers running SSLv3, you must manually configure your own ConnectionSpec . OkHttp now offers interceptors. Interceptors are a powerful mechanism that can monitor, rewrite, and retry calls. The interceptors doc is a full introduction to this new API. New: APIs to iterate and selectively clear the response cache. New: Support for SOCKS proxies. New: Support for TLS_FALLBACK_SCSV . New: Update HTTP/2 support to h2-16 and hpack-10 . New: APIs to prevent retrying non-idempotent requests. Fix: Drop NPN support. Going forward we support ALPN only. Fix: The hostname verifier is now strict. This is consistent with the hostname verifier in modern browsers. Fix: Improve CONNECT handling for misbehaving HTTP proxies. Fix: Don\u2019t retry requests that failed due to timeouts. Fix: Cache 302s and 308s that include appropriate response headers. Fix: Improve pooling of connections that use proxy selectors. Fix: Don\u2019t leak connections when using ALPN on the desktop. Fix: Update Jetty ALPN to 7.1.2.v20141202 (Java 7) and 8.1.2.v20141202 (Java 8). This fixes a bug in resumed TLS sessions where the wrong protocol could be selected. Fix: Don\u2019t crash in SPDY and HTTP/2 when disconnecting before connecting. Fix: Avoid a reverse DNS-lookup for a numeric proxy address Fix: Resurrect http/2 frame logging. Fix: Limit to 20 authorization attempts.","title":"Version 2.2.0"},{"location":"changelog_2x/#version-210","text":"2014-11-11 New: Typesafe APIs for interacting with cipher suites and TLS versions. Fix: Don\u2019t crash when mixing authorization challenges with upload retries.","title":"Version 2.1.0"},{"location":"changelog_2x/#version-210-rc1","text":"2014-11-04 OkHttp now caches private responses . We\u2019ve changed from a shared cache to a private cache, and will now store responses that use an Authorization header. This means OkHttp\u2019s cache shouldn\u2019t be used on middleboxes that sit between user agents and the origin server. TLS configuration updated. OkHttp now explicitly enables TLSv1.2, TLSv1.1 and TLSv1.0 where they are supported. It will continue to perform only one fallback, to SSLv3. Applications can now configure this with the ConnectionSpec class. To disable TLS fallback: client . setConnectionSpecs ( Arrays . asList ( ConnectionSpec . MODERN_TLS , ConnectionSpec . CLEARTEXT )); To disable cleartext connections, permitting https URLs only: client . setConnectionSpecs ( Arrays . asList ( ConnectionSpec . MODERN_TLS , ConnectionSpec . COMPATIBLE_TLS )); New cipher suites. Please confirm that your webservers are reachable with this limited set of cipher suites. Android Name Version TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 5.0 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 5.0 TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 5.0 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA 4.0 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA 4.0 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA 4.0 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA 4.0 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA 4.0 TLS_ECDHE_RSA_WITH_RC4_128_SHA 4.0 TLS_DHE_RSA_WITH_AES_128_CBC_SHA 2.3 TLS_DHE_DSS_WITH_AES_128_CBC_SHA 2.3 TLS_DHE_RSA_WITH_AES_256_CBC_SHA 2.3 TLS_RSA_WITH_AES_128_GCM_SHA256 5.0 TLS_RSA_WITH_AES_128_CBC_SHA 2.3 TLS_RSA_WITH_AES_256_CBC_SHA 2.3 SSL_RSA_WITH_3DES_EDE_CBC_SHA 2.3 (Deprecated in 5.0) SSL_RSA_WITH_RC4_128_SHA 2.3 SSL_RSA_WITH_RC4_128_MD5 2.3 (Deprecated in 5.0) Okio updated to 1.0.1. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.0.1 </version> </dependency> New APIs to permit easy certificate pinning. Be warned, certificate pinning is dangerous and could prevent your application from trusting your server! Cache improvements. This release fixes some severe cache problems including a bug where the cache could be corrupted upon certain access patterns. We also fixed a bug where the cache was being cleared due to a corrupted journal. We\u2019ve added APIs to configure a request\u2019s Cache-Control headers, and to manually clear the cache. Request cancellation fixes. This update fixes a bug where synchronous requests couldn\u2019t be canceled by tag. This update avoids crashing when onResponse() throws an IOException . That failure will now be logged instead of notifying the thread\u2019s uncaught exception handler. We\u2019ve added a new API, Call.isCanceled() to check if a call has been canceled. New: Update MultipartBuilder to support content length. New: Make it possible to mock OkHttpClient and Call . New: Update to h2-14 and hpack-9. New: OkHttp includes a user-agent by default, like okhttp/2.1.0-RC1 . Fix: Handle response code 308 Permanent Redirect . Fix: Don\u2019t skip the callback if a call is canceled. Fix: Permit hostnames with underscores. Fix: Permit overriding the content-type in OkApacheClient . Fix: Use the socket factory for direct connections. Fix: Honor OkUrlFactory APIs that disable redirects. Fix: Don\u2019t crash on concurrent modification of SPDY SPDY settings.","title":"Version 2.1.0-RC1"},{"location":"changelog_2x/#version-200","text":"This release commits to a stable 2.0 API. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x. 2014-06-21 API Change : Use IOException in Callback.onFailure() . This is a source-incompatible change, and is different from OkHttp 2.0.0-RC2 which used Throwable . Fix: Fixed a caching bug where we weren\u2019t storing rewritten request headers like Accept-Encoding . Fix: Fixed bugs in handling the SPDY window size. This was stalling certain large downloads Update the language level to Java 7. (OkHttp requires Android 2.3+ or Java 7+.)","title":"Version 2.0.0"},{"location":"changelog_2x/#version-200-rc2","text":"2014-06-11 This update fixes problems in 2.0.0-RC1. Read the 2.0.0-RC1 changes for advice on upgrading from 1.x to 2.x. Fix: Don\u2019t leak connections! There was a regression in 2.0.0-RC1 where connections were neither closed nor pooled. Fix: Revert builder-style return types from OkHttpClient\u2019s timeout methods for binary compatibility with OkHttp 1.x. Fix: Don\u2019t skip client stream 1 on SPDY/3.1. This fixes SPDY connectivity to https://google.com , which doesn\u2019t follow the SPDY/3.1 spec! Fix: Always configure NPN headers. This fixes connectivity to https://facebook.com when SPDY and HTTP/2 are both disabled. Otherwise an unexpected NPN response is received and OkHttp crashes. Fix: Write continuation frames when HPACK data is larger than 16383 bytes. Fix: Don\u2019t drop uncaught exceptions thrown in async calls. Fix: Throw an exception eagerly when a request body is not legal. Previously we ignored the problem at request-building time, only to crash later with a NullPointerException . Fix: Include a backwards-compatible OkHttp-Response-Source header with OkUrlFactory responses. Fix: Don\u2019t include a default User-Agent header in requests made with the Call API. Requests made with OkUrlFactory will continue to have a default user agent. New: Guava-like API to create headers: Headers headers = Headers . of ( name1 , value1 , name2 , value2 , ...). New: Make the content-type header optional for request bodies. New: Response.isSuccessful() is a convenient API to check response codes. New: The response body can now be read outside of the callback. Response bodies must always be closed, otherwise they will leak connections! New: APIs to create multipart request bodies ( MultipartBuilder ) and form encoding bodies ( FormEncodingBuilder ).","title":"Version 2.0.0-RC2"},{"location":"changelog_2x/#version-200-rc1","text":"2014-05-23 OkHttp 2 is designed around a new API that is true to HTTP, with classes for requests, responses, headers, and calls. It uses modern Java patterns like immutability and chained builders. The API now offers asynchronous callbacks in addition to synchronous blocking calls.","title":"Version 2.0.0-RC1"},{"location":"changelog_2x/#api-changes","text":"New Request and Response types, each with their own builder. There\u2019s also a RequestBody class to write the request body to the network and a ResponseBody to read the response body from the network. The standalone Headers class offers full access to the HTTP headers. Okio dependency added. OkHttp now depends on Okio , an I/O library that makes it easier to access, store and process data. Using this library internally makes OkHttp faster while consuming less memory. You can write a RequestBody as an Okio BufferedSink and a ResponseBody as an Okio BufferedSource . Standard InputStream and OutputStream access is also available. New Call and Callback types execute requests and receive their responses. Both types of calls can be canceled via the Call or the OkHttpClient . URLConnection support has moved to the okhttp-urlconnection module. If you\u2019re upgrading from 1.x, this change will impact you. You will need to add the okhttp-urlconnection module to your project and use the OkUrlFactory to create new instances of HttpURLConnection : // OkHttp 1.x: HttpURLConnection connection = client . open ( url ); // OkHttp 2.x: HttpURLConnection connection = new OkUrlFactory ( client ). open ( url ); Custom caches are no longer supported. In OkHttp 1.x it was possible to define your own response cache with the java.net.ResponseCache and OkHttp\u2019s OkResponseCache interfaces. Both of these APIs have been dropped. In OkHttp 2 the built-in disk cache is the only supported response cache. HttpResponseCache has been renamed to Cache. Install it with OkHttpClient.setCache(...) instead of OkHttpClient.setResponseCache(...) . OkAuthenticator has been replaced with Authenticator. This new authenticator has access to the full incoming response and can respond with whichever followup request is appropriate. The Challenge class is now a top-level class and Credential is replaced with a utility class called Credentials . OkHttpClient.getFollowProtocolRedirects() renamed to getFollowSslRedirects() . We reserve the word protocol for the HTTP version being used (HTTP/1.1, HTTP/2). The old name of this method was misleading; it was always used to configure redirects between https:// and http:// schemes. RouteDatabase is no longer public API. OkHttp continues to track which routes have failed but this is no exposed in the API. ResponseSource is gone. This enum exposed whether a response came from the cache, network, or both. OkHttp 2 offers more detail with raw access to the cache and network responses in the new Response class. TunnelRequest is gone. It specified how to connect to an HTTP proxy. OkHttp 2 uses the new Request class for this. Dispatcher is a new class that manages the queue of asynchronous calls. It implements limits on total in-flight calls and in-flight calls per host.","title":"API Changes"},{"location":"changelog_2x/#implementation-changes","text":"Support Android TrafficStats socket tagging. Drop authentication headers on redirect. Added support for compressed data frames. Process push promise callbacks in order. Update to http/2 draft 12. Update to HPACK draft 07. Add ALPN support. Maven will use ALPN on OpenJDK 8. Update NPN dependency to target jdk7u60-b13 and Oracle jdk7u55-b13 . Ensure SPDY variants support zero-length DELETE and POST. Prevent leaking a cache item\u2019s InputStreams when metadata read fails. Use a string to identify TLS versions in routes. Add frame logger for HTTP/2. Replacing httpMinorVersion with Protocol . Expose HTTP/1.0 as a potential protocol. Use Protocol to describe framing. Implement write timeouts for HTTP/1.1 streams. Avoid use of SPDY stream ID 1, as that\u2019s typically used for UPGRADE. Support OAuth in Authenticator . Permit a dangling semicolon in media type parsing.","title":"Implementation changes"},{"location":"changelog_2x/#version-1x","text":"Change log","title":"Version 1.x"},{"location":"changelog_3x/","text":"OkHttp 3.x Change Log \u00b6 Version 3.14.9 \u00b6 2020-05-17 Fix: Don\u2019t crash when running as a plugin in Android Studio Canary 4.1. To enable platform-specific TLS features OkHttp must detect whether it\u2019s running in a JVM or in Android. The upcoming Android Studio runs in a JVM but has classes from Android and that confused OkHttp! Version 3.14.8 \u00b6 2020-04-28 Fix: Don\u2019t crash on Java 8u252 which introduces an API previously found only on Java 9 and above. See Jetty\u2019s overview of the API change and its consequences. Version 3.14.7 \u00b6 2020-02-24 Fix: Don\u2019t crash on Android 11 due to use of restricted methods. This prevents a crash with the exception, \u201cExpected Android API level 21+ but was 29\u201d. Version 3.14.6 \u00b6 2020-01-11 Fix: Don\u2019t crash if the connection is closed when sending a degraded ping. This fixes a regression that was introduced in OkHttp 3.14.5. Version 3.14.5 \u00b6 2020-01-03 Fix: Degrade HTTP/2 connections after a timeout. When an HTTP/2 stream times out it may impact the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after a stream timeout to determine whether the connection should remain eligible for pooling. Version 3.14.4 \u00b6 2019-09-29 Fix: Cancel calls that fail due to unexpected exceptions. We had a bug where an enqueued call would never call back if it crashed with an unchecked throwable, such as a NullPointerException or OutOfMemoryError . We now call Callback.onFailure() with an IOException that reports the call as canceled. The triggering exception is still delivered to the thread\u2019s UncaughtExceptionHandler . Fix: Don\u2019t evict incomplete entries when iterating the cache. We had a bug where iterating Cache.urls() would prevent in-flight entries from being written. Version 3.14.3 \u00b6 2019-09-10 Fix: Don\u2019t lose HTTP/2 flow control bytes when incoming data races with a stream close. If this happened enough then eventually the connection would stall. Fix: Acknowledge and apply inbound HTTP/2 settings atomically. Previously we had a race where we could use new flow control capacity before acknowledging it, causing strict HTTP/2 servers to fail the call. Fix: Recover gracefully when a coalesced connection immediately goes unhealthy. Version 3.14.2 \u00b6 2019-05-19 Fix: Lock in a route when recovering from an HTTP/2 connection error. We had a bug where two calls that failed at the same time could cause OkHttp to crash with a NoSuchElementException instead of the expected IOException . Fix: Don\u2019t crash with a NullPointerException when formatting an error message describing a truncated response from an HTTPS proxy. Version 3.14.1 \u00b6 2019-04-10 Fix: Don\u2019t crash when an interceptor retries when there are no more routes. This was an edge-case regression introduced with the events cleanup in 3.14.0. Fix: Provide actionable advice when the exchange is non-null. Prior to 3.14, OkHttp would silently leak connections when an interceptor retries without closing the response body. With 3.14 we detect this problem but the exception was not helpful. Version 3.14.0 \u00b6 2019-03-14 This release deletes the long-deprecated OkUrlFactory and OkApacheClient APIs. These facades hide OkHttp\u2019s implementation behind another client\u2019s API. If you still need this please copy and paste ObsoleteUrlFactory.java or ObsoleteApacheClient.java into your project. OkHttp now supports duplex calls over HTTP/2. With normal HTTP calls the request must finish before the response starts. With duplex, request and response bodies are transmitted simultaneously. This can be used to implement interactive conversations within a single HTTP call. Create duplex calls by overriding the new RequestBody.isDuplex() method to return true. This simple option dramatically changes the behavior of the request body and of the entire call. The RequestBody.writeTo() method may now retain a reference to the provided sink and hand it off to another thread to write to it after writeTo returns. The EventListener may now see requests and responses interleaved in ways not previously permitted. For example, a listener may receive responseHeadersStart() followed by requestBodyEnd() , both on the same call. Such events may be triggered by different threads even for a single call. Interceptors that rewrite or replace the request body may now inadvertently interfere with duplex request bodies. Such interceptors should check RequestBody.isDuplex() and avoid accessing the request body when it is. Duplex calls require HTTP/2. If HTTP/1 is established instead the duplex call will fail. The most common use of duplex calls is gRPC . New: Prevent OkHttp from retransmitting a request body by overriding RequestBody.isOneShot() . This is most useful when writing the request body is destructive. New: We\u2019ve added requestFailed() and responseFailed() methods to EventListener . These are called instead of requestBodyEnd() and responseBodyEnd() in some failure situations. They may also be fired in cases where no event was published previously. In this release we did an internal rewrite of our event code to fix problems where events were lost or unbalanced. Fix: Don\u2019t leak a connection when a call is canceled immediately preceding the onFailure() callback. Fix: Apply call timeouts when connecting duplex calls, web sockets, and server-sent events. Once the streams are established no further timeout is enforced. Fix: Retain the Route when a connection is reused on a redirect or other follow-up. This was causing some Authenticator calls to see a null route when non-null was expected. Fix: Use the correct key size in the name of TLS_AES_128_CCM_8_SHA256 which is a TLS 1.3 cipher suite. We accidentally specified a key size of 256, preventing that cipher suite from being selected for any TLS handshakes. We didn\u2019t notice because this cipher suite isn\u2019t supported on Android, Java, or Conscrypt. We removed this cipher suite and TLS_AES_128_CCM_SHA256 from the restricted, modern, and compatible sets of cipher suites. These two cipher suites aren\u2019t enabled by default in either Firefox or Chrome. See our TLS Configuration History tracker for a log of all changes to OkHttp\u2019s default TLS options. New: Upgrade to Conscrypt 2.0.0. OkHttp works with other versions of Conscrypt but this is the version we\u2019re testing against. implementation ( \"org.conscrypt:conscrypt-openjdk-uber:2.0.0\" ) New: Update the embedded public suffixes list. Version 3.13.1 \u00b6 2019-02-05 Fix: Don\u2019t crash when using a custom X509TrustManager or SSLSocket on Android. When we removed obsolete code for Android 4.4 we inadvertently also removed support for custom subclasses. We\u2019ve restored that support! Version 3.13.0 \u00b6 2019-02-04 This release bumps our minimum requirements to Java 8+ or Android 5+. Cutting off old devices is a serious change and we don\u2019t do it lightly! This post explains why we\u2019re doing this and how to upgrade. The OkHttp 3.12.x branch will be our long-term branch for Android 2.3+ (API level 9+) and Java 7+. These platforms lack support for TLS 1.2 and should not be used. But because upgrading is difficult we will backport critical fixes to the 3.12.x branch through December 31, 2021. (This commitment was originally through December 31, 2020; we have since extended it.) TLSv1 and TLSv1.1 are no longer enabled by default. Major web browsers are working towards removing these versions altogether in early 2020. If your servers aren\u2019t ready yet you can configure OkHttp 3.13 to allow TLSv1 and TLSv1.1 connections: OkHttpClient client = new OkHttpClient.Builder() .connectionSpecs(Arrays.asList(ConnectionSpec.COMPATIBLE_TLS)) .build(); New: You can now access HTTP trailers with Response.trailers() . This method may only be called after the entire HTTP response body has been read. New: Upgrade to Okio 1.17.3. If you\u2019re on Kotlin-friendly Okio 2.x this release requires 2.2.2 or newer. implementation ( \"com.squareup.okio:okio:1.17.3\" ) Fix: Don\u2019t miss cancels when sending HTTP/2 request headers. Fix: Don\u2019t miss whole operation timeouts when calls redirect. Fix: Don\u2019t leak connections if web sockets have malformed responses or if onOpen() throws. Fix: Don\u2019t retry when request bodies fail due to FileNotFoundException . Fix: Don\u2019t crash when URLs have IPv4-mapped IPv6 addresses. Fix: Don\u2019t crash when building HandshakeCertificates on Android API 28. Fix: Permit multipart file names to contain non-ASCII characters. New: API to get MockWebServer\u2019s dispatcher. New: API to access headers as java.time.Instant . New: Fail fast if a SSLSocketFactory is used as a SocketFactory . New: Log the TLS handshake in LoggingEventListener . Version 3.12.12 \u00b6 2020-05-17 Fix: Don\u2019t crash when running as a plugin in Android Studio Canary 4.1. To enable platform-specific TLS features OkHttp must detect whether it\u2019s running in a JVM or in Android. The upcoming Android Studio runs in a JVM but has classes from Android and that confused OkHttp! Version 3.12.11 \u00b6 2020-04-28 Fix: Don\u2019t crash on Java 8u252 which introduces an API previously found only on Java 9 and above. See Jetty\u2019s overview of the API change and its consequences. Version 3.12.10 \u00b6 2020-02-29 Fix: Don\u2019t crash on Android 4.1 when detecting methods that became restricted in Android 11. Supporting a full decade of Android releases on our 3.12.x branch is tricky! Version 3.12.9 \u00b6 2020-02-24 Fix: Don\u2019t crash on Android 11 due to use of restricted methods. This prevents a crash with the exception, \u201cExpected Android API level 21+ but was 29\u201d. Version 3.12.8 \u00b6 2020-01-11 Fix: Don\u2019t crash if the connection is closed when sending a degraded ping. This fixes a regression that was introduced in OkHttp 3.12.7. Version 3.12.7 \u00b6 2020-01-03 Fix: Degrade HTTP/2 connections after a timeout. When an HTTP/2 stream times out it may impact the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after a stream timeout to determine whether the connection should remain eligible for pooling. Version 3.12.6 \u00b6 2019-09-29 Fix: Cancel calls that fail due to unexpected exceptions. We had a bug where an enqueued call would never call back if it crashed with an unchecked throwable, such as a NullPointerException or OutOfMemoryError . We now call Callback.onFailure() with an IOException that reports the call as canceled. The triggering exception is still delivered to the thread\u2019s UncaughtExceptionHandler . Fix: Don\u2019t evict incomplete entries when iterating the cache. We had a bug where iterating Cache.urls() would prevent in-flight entries from being written. Version 3.12.5 \u00b6 2019-09-10 Fix: Don\u2019t lose HTTP/2 flow control bytes when incoming data races with a stream close. If this happened enough then eventually the connection would stall. Fix: Acknowledge and apply inbound HTTP/2 settings atomically. Previously we had a race where we could use new flow control capacity before acknowledging it, causing strict HTTP/2 servers to fail the call. Version 3.12.4 \u00b6 2019-09-04 Fix: Don\u2019t crash looking up an absent class on certain buggy Android 4.x devices. Version 3.12.3 \u00b6 2019-05-07 Fix: Permit multipart file names to contain non-ASCII characters. Fix: Retain the Route when a connection is reused on a redirect or other follow-up. This was causing some Authenticator calls to see a null route when non-null was expected. Version 3.12.2 \u00b6 2019-03-14 Fix: Don\u2019t crash if the HTTPS server returns no certificates in the TLS handshake. Fix: Don\u2019t leak a connection when a call is canceled immediately preceding the onFailure() callback. Version 3.12.1 \u00b6 2018-12-23 Fix: Remove overlapping package-info.java . This caused issues with some build tools. Version 3.12.0 \u00b6 2018-11-16 OkHttp now supports TLS 1.3. This requires either Conscrypt or Java 11+. Proxy authenticators are now asked for preemptive authentication. OkHttp will now request authentication credentials before creating TLS tunnels through HTTP proxies (HTTP CONNECT ). Authenticators should identify preemptive authentications by the presence of a challenge whose scheme is \u201cOkHttp-Preemptive\u201d. OkHttp now offers full-operation timeouts. This sets a limit on how long the entire call may take and covers resolving DNS, connecting, writing the request body, server processing, and reading the full response body. If a call requires redirects or retries all must complete within one timeout period. Use OkHttpClient.Builder.callTimeout() to specify the default duration and Call.timeout() to specify the timeout of an individual call. New: Return values and fields are now non-null unless otherwise annotated. New: LoggingEventListener makes it easy to get basic visibility into a call\u2019s performance. This class is in the logging-interceptor artifact. New: Headers.Builder.addUnsafeNonAscii() allows non-ASCII values to be added without an immediate exception. New: Headers can be redacted in HttpLoggingInterceptor . New: Headers.Builder now accepts dates. New: OkHttp now accepts java.time.Duration for timeouts on Java 8+ and Android 26+. New: Challenge includes all authentication parameters. New: Upgrade to BouncyCastle 1.60, Conscrypt 1.4.0, and Okio 1.15.0. We don\u2019t yet require Kotlin-friendly Okio 2.x but OkHttp works fine with that series. implementation ( \"org.bouncycastle:bcprov-jdk15on:1.60\" ) implementation ( \"org.conscrypt:conscrypt-openjdk-uber:1.4.0\" ) implementation ( \"com.squareup.okio:okio:1.15.0\" ) Fix: Handle dispatcher executor shutdowns gracefully. When there aren\u2019t any threads to carry a call its callback now gets a RejectedExecutionException . Fix: Don\u2019t permanently cache responses with Cache-Control: immutable . We misunderstood the original immutable proposal! Fix: Change Authenticator \u2018s Route parameter to be nullable. This was marked as non-null but could be called with null in some cases. Fix: Don\u2019t create malformed URLs when MockWebServer is reached via an IPv6 address. Fix: Don\u2019t crash if the system default authenticator is null. Fix: Don\u2019t crash generating elliptic curve certificates on Android. Fix: Don\u2019t crash doing platform detection on RoboVM. Fix: Don\u2019t leak socket connections when web socket upgrades fail. Version 3.11.0 \u00b6 2018-07-12 OkHttp\u2019s new okhttp-tls submodule tames HTTPS and TLS. HeldCertificate is a TLS certificate and its private key. Generate a certificate with its builder then use it to sign another certificate or perform a TLS handshake. The certificatePem() method encodes the certificate in the familiar PEM format ( --- BEGIN CERTIFICATE --- ); the privateKeyPkcs8Pem() does likewise for the private key. HandshakeCertificates holds the TLS certificates required for a TLS handshake. On the server it keeps your HeldCertificate and its chain. On the client it keeps the root certificates that are trusted to sign a server\u2019s certificate chain. HandshakeCertificates also works with mutual TLS where these roles are reversed. These classes make it possible to enable HTTPS in MockWebServer in just a few lines of code . OkHttp now supports prior knowledge cleartext HTTP/2. Enable this by setting Protocol.H2_PRIOR_KNOWLEDGE as the lone protocol on an OkHttpClient.Builder . This mode only supports http: URLs and is best suited in closed environments where HTTPS is inappropriate. New: HttpUrl.get(String) is an alternative to HttpUrl.parse(String) that throws an exception when the URL is malformed instead of returning null. Use this to avoid checking for null in situations where the input is known to be well-formed. We\u2019ve also added MediaType.get(String) which is an exception-throwing alternative to MediaType.parse(String) . New: The EventListener API previewed in OkHttp 3.9 has graduated to a stable API. Use this interface to track metrics and monitor HTTP requests\u2019 size and duration. New: okhttp-dnsoverhttps is an experimental API for doing DNS queries over HTTPS. Using HTTPS for DNS offers better security and potentially better performance. This feature is a preview: the API is subject to change. New: okhttp-sse is an early preview of Server-Sent Events (SSE). This feature is incomplete and is only suitable for experimental use. New: MockWebServer now supports client authentication (mutual TLS). Call requestClientAuth() to permit an optional client certificate or requireClientAuth() to require one. New: RecordedRequest.getHandshake() returns the HTTPS handshake of a request sent to MockWebServer . Fix: Honor the MockResponse header delay in MockWebServer. Fix: Don\u2019t release HTTP/2 connections that have multiple canceled calls. We had a bug where canceling calls would cause the shared HTTP/2 connection to be unnecessarily released. This harmed connection reuse. Fix: Ensure canceled and discarded HTTP/2 data is not permanently counted against the limited flow control window. We had a few bugs where window size accounting was broken when streams were canceled or reset. Fix: Recover gracefully if the TLS session returns an unexpected version ( NONE ) or cipher suite ( SSL_NULL_WITH_NULL_NULL ). Fix: Don\u2019t change Conscrypt configuration globally. We migrated from a process-wide setting to configuring only OkHttp\u2019s TLS sockets. Fix: Prefer TLSv1.2 where it is available. On certain older platforms it is necessary to opt-in to TLSv1.2. New: Request.tag() permits multiple tags. Use a Class<?> as a key to identify tags. Note that tag() now returns null if the request has no tag. Previously this would return the request itself. New: Headers.Builder.addAll(Headers) . New: ResponseBody.create(MediaType, ByteString) . New: Embed R8/ProGuard rules in the jar. These will be applied automatically by R8. Fix: Release the connection if Authenticator throws an exception. Fix: Change the declaration of OkHttpClient.cache() to return a @Nullable Cache . The return value has always been nullable but it wasn\u2019t declared properly. Fix: Reverse suppression of connect exceptions. When both a call and its retry fail, we now throw the initial exception which is most likely to be actionable. Fix: Retain interrupted state when throwing InterruptedIOException . A single interrupt should now be sufficient to break out an in-flight OkHttp call. Fix: Don\u2019t drop a call to EventListener.callEnd() when the response body is consumed inside an interceptor. Version 3.10.0 \u00b6 2018-02-24 The pingInterval() feature now aggressively checks connectivity for web sockets and HTTP/2 connections. Previously if you configured a ping interval that would cause OkHttp to send pings, but it did not track whether the reply pongs were received. With this update OkHttp requires that every ping receive a response: if it does not the connection will be closed and the listener\u2019s onFailure() method will be called. Web sockets have always been had pings, but pings on HTTP/2 connections is new in this release. Pings are used for connections that are busy carrying calls and for idle connections in the connection pool. (Pings do not impact when pooled connections are evicted). If you have a configured ping interval, you should confirm that it is long enough for a roundtrip from client to server. If your ping interval is too short, slow connections may be misinterpreted as failed connections. A ping interval of 30 seconds is reasonable for most use cases. OkHttp now supports Conscrypt . Conscrypt is a Java Security Provider that integrates BoringSSL into the Java platform. Conscrypt supports more cipher suites than the JVM\u2019s default provider and may also execute more efficiently. To use it, first register a Conscrypt dependency in your build system. OkHttp will use Conscrypt if you set the okhttp.platform system property to conscrypt . Alternatively, OkHttp will also use Conscrypt if you install it as your preferred security provider. To do so, add the following code to execute before you create your OkHttpClient . Security.insertProviderAt( new org.conscrypt.OpenSSLProvider(), 1); Conscrypt is the bundled security provider on Android so it is not necessary to configure it on that platform. New: HttpUrl.addQueryParameter() percent-escapes more characters. Previously several ASCII punctuation characters were not percent-escaped when used with this method. This does not impact already-encoded query parameters in APIs like HttpUrl.parse() and HttpUrl.Builder.addEncodedQueryParameter() . New: CBC-mode ECDSA cipher suites have been removed from OkHttp\u2019s default configuration: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA and TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA . This tracks a Chromium change to remove these cipher suites because they are fragile and rarely-used. New: Don\u2019t fall back to common name (CN) verification for hostnames. This behavior was deprecated with RFC 2818 in May 2000 and was recently dropped from major web browsers. New: Honor the Retry-After response header. HTTP 503 (Unavailable) responses are retried automatically if this header is present and its delay is 0 seconds. HTTP 408 (Client Timeout) responses are retried automatically if the header is absent or its delay is 0 seconds. New: Allow request bodies for all HTTP methods except GET and HEAD. New: Automatic module name of okhttp3 for use with the Java Platform Module System. New: Log gzipped bodies when HttpLoggingInterceptor is used as a network interceptor. New: Protocol.QUIC constant. This protocol is not supported but this constant is included for completeness. New: Upgrade to Okio 1.14.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.14.0 </version> </dependency> com.squareup.okio:okio:1.14.0 Fix: Handle HTTP/1.1 100 Continue status lines, even on requests that did not send the Expect: continue request header. Fix: Do not count web sockets toward the dispatcher\u2019s per-host connection limit. Fix: Avoid using invalid HTTPS sessions. This prevents OkHttp from crashing with the error, Unexpected TLS version: NONE . Fix: Don\u2019t corrupt the response cache when a 304 (Not Modified) response overrides the stored \u201cContent-Encoding\u201d header. Fix: Gracefully shut down the HTTP/2 connection before it exhausts the namespace of stream IDs (~536 million streams). Fix: Never pass a null Route to Authenticator . There was a bug where routes were omitted for eagerly-closed connections. Version 3.9.1 \u00b6 2017-11-18 New: Recover gracefully when Android\u2019s DNS crashes with an unexpected NullPointerException . New: Recover gracefully when Android\u2019s socket connections crash with an unexpected ClassCastException . Fix: Don\u2019t include the URL\u2019s fragment in encodedQuery() when the query itself is empty. Version 3.9.0 \u00b6 2017-09-03 Interceptors are more capable. The Chain interface now offers access to the call and can adjust all call timeouts. Note that this change is source-incompatible for code that implements the Chain interface. We don\u2019t expect this to be a problem in practice! OkHttp has an experimental new API for tracking metrics. The new EventListener API is designed to help developers monitor HTTP requests\u2019 size and duration. This feature is an unstable preview: the API is subject to change, and the implementation is incomplete. This is a big new API we are eager for feedback. New: Support ALPN via Google Play Services\u2019 Dynamic Security Provider. This expands HTTP/2 support to older Android devices that have Google Play Services. New: Consider all routes when looking for candidate coalesced connections. This increases the likelihood that HTTP/2 connections will be shared. New: Authentication challenges and credentials now use a charset. Use this in your authenticator to support user names and passwords with non-ASCII characters. New: Accept a charset in FormBody.Builder . Previously form bodies were always UTF-8. New: Support the immutable cache-control directive. Fix: Don\u2019t crash when an HTTP/2 call is redirected while the connection is being shut down. Fix: Don\u2019t drop headers of healthy streams that raced with GOAWAY frames. This bug would cause HTTP/2 streams to occasional hang when the connection was shutting down. Fix: Honor OkHttpClient.retryOnConnectionFailure() when the response is a HTTP 408 Request Timeout. If retries are enabled, OkHttp will retry exactly once in response to a 408. Fix: Don\u2019t crash when reading the empty HEAD response body if it specifies a Content-Length . Fix: Don\u2019t crash if the thread is interrupted while reading the public suffix database. Fix: Use relative resource path when loading the public suffix database. Loading the resource using a path relative to the class prevents conflicts when the OkHttp classes are relocated (shaded) by allowing multiple private copies of the database. Fix: Accept cookies for URLs that have an IPv6 address for a host. Fix: Don\u2019t log the protocol (HTTP/1.1, h2) in HttpLoggingInterceptor if the protocol isn\u2019t negotiated yet! Previously we\u2019d log HTTP/1.1 by default, and this was confusing. Fix: Omit the message from MockWebServer\u2019s HTTP/2 :status header. Fix: Handle \u2018Expect: 100 Continue\u2019 properly in MockWebServer. Version 3.8.1 \u00b6 2017-06-18 Fix: Recover gracefully from stale coalesced connections. We had a bug where connection coalescing (introduced in OkHttp 3.7.0) and stale connection recovery could interact to cause a NoSuchElementException crash in the RouteSelector . Version 3.8.0 \u00b6 2017-05-13 OkHttp now uses @Nullable to annotate all possibly-null values. We\u2019ve added a compile-time dependency on the JSR 305 annotations. This is a provided dependency and does not need to be included in your build configuration, .jar file, or .apk . We use @ParametersAreNonnullByDefault and all parameters and return types are never null unless explicitly annotated @Nullable . Warning: this release is source-incompatible for Kotlin users. Nullability was previously ambiguous and lenient but now the compiler will enforce strict null checks. New: The response message is now non-null. This is the \u201cNot Found\u201d in the status line \u201cHTTP 404 Not Found\u201d. If you are building responses programmatically (with new Response.Builder() ) you must now always supply a message. An empty string \"\" is permitted. This value was never null on responses returned by OkHttp itself, and it was an old mistake to permit application code to omit a message. The challenge\u2019s scheme and realm are now non-null. If you are calling new Challenge(scheme, realm) you must provide non-null values. These were never null in challenges created by OkHttp, but could have been null in application code that creates challenges. New: The TlsVersion of a Handshake is now non-null. If you are calling Handshake.get() with a null TLS version, you must instead now provide a non-null TlsVersion . Cache responses persisted prior to OkHttp 3.0 did not store a TLS version; for these unknown values the handshake is defaulted to TlsVersion.SSL_3_0 . New: Upgrade to Okio 1.13.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.13.0 </version> </dependency> com.squareup.okio:okio:1.13.0 Fix: gracefully recover when Android 7.0\u2019s sockets throw an unexpected NullPointerException . Version 3.7.0 \u00b6 2017-04-15 OkHttp no longer recovers from TLS handshake failures by attempting a TLSv1 connection. The fallback was necessary for servers that implemented version negotiation incorrectly. Now that 99.99% of servers do it right this fallback is obsolete. Fix: Do not honor cookies set on a public domain. Previously a malicious site could inject cookies on top-level domains like co.uk because our cookie parser didn\u2019t honor the public suffix list. Alongside this fix is a new API, HttpUrl.topPrivateDomain() , which returns the privately domain name if the URL has one. Fix: Change MediaType.charset() to return null for unexpected charsets. Fix: Don\u2019t skip cache invalidation if the invalidating response has no body. Fix: Don\u2019t use a cryptographic random number generator for web sockets. Some Android devices implement SecureRandom incorrectly! Fix: Correctly canonicalize IPv6 addresses in HttpUrl . This prevented OkHttp from trusting HTTPS certificates issued to certain IPv6 addresses. Fix: Don\u2019t reuse connections after an unsuccessful Expect: 100-continue . Fix: Handle either TLS_ or SSL_ prefixes for cipher suite names. This is necessary for IBM JVMs that use the SSL_ prefix exclusively. Fix: Reject HTTP/2 data frames if the stream ID is 0. New: Upgrade to Okio 1.12.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.12.0 </version> </dependency> com.squareup.okio:okio:1.12.0 New: Connection coalescing. OkHttp may reuse HTTP/2 connections across calls that share an IP address and HTTPS certificate, even if their domain names are different. New: MockWebServer\u2019s RecordedRequest exposes the requested HttpUrl with getRequestUrl() . Version 3.6.0 \u00b6 2017-01-29 Fix: Don\u2019t crash with a \u201ccache is closed\u201d error when there is an error initializing the cache. Fix: Calling disconnect() on a connecting HttpUrlConnection could cause it to retry in an infinite loop! This regression was introduced in OkHttp 2.7.0. Fix: Drop cookies that contain ASCII NULL and other bad characters. Previously such cookies would cause OkHttp to crash when they were included in a request. Fix: Release duplicated multiplexed connections. If we concurrently establish connections to an HTTP/2 server, close all but the first connection. Fix: Fail the HTTP/2 connection if first frame isn\u2019t SETTINGS . Fix: Forbid spaces in header names. Fix: Don\u2019t offer to do gzip if the request is partial. Fix: MockWebServer is now usable with JUnit 5. That update broke the rules . New: Support Expect: 100-continue as a request header. Callers can use this header to pessimistically hold off on transmitting a request body until a server gives the go-ahead. New: Permit network interceptors to rewrite the host header for HTTP/2. This makes it possible to do domain fronting. New: charset support for Credentials.basic() . Version 3.5.0 \u00b6 2016-11-30 Web Sockets are now a stable feature of OkHttp. Since being introduced as a beta feature in OkHttp 2.3 our web socket client has matured. Connect to a server\u2019s web socket with OkHttpClient.newWebSocket() , send messages with send() , and receive messages with the WebSocketListener . The okhttp-ws submodule is no longer available and okhttp-ws artifacts from previous releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package please note that the WebSocket and WebSocketCall classes have been merged. Sending messages is now asynchronous and they may be enqueued before the web socket is connected. OkHttp no longer attempts a direct connection if the system\u2019s HTTP proxy fails. This behavior was surprising because OkHttp was disregarding the user\u2019s specified configuration. If you need to customize proxy fallback behavior, implement your own java.net.ProxySelector . Fix: Support TLSv1.3 on devices that support it. Fix: Share pooled connections across equivalent OkHttpClient instances. Previous releases had a bug where a shared connection pool did not guarantee shared connections in some cases. Fix: Prefer the server\u2019s response body on all conditional cache misses. Previously we would return the cached response\u2019s body if it had a newer Last-Modified date. Fix: Update the stored timestamp on conditional cache hits. New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string literals are now Huffman-encoded. New: Expose Part headers and body in Multipart . New: Make ResponseBody.string() and ResponseBody.charStream() BOM-aware. If your HTTP response body begins with a byte order mark it will be consumed and used to select a charset for the remaining bytes. Most applications should not need a byte order mark. New: Upgrade to Okio 1.11.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.11.0 </version> </dependency> com.squareup.okio:okio:1.11.0 Fix: Avoid sending empty HTTP/2 data frames when there is no request body. Fix: Add a leading . for better domain matching in JavaNetCookieJar . Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request. Fix: Be lenient if a MediaType \u2018s character set is 'single-quoted' . Fix: Allow horizontal tab characters in header values. Fix: When parsing HTTP authentication headers permit challenge parameters in any order. Version 3.4.2 \u00b6 2016-11-03 Fix: Recover gracefully when an HTTP/2 connection is shutdown. We had a bug where shutdown HTTP/2 connections were considered usable. This caused infinite loops when calls attempted to recover. Version 3.4.1 \u00b6 2016-07-10 Fix a major bug in encoding HTTP headers. In 3.4.0 and 3.4.0-RC1 OkHttp had an off-by-one bug in our HPACK encoder. This bug could have caused the wrong headers to be emitted after a sequence of HTTP/2 requests! Everyone who is using OkHttp 3.4.0 or 3.4.0-RC1 should upgrade for this bug fix. Version 3.4.0 \u00b6 2016-07-08 New: Support dynamic table size changes to HPACK Encoder. Fix: Use TreeMap in Headers.toMultimap() . This makes string lookups on the returned map case-insensitive. Fix: Don\u2019t share the OkHttpClient\u2019s Dispatcher in HttpURLConnection . Version 3.4.0-RC1 \u00b6 2016-07-02 We\u2019ve rewritten HttpURLConnection and HttpsURLConnection. Previously we shared a single HTTP engine between two frontend APIs: HttpURLConnection and Call . With this release we\u2019ve rearranged things so that the HttpURLConnection frontend now delegates to the Call APIs internally. This has enabled substantial simplifications and optimizations in the OkHttp core for both frontends. For most HTTP requests the consequences of this change will be negligible. If your application uses HttpURLConnection.connect() , setFixedLengthStreamingMode() , or setChunkedStreamingMode() , OkHttp will now use a async dispatcher thread to establish the HTTP connection. We don\u2019t expect this change to have any behavior or performance consequences. Regardless, please exercise your OkUrlFactory and HttpURLConnection code when applying this update. Cipher suites may now have arbitrary names. Previously CipherSuite was a Java enum and it was impossible to define new cipher suites without first upgrading OkHttp. With this change it is now a regular Java class with enum-like constants. Application code that uses enum methods on cipher suites ( ordinal() , name() , etc.) will break with this change. Fix: CertificatePinner now matches canonicalized hostnames. Previously this was case sensitive. This change should also make it easier to configure certificate pinning for internationalized domain names. Fix: Don\u2019t crash on non-ASCII ETag headers. Previously OkHttp would reject these headers when validating a cached response. Fix: Don\u2019t allow remote peer to arbitrarily size the HPACK decoder dynamic table. Fix: Honor per-host configuration in Android\u2019s network security config. Previously disabling cleartext for any host would disable cleartext for all hosts. Note that this setting is only available on Android 24+. New: HPACK compression is now dynamic. This should improve performance when transmitting request headers over HTTP/2. New: Dispatcher.setIdleCallback() can be used to signal when there are no calls in flight. This is useful for testing with Espresso . New: Upgrade to Okio 1.9.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.9.0 </version> </dependency> Version 3.3.1 \u00b6 2016-05-28 Fix: The plaintext check in HttpLoggingInterceptor incorrectly classified newline characters as control characters. This is fixed. Fix: Don\u2019t crash reading non-ASCII characters in HTTP/2 headers or in cached HTTP headers. Fix: Retain the response body when an attempt to open a web socket returns a non-101 response code. Version 3.3.0 \u00b6 2016-05-24 New: Response.sentRequestAtMillis() and receivedResponseAtMillis() methods track the system\u2019s local time when network calls are made. These replace the OkHttp-Sent-Millis and OkHttp-Received-Millis headers that were present in earlier versions of OkHttp. New: Accept user-provided trust managers in OkHttpClient.Builder . This allows OkHttp to satisfy its TLS requirements directly. Otherwise OkHttp will use reflection to extract the TrustManager from the SSLSocketFactory . New: Support prerelease Java 9. This gets ALPN from the platform rather than relying on the alpn-boot bootclasspath override. New: HttpLoggingInterceptor now logs connection failures. New: Upgrade to Okio 1.8.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.8.0 </version> </dependency> Fix: Gracefully recover from a failure to rebuild the cache journal. Fix: Don\u2019t corrupt cache entries when a cache entry is evicted while it is being updated. Fix: Make logging more consistent throughout OkHttp. Fix: Log plaintext bodies only. This uses simple heuristics to differentiate text from other data. Fix: Recover from REFUSED_STREAM errors in HTTP/2. This should improve interoperability with Nginx 1.10.0, which refuses streams created before HTTP/2 settings have been acknowledged. Fix: Improve recovery from failed routes. Fix: Accommodate tunneling proxies that close the connection after an auth challenge. Fix: Use the proxy authenticator when authenticating HTTP proxies. This regression was introduced in OkHttp 3.0. Fix: Fail fast if network interceptors transform the response body such that closing it doesn\u2019t also close the underlying stream. We had a bug where OkHttp would attempt to reuse a connection but couldn\u2019t because it was still held by a prior request. Fix: Ensure network interceptors always have access to the underlying connection. Fix: Use X509TrustManagerExtensions on Android 17+. Fix: Unblock waiting dispatchers on MockWebServer shutdown. Version 3.2.0 \u00b6 2016-02-25 Fix: Change the certificate pinner to always build full chains. This prevents a potential crash when using certificate pinning with the Google Play Services security provider. Fix: Make IPv6 request lines consistent with Firefox and Chrome. Fix: Recover gracefully when trimming the response cache fails. New: Add multiple path segments using a single string in HttpUrl.Builder . New: Support SHA-256 pins in certificate pinner. Version 3.1.2 \u00b6 2016-02-10 Fix: Don\u2019t crash when finding the trust manager on Robolectric. We attempted to detect the host platform and got confused because Robolectric looks like Android but isn\u2019t! Fix: Change CertificatePinner to skip sanitizing the certificate chain when no certificates were pinned. This avoids an SSL failure in insecure \u201ctrust everyone\u201d configurations, such as when talking to a development HTTPS server that has a self-signed certificate. Version 3.1.1 \u00b6 2016-02-07 Fix: Don\u2019t crash when finding the trust manager if the Play Services (GMS) security provider is installed. Fix: The previous release introduced a performance regression on Android, caused by looking up CA certificates. This is now fixed. Version 3.1.0 \u00b6 2016-02-06 New: WebSockets now defer some writes. This should improve performance for some applications. New: Override equals() and hashCode() in our new cookie class. This class now defines equality by value rather than by reference. New: Handle 408 responses by retrying the request. This allows servers to direct clients to retry rather than failing permanently. New: Expose the framed protocol in Connection . Previously this would return the application-layer protocol (HTTP/1.1 or HTTP/1.0); now it always returns the wire-layer protocol (HTTP/2, SPDY/3.1, or HTTP/1.1). Fix: Permit the trusted CA root to be pinned by CertificatePinner . Fix: Silently ignore unknown HTTP/2 settings. Previously this would cause the entire connection to fail. Fix: Don\u2019t crash on unexpected charsets in the logging interceptor. Fix: OkHttpClient is now non-final for the benefit of mocking frameworks. Mocking sophisticated classes like OkHttpClient is fragile and you shouldn\u2019t do it. But if that\u2019s how you want to live your life we won\u2019t stand in your way! Version 3.0.1 \u00b6 2016-01-14 Rollback OSGi support. This was causing library jars to include more classes than expected, which interfered with Gradle builds. Version 3.0.0 \u00b6 2016-01-13 This release commits to a stable 3.0 API. Read the 3.0.0-RC1 changes for advice on upgrading from 2.x to 3.x. The Callback interface now takes a Call . This makes it easier to check if the call was canceled from within the callback. When migrating async calls to this new API, Call is now the first parameter for both onResponse() and onFailure() . Fix: handle multiple cookies in JavaNetCookieJar on Android. Fix: improve the default HTTP message in MockWebServer responses. Fix: don\u2019t leak file handles when a conditional GET throws. Fix: Use charset specified by the request body content type in OkHttp\u2019s logging interceptor. Fix: Don\u2019t eagerly release pools on cache hits. New: Make OkHttp OSGi ready. New: Add already-implemented interfaces Closeable and Flushable to the cache. Version 3.0.0-RC1 \u00b6 2016-01-02 OkHttp 3 is a major release focused on API simplicity and consistency. The API changes are numerous but most are cosmetic. Applications should be able to upgrade from the 2.x API to the 3.x API mechanically and without risk. Because the release includes breaking API changes, we\u2019re changing the project\u2019s package name from com.squareup.okhttp to okhttp3 . This should make it possible for large applications to migrate incrementally. The Maven group ID is now com.squareup.okhttp3 . For an explanation of this strategy, see Jake Wharton\u2019s post, Java Interoperability Policy for Major Version Updates . This release obsoletes OkHttp 2.x, and all code that uses OkHttp\u2019s com.squareup.okhttp package should upgrade to the okhttp3 package. Libraries that depend on OkHttp should upgrade quickly to prevent applications from being stuck on the old version. There is no longer a global singleton connection pool. In OkHttp 2.x, all OkHttpClient instances shared a common connection pool by default. In OkHttp 3.x, each new OkHttpClient gets its own private connection pool. Applications should avoid creating many connection pools as doing so prevents connection reuse. Each connection pool holds its own set of connections alive so applications that have many pools also risk exhausting memory! The best practice in OkHttp 3 is to create a single OkHttpClient instance and share it throughout the application. Requests that needs a customized client should call OkHttpClient.newBuilder() on that shared instance. This allows customization without the drawbacks of separate connection pools. OkHttpClient is now stateless. In the 2.x API OkHttpClient had getters and setters. Internally each request was forced to make its own complete snapshot of the OkHttpClient instance to defend against racy configuration changes. In 3.x, OkHttpClient is now stateless and has a builder. Note that this class is not strictly immutable as it has stateful members like the connection pool and cache. Get and Set prefixes are now avoided. With ubiquitous builders throughout OkHttp these accessor prefixes aren\u2019t necessary. Previously OkHttp used get and set prefixes sporadically which make the API inconsistent and awkward to explore. OkHttpClient now implements the new Call.Factory interface. This interface will make your code easier to test. When you test code that makes HTTP requests, you can use this interface to replace the real OkHttpClient with your own mocks or fakes. The interface will also let you use OkHttp\u2019s API with another HTTP client\u2019s implementation. This is useful in sandboxed environments like Google App Engine. OkHttp now does cookies. We\u2019ve replaced java.net.CookieHandler with a new interface, CookieJar and added our own Cookie model class. This new cookie follows the latest RFC and supports the same cookie attributes as modern web browsers. Form and Multipart bodies are now modeled. We\u2019ve replaced the opaque FormEncodingBuilder with the more powerful FormBody and FormBody.Builder combo. Similarly we\u2019ve upgraded MultipartBuilder into MultipartBody , MultipartBody.Part , and MultipartBody.Builder . The Apache HTTP client and HttpURLConnection APIs are deprecated. They continue to work as they always have, but we\u2019re moving everything to the new OkHttp 3 API. The okhttp-apache and okhttp-urlconnection modules should be only be used to accelerate a transition to OkHttp\u2019s request/response API. These deprecated modules will be dropped in an upcoming OkHttp 3.x release. Canceling batches of calls is now the application\u2019s responsibility. The API to cancel calls by tag has been removed and replaced with a more general mechanism. The dispatcher now exposes all in-flight calls via its runningCalls() and queuedCalls() methods. You can write code that selects calls by tag, host, or whatever, and invokes Call.cancel() on the ones that are no longer necessary. OkHttp no longer uses the global java.net.Authenticator by default. We\u2019ve changed our Authenticator interface to authenticate web and proxy authentication failures through a single method. An adapter for the old authenticator is available in the okhttp-urlconnection module. Fix: Don\u2019t throw IOException on ResponseBody.contentLength() or close() . Fix: Never throw converting an HttpUrl to a java.net.URI . This changes the uri() method to handle malformed percent-escapes and characters forbidden by URI . Fix: When a connect times out, attempt an alternate route. Previously route selection was less efficient when differentiating failures. New: Response.peekBody() lets you access the response body without consuming it. This may be handy for interceptors! New: HttpUrl.newBuilder() resolves a link to a builder. New: Add the TLS version to the Handshake . New: Drop Request.uri() and Request#urlString() . Just use Request.url().uri() and Request.url().toString() . New: Add URL to HTTP response logging. New: Make HttpUrl the blessed URL method of Request . Version 2.x \u00b6 Change log","title":"Changelog 3x"},{"location":"changelog_3x/#okhttp-3x-change-log","text":"","title":"OkHttp 3.x Change Log"},{"location":"changelog_3x/#version-3149","text":"2020-05-17 Fix: Don\u2019t crash when running as a plugin in Android Studio Canary 4.1. To enable platform-specific TLS features OkHttp must detect whether it\u2019s running in a JVM or in Android. The upcoming Android Studio runs in a JVM but has classes from Android and that confused OkHttp!","title":"Version 3.14.9"},{"location":"changelog_3x/#version-3148","text":"2020-04-28 Fix: Don\u2019t crash on Java 8u252 which introduces an API previously found only on Java 9 and above. See Jetty\u2019s overview of the API change and its consequences.","title":"Version 3.14.8"},{"location":"changelog_3x/#version-3147","text":"2020-02-24 Fix: Don\u2019t crash on Android 11 due to use of restricted methods. This prevents a crash with the exception, \u201cExpected Android API level 21+ but was 29\u201d.","title":"Version 3.14.7"},{"location":"changelog_3x/#version-3146","text":"2020-01-11 Fix: Don\u2019t crash if the connection is closed when sending a degraded ping. This fixes a regression that was introduced in OkHttp 3.14.5.","title":"Version 3.14.6"},{"location":"changelog_3x/#version-3145","text":"2020-01-03 Fix: Degrade HTTP/2 connections after a timeout. When an HTTP/2 stream times out it may impact the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after a stream timeout to determine whether the connection should remain eligible for pooling.","title":"Version 3.14.5"},{"location":"changelog_3x/#version-3144","text":"2019-09-29 Fix: Cancel calls that fail due to unexpected exceptions. We had a bug where an enqueued call would never call back if it crashed with an unchecked throwable, such as a NullPointerException or OutOfMemoryError . We now call Callback.onFailure() with an IOException that reports the call as canceled. The triggering exception is still delivered to the thread\u2019s UncaughtExceptionHandler . Fix: Don\u2019t evict incomplete entries when iterating the cache. We had a bug where iterating Cache.urls() would prevent in-flight entries from being written.","title":"Version 3.14.4"},{"location":"changelog_3x/#version-3143","text":"2019-09-10 Fix: Don\u2019t lose HTTP/2 flow control bytes when incoming data races with a stream close. If this happened enough then eventually the connection would stall. Fix: Acknowledge and apply inbound HTTP/2 settings atomically. Previously we had a race where we could use new flow control capacity before acknowledging it, causing strict HTTP/2 servers to fail the call. Fix: Recover gracefully when a coalesced connection immediately goes unhealthy.","title":"Version 3.14.3"},{"location":"changelog_3x/#version-3142","text":"2019-05-19 Fix: Lock in a route when recovering from an HTTP/2 connection error. We had a bug where two calls that failed at the same time could cause OkHttp to crash with a NoSuchElementException instead of the expected IOException . Fix: Don\u2019t crash with a NullPointerException when formatting an error message describing a truncated response from an HTTPS proxy.","title":"Version 3.14.2"},{"location":"changelog_3x/#version-3141","text":"2019-04-10 Fix: Don\u2019t crash when an interceptor retries when there are no more routes. This was an edge-case regression introduced with the events cleanup in 3.14.0. Fix: Provide actionable advice when the exchange is non-null. Prior to 3.14, OkHttp would silently leak connections when an interceptor retries without closing the response body. With 3.14 we detect this problem but the exception was not helpful.","title":"Version 3.14.1"},{"location":"changelog_3x/#version-3140","text":"2019-03-14 This release deletes the long-deprecated OkUrlFactory and OkApacheClient APIs. These facades hide OkHttp\u2019s implementation behind another client\u2019s API. If you still need this please copy and paste ObsoleteUrlFactory.java or ObsoleteApacheClient.java into your project. OkHttp now supports duplex calls over HTTP/2. With normal HTTP calls the request must finish before the response starts. With duplex, request and response bodies are transmitted simultaneously. This can be used to implement interactive conversations within a single HTTP call. Create duplex calls by overriding the new RequestBody.isDuplex() method to return true. This simple option dramatically changes the behavior of the request body and of the entire call. The RequestBody.writeTo() method may now retain a reference to the provided sink and hand it off to another thread to write to it after writeTo returns. The EventListener may now see requests and responses interleaved in ways not previously permitted. For example, a listener may receive responseHeadersStart() followed by requestBodyEnd() , both on the same call. Such events may be triggered by different threads even for a single call. Interceptors that rewrite or replace the request body may now inadvertently interfere with duplex request bodies. Such interceptors should check RequestBody.isDuplex() and avoid accessing the request body when it is. Duplex calls require HTTP/2. If HTTP/1 is established instead the duplex call will fail. The most common use of duplex calls is gRPC . New: Prevent OkHttp from retransmitting a request body by overriding RequestBody.isOneShot() . This is most useful when writing the request body is destructive. New: We\u2019ve added requestFailed() and responseFailed() methods to EventListener . These are called instead of requestBodyEnd() and responseBodyEnd() in some failure situations. They may also be fired in cases where no event was published previously. In this release we did an internal rewrite of our event code to fix problems where events were lost or unbalanced. Fix: Don\u2019t leak a connection when a call is canceled immediately preceding the onFailure() callback. Fix: Apply call timeouts when connecting duplex calls, web sockets, and server-sent events. Once the streams are established no further timeout is enforced. Fix: Retain the Route when a connection is reused on a redirect or other follow-up. This was causing some Authenticator calls to see a null route when non-null was expected. Fix: Use the correct key size in the name of TLS_AES_128_CCM_8_SHA256 which is a TLS 1.3 cipher suite. We accidentally specified a key size of 256, preventing that cipher suite from being selected for any TLS handshakes. We didn\u2019t notice because this cipher suite isn\u2019t supported on Android, Java, or Conscrypt. We removed this cipher suite and TLS_AES_128_CCM_SHA256 from the restricted, modern, and compatible sets of cipher suites. These two cipher suites aren\u2019t enabled by default in either Firefox or Chrome. See our TLS Configuration History tracker for a log of all changes to OkHttp\u2019s default TLS options. New: Upgrade to Conscrypt 2.0.0. OkHttp works with other versions of Conscrypt but this is the version we\u2019re testing against. implementation ( \"org.conscrypt:conscrypt-openjdk-uber:2.0.0\" ) New: Update the embedded public suffixes list.","title":"Version 3.14.0"},{"location":"changelog_3x/#version-3131","text":"2019-02-05 Fix: Don\u2019t crash when using a custom X509TrustManager or SSLSocket on Android. When we removed obsolete code for Android 4.4 we inadvertently also removed support for custom subclasses. We\u2019ve restored that support!","title":"Version 3.13.1"},{"location":"changelog_3x/#version-3130","text":"2019-02-04 This release bumps our minimum requirements to Java 8+ or Android 5+. Cutting off old devices is a serious change and we don\u2019t do it lightly! This post explains why we\u2019re doing this and how to upgrade. The OkHttp 3.12.x branch will be our long-term branch for Android 2.3+ (API level 9+) and Java 7+. These platforms lack support for TLS 1.2 and should not be used. But because upgrading is difficult we will backport critical fixes to the 3.12.x branch through December 31, 2021. (This commitment was originally through December 31, 2020; we have since extended it.) TLSv1 and TLSv1.1 are no longer enabled by default. Major web browsers are working towards removing these versions altogether in early 2020. If your servers aren\u2019t ready yet you can configure OkHttp 3.13 to allow TLSv1 and TLSv1.1 connections: OkHttpClient client = new OkHttpClient.Builder() .connectionSpecs(Arrays.asList(ConnectionSpec.COMPATIBLE_TLS)) .build(); New: You can now access HTTP trailers with Response.trailers() . This method may only be called after the entire HTTP response body has been read. New: Upgrade to Okio 1.17.3. If you\u2019re on Kotlin-friendly Okio 2.x this release requires 2.2.2 or newer. implementation ( \"com.squareup.okio:okio:1.17.3\" ) Fix: Don\u2019t miss cancels when sending HTTP/2 request headers. Fix: Don\u2019t miss whole operation timeouts when calls redirect. Fix: Don\u2019t leak connections if web sockets have malformed responses or if onOpen() throws. Fix: Don\u2019t retry when request bodies fail due to FileNotFoundException . Fix: Don\u2019t crash when URLs have IPv4-mapped IPv6 addresses. Fix: Don\u2019t crash when building HandshakeCertificates on Android API 28. Fix: Permit multipart file names to contain non-ASCII characters. New: API to get MockWebServer\u2019s dispatcher. New: API to access headers as java.time.Instant . New: Fail fast if a SSLSocketFactory is used as a SocketFactory . New: Log the TLS handshake in LoggingEventListener .","title":"Version 3.13.0"},{"location":"changelog_3x/#version-31212","text":"2020-05-17 Fix: Don\u2019t crash when running as a plugin in Android Studio Canary 4.1. To enable platform-specific TLS features OkHttp must detect whether it\u2019s running in a JVM or in Android. The upcoming Android Studio runs in a JVM but has classes from Android and that confused OkHttp!","title":"Version 3.12.12"},{"location":"changelog_3x/#version-31211","text":"2020-04-28 Fix: Don\u2019t crash on Java 8u252 which introduces an API previously found only on Java 9 and above. See Jetty\u2019s overview of the API change and its consequences.","title":"Version 3.12.11"},{"location":"changelog_3x/#version-31210","text":"2020-02-29 Fix: Don\u2019t crash on Android 4.1 when detecting methods that became restricted in Android 11. Supporting a full decade of Android releases on our 3.12.x branch is tricky!","title":"Version 3.12.10"},{"location":"changelog_3x/#version-3129","text":"2020-02-24 Fix: Don\u2019t crash on Android 11 due to use of restricted methods. This prevents a crash with the exception, \u201cExpected Android API level 21+ but was 29\u201d.","title":"Version 3.12.9"},{"location":"changelog_3x/#version-3128","text":"2020-01-11 Fix: Don\u2019t crash if the connection is closed when sending a degraded ping. This fixes a regression that was introduced in OkHttp 3.12.7.","title":"Version 3.12.8"},{"location":"changelog_3x/#version-3127","text":"2020-01-03 Fix: Degrade HTTP/2 connections after a timeout. When an HTTP/2 stream times out it may impact the stream only or the entire connection. With this fix OkHttp will now send HTTP/2 pings after a stream timeout to determine whether the connection should remain eligible for pooling.","title":"Version 3.12.7"},{"location":"changelog_3x/#version-3126","text":"2019-09-29 Fix: Cancel calls that fail due to unexpected exceptions. We had a bug where an enqueued call would never call back if it crashed with an unchecked throwable, such as a NullPointerException or OutOfMemoryError . We now call Callback.onFailure() with an IOException that reports the call as canceled. The triggering exception is still delivered to the thread\u2019s UncaughtExceptionHandler . Fix: Don\u2019t evict incomplete entries when iterating the cache. We had a bug where iterating Cache.urls() would prevent in-flight entries from being written.","title":"Version 3.12.6"},{"location":"changelog_3x/#version-3125","text":"2019-09-10 Fix: Don\u2019t lose HTTP/2 flow control bytes when incoming data races with a stream close. If this happened enough then eventually the connection would stall. Fix: Acknowledge and apply inbound HTTP/2 settings atomically. Previously we had a race where we could use new flow control capacity before acknowledging it, causing strict HTTP/2 servers to fail the call.","title":"Version 3.12.5"},{"location":"changelog_3x/#version-3124","text":"2019-09-04 Fix: Don\u2019t crash looking up an absent class on certain buggy Android 4.x devices.","title":"Version 3.12.4"},{"location":"changelog_3x/#version-3123","text":"2019-05-07 Fix: Permit multipart file names to contain non-ASCII characters. Fix: Retain the Route when a connection is reused on a redirect or other follow-up. This was causing some Authenticator calls to see a null route when non-null was expected.","title":"Version 3.12.3"},{"location":"changelog_3x/#version-3122","text":"2019-03-14 Fix: Don\u2019t crash if the HTTPS server returns no certificates in the TLS handshake. Fix: Don\u2019t leak a connection when a call is canceled immediately preceding the onFailure() callback.","title":"Version 3.12.2"},{"location":"changelog_3x/#version-3121","text":"2018-12-23 Fix: Remove overlapping package-info.java . This caused issues with some build tools.","title":"Version 3.12.1"},{"location":"changelog_3x/#version-3120","text":"2018-11-16 OkHttp now supports TLS 1.3. This requires either Conscrypt or Java 11+. Proxy authenticators are now asked for preemptive authentication. OkHttp will now request authentication credentials before creating TLS tunnels through HTTP proxies (HTTP CONNECT ). Authenticators should identify preemptive authentications by the presence of a challenge whose scheme is \u201cOkHttp-Preemptive\u201d. OkHttp now offers full-operation timeouts. This sets a limit on how long the entire call may take and covers resolving DNS, connecting, writing the request body, server processing, and reading the full response body. If a call requires redirects or retries all must complete within one timeout period. Use OkHttpClient.Builder.callTimeout() to specify the default duration and Call.timeout() to specify the timeout of an individual call. New: Return values and fields are now non-null unless otherwise annotated. New: LoggingEventListener makes it easy to get basic visibility into a call\u2019s performance. This class is in the logging-interceptor artifact. New: Headers.Builder.addUnsafeNonAscii() allows non-ASCII values to be added without an immediate exception. New: Headers can be redacted in HttpLoggingInterceptor . New: Headers.Builder now accepts dates. New: OkHttp now accepts java.time.Duration for timeouts on Java 8+ and Android 26+. New: Challenge includes all authentication parameters. New: Upgrade to BouncyCastle 1.60, Conscrypt 1.4.0, and Okio 1.15.0. We don\u2019t yet require Kotlin-friendly Okio 2.x but OkHttp works fine with that series. implementation ( \"org.bouncycastle:bcprov-jdk15on:1.60\" ) implementation ( \"org.conscrypt:conscrypt-openjdk-uber:1.4.0\" ) implementation ( \"com.squareup.okio:okio:1.15.0\" ) Fix: Handle dispatcher executor shutdowns gracefully. When there aren\u2019t any threads to carry a call its callback now gets a RejectedExecutionException . Fix: Don\u2019t permanently cache responses with Cache-Control: immutable . We misunderstood the original immutable proposal! Fix: Change Authenticator \u2018s Route parameter to be nullable. This was marked as non-null but could be called with null in some cases. Fix: Don\u2019t create malformed URLs when MockWebServer is reached via an IPv6 address. Fix: Don\u2019t crash if the system default authenticator is null. Fix: Don\u2019t crash generating elliptic curve certificates on Android. Fix: Don\u2019t crash doing platform detection on RoboVM. Fix: Don\u2019t leak socket connections when web socket upgrades fail.","title":"Version 3.12.0"},{"location":"changelog_3x/#version-3110","text":"2018-07-12 OkHttp\u2019s new okhttp-tls submodule tames HTTPS and TLS. HeldCertificate is a TLS certificate and its private key. Generate a certificate with its builder then use it to sign another certificate or perform a TLS handshake. The certificatePem() method encodes the certificate in the familiar PEM format ( --- BEGIN CERTIFICATE --- ); the privateKeyPkcs8Pem() does likewise for the private key. HandshakeCertificates holds the TLS certificates required for a TLS handshake. On the server it keeps your HeldCertificate and its chain. On the client it keeps the root certificates that are trusted to sign a server\u2019s certificate chain. HandshakeCertificates also works with mutual TLS where these roles are reversed. These classes make it possible to enable HTTPS in MockWebServer in just a few lines of code . OkHttp now supports prior knowledge cleartext HTTP/2. Enable this by setting Protocol.H2_PRIOR_KNOWLEDGE as the lone protocol on an OkHttpClient.Builder . This mode only supports http: URLs and is best suited in closed environments where HTTPS is inappropriate. New: HttpUrl.get(String) is an alternative to HttpUrl.parse(String) that throws an exception when the URL is malformed instead of returning null. Use this to avoid checking for null in situations where the input is known to be well-formed. We\u2019ve also added MediaType.get(String) which is an exception-throwing alternative to MediaType.parse(String) . New: The EventListener API previewed in OkHttp 3.9 has graduated to a stable API. Use this interface to track metrics and monitor HTTP requests\u2019 size and duration. New: okhttp-dnsoverhttps is an experimental API for doing DNS queries over HTTPS. Using HTTPS for DNS offers better security and potentially better performance. This feature is a preview: the API is subject to change. New: okhttp-sse is an early preview of Server-Sent Events (SSE). This feature is incomplete and is only suitable for experimental use. New: MockWebServer now supports client authentication (mutual TLS). Call requestClientAuth() to permit an optional client certificate or requireClientAuth() to require one. New: RecordedRequest.getHandshake() returns the HTTPS handshake of a request sent to MockWebServer . Fix: Honor the MockResponse header delay in MockWebServer. Fix: Don\u2019t release HTTP/2 connections that have multiple canceled calls. We had a bug where canceling calls would cause the shared HTTP/2 connection to be unnecessarily released. This harmed connection reuse. Fix: Ensure canceled and discarded HTTP/2 data is not permanently counted against the limited flow control window. We had a few bugs where window size accounting was broken when streams were canceled or reset. Fix: Recover gracefully if the TLS session returns an unexpected version ( NONE ) or cipher suite ( SSL_NULL_WITH_NULL_NULL ). Fix: Don\u2019t change Conscrypt configuration globally. We migrated from a process-wide setting to configuring only OkHttp\u2019s TLS sockets. Fix: Prefer TLSv1.2 where it is available. On certain older platforms it is necessary to opt-in to TLSv1.2. New: Request.tag() permits multiple tags. Use a Class<?> as a key to identify tags. Note that tag() now returns null if the request has no tag. Previously this would return the request itself. New: Headers.Builder.addAll(Headers) . New: ResponseBody.create(MediaType, ByteString) . New: Embed R8/ProGuard rules in the jar. These will be applied automatically by R8. Fix: Release the connection if Authenticator throws an exception. Fix: Change the declaration of OkHttpClient.cache() to return a @Nullable Cache . The return value has always been nullable but it wasn\u2019t declared properly. Fix: Reverse suppression of connect exceptions. When both a call and its retry fail, we now throw the initial exception which is most likely to be actionable. Fix: Retain interrupted state when throwing InterruptedIOException . A single interrupt should now be sufficient to break out an in-flight OkHttp call. Fix: Don\u2019t drop a call to EventListener.callEnd() when the response body is consumed inside an interceptor.","title":"Version 3.11.0"},{"location":"changelog_3x/#version-3100","text":"2018-02-24 The pingInterval() feature now aggressively checks connectivity for web sockets and HTTP/2 connections. Previously if you configured a ping interval that would cause OkHttp to send pings, but it did not track whether the reply pongs were received. With this update OkHttp requires that every ping receive a response: if it does not the connection will be closed and the listener\u2019s onFailure() method will be called. Web sockets have always been had pings, but pings on HTTP/2 connections is new in this release. Pings are used for connections that are busy carrying calls and for idle connections in the connection pool. (Pings do not impact when pooled connections are evicted). If you have a configured ping interval, you should confirm that it is long enough for a roundtrip from client to server. If your ping interval is too short, slow connections may be misinterpreted as failed connections. A ping interval of 30 seconds is reasonable for most use cases. OkHttp now supports Conscrypt . Conscrypt is a Java Security Provider that integrates BoringSSL into the Java platform. Conscrypt supports more cipher suites than the JVM\u2019s default provider and may also execute more efficiently. To use it, first register a Conscrypt dependency in your build system. OkHttp will use Conscrypt if you set the okhttp.platform system property to conscrypt . Alternatively, OkHttp will also use Conscrypt if you install it as your preferred security provider. To do so, add the following code to execute before you create your OkHttpClient . Security.insertProviderAt( new org.conscrypt.OpenSSLProvider(), 1); Conscrypt is the bundled security provider on Android so it is not necessary to configure it on that platform. New: HttpUrl.addQueryParameter() percent-escapes more characters. Previously several ASCII punctuation characters were not percent-escaped when used with this method. This does not impact already-encoded query parameters in APIs like HttpUrl.parse() and HttpUrl.Builder.addEncodedQueryParameter() . New: CBC-mode ECDSA cipher suites have been removed from OkHttp\u2019s default configuration: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA and TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA . This tracks a Chromium change to remove these cipher suites because they are fragile and rarely-used. New: Don\u2019t fall back to common name (CN) verification for hostnames. This behavior was deprecated with RFC 2818 in May 2000 and was recently dropped from major web browsers. New: Honor the Retry-After response header. HTTP 503 (Unavailable) responses are retried automatically if this header is present and its delay is 0 seconds. HTTP 408 (Client Timeout) responses are retried automatically if the header is absent or its delay is 0 seconds. New: Allow request bodies for all HTTP methods except GET and HEAD. New: Automatic module name of okhttp3 for use with the Java Platform Module System. New: Log gzipped bodies when HttpLoggingInterceptor is used as a network interceptor. New: Protocol.QUIC constant. This protocol is not supported but this constant is included for completeness. New: Upgrade to Okio 1.14.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.14.0 </version> </dependency> com.squareup.okio:okio:1.14.0 Fix: Handle HTTP/1.1 100 Continue status lines, even on requests that did not send the Expect: continue request header. Fix: Do not count web sockets toward the dispatcher\u2019s per-host connection limit. Fix: Avoid using invalid HTTPS sessions. This prevents OkHttp from crashing with the error, Unexpected TLS version: NONE . Fix: Don\u2019t corrupt the response cache when a 304 (Not Modified) response overrides the stored \u201cContent-Encoding\u201d header. Fix: Gracefully shut down the HTTP/2 connection before it exhausts the namespace of stream IDs (~536 million streams). Fix: Never pass a null Route to Authenticator . There was a bug where routes were omitted for eagerly-closed connections.","title":"Version 3.10.0"},{"location":"changelog_3x/#version-391","text":"2017-11-18 New: Recover gracefully when Android\u2019s DNS crashes with an unexpected NullPointerException . New: Recover gracefully when Android\u2019s socket connections crash with an unexpected ClassCastException . Fix: Don\u2019t include the URL\u2019s fragment in encodedQuery() when the query itself is empty.","title":"Version 3.9.1"},{"location":"changelog_3x/#version-390","text":"2017-09-03 Interceptors are more capable. The Chain interface now offers access to the call and can adjust all call timeouts. Note that this change is source-incompatible for code that implements the Chain interface. We don\u2019t expect this to be a problem in practice! OkHttp has an experimental new API for tracking metrics. The new EventListener API is designed to help developers monitor HTTP requests\u2019 size and duration. This feature is an unstable preview: the API is subject to change, and the implementation is incomplete. This is a big new API we are eager for feedback. New: Support ALPN via Google Play Services\u2019 Dynamic Security Provider. This expands HTTP/2 support to older Android devices that have Google Play Services. New: Consider all routes when looking for candidate coalesced connections. This increases the likelihood that HTTP/2 connections will be shared. New: Authentication challenges and credentials now use a charset. Use this in your authenticator to support user names and passwords with non-ASCII characters. New: Accept a charset in FormBody.Builder . Previously form bodies were always UTF-8. New: Support the immutable cache-control directive. Fix: Don\u2019t crash when an HTTP/2 call is redirected while the connection is being shut down. Fix: Don\u2019t drop headers of healthy streams that raced with GOAWAY frames. This bug would cause HTTP/2 streams to occasional hang when the connection was shutting down. Fix: Honor OkHttpClient.retryOnConnectionFailure() when the response is a HTTP 408 Request Timeout. If retries are enabled, OkHttp will retry exactly once in response to a 408. Fix: Don\u2019t crash when reading the empty HEAD response body if it specifies a Content-Length . Fix: Don\u2019t crash if the thread is interrupted while reading the public suffix database. Fix: Use relative resource path when loading the public suffix database. Loading the resource using a path relative to the class prevents conflicts when the OkHttp classes are relocated (shaded) by allowing multiple private copies of the database. Fix: Accept cookies for URLs that have an IPv6 address for a host. Fix: Don\u2019t log the protocol (HTTP/1.1, h2) in HttpLoggingInterceptor if the protocol isn\u2019t negotiated yet! Previously we\u2019d log HTTP/1.1 by default, and this was confusing. Fix: Omit the message from MockWebServer\u2019s HTTP/2 :status header. Fix: Handle \u2018Expect: 100 Continue\u2019 properly in MockWebServer.","title":"Version 3.9.0"},{"location":"changelog_3x/#version-381","text":"2017-06-18 Fix: Recover gracefully from stale coalesced connections. We had a bug where connection coalescing (introduced in OkHttp 3.7.0) and stale connection recovery could interact to cause a NoSuchElementException crash in the RouteSelector .","title":"Version 3.8.1"},{"location":"changelog_3x/#version-380","text":"2017-05-13 OkHttp now uses @Nullable to annotate all possibly-null values. We\u2019ve added a compile-time dependency on the JSR 305 annotations. This is a provided dependency and does not need to be included in your build configuration, .jar file, or .apk . We use @ParametersAreNonnullByDefault and all parameters and return types are never null unless explicitly annotated @Nullable . Warning: this release is source-incompatible for Kotlin users. Nullability was previously ambiguous and lenient but now the compiler will enforce strict null checks. New: The response message is now non-null. This is the \u201cNot Found\u201d in the status line \u201cHTTP 404 Not Found\u201d. If you are building responses programmatically (with new Response.Builder() ) you must now always supply a message. An empty string \"\" is permitted. This value was never null on responses returned by OkHttp itself, and it was an old mistake to permit application code to omit a message. The challenge\u2019s scheme and realm are now non-null. If you are calling new Challenge(scheme, realm) you must provide non-null values. These were never null in challenges created by OkHttp, but could have been null in application code that creates challenges. New: The TlsVersion of a Handshake is now non-null. If you are calling Handshake.get() with a null TLS version, you must instead now provide a non-null TlsVersion . Cache responses persisted prior to OkHttp 3.0 did not store a TLS version; for these unknown values the handshake is defaulted to TlsVersion.SSL_3_0 . New: Upgrade to Okio 1.13.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.13.0 </version> </dependency> com.squareup.okio:okio:1.13.0 Fix: gracefully recover when Android 7.0\u2019s sockets throw an unexpected NullPointerException .","title":"Version 3.8.0"},{"location":"changelog_3x/#version-370","text":"2017-04-15 OkHttp no longer recovers from TLS handshake failures by attempting a TLSv1 connection. The fallback was necessary for servers that implemented version negotiation incorrectly. Now that 99.99% of servers do it right this fallback is obsolete. Fix: Do not honor cookies set on a public domain. Previously a malicious site could inject cookies on top-level domains like co.uk because our cookie parser didn\u2019t honor the public suffix list. Alongside this fix is a new API, HttpUrl.topPrivateDomain() , which returns the privately domain name if the URL has one. Fix: Change MediaType.charset() to return null for unexpected charsets. Fix: Don\u2019t skip cache invalidation if the invalidating response has no body. Fix: Don\u2019t use a cryptographic random number generator for web sockets. Some Android devices implement SecureRandom incorrectly! Fix: Correctly canonicalize IPv6 addresses in HttpUrl . This prevented OkHttp from trusting HTTPS certificates issued to certain IPv6 addresses. Fix: Don\u2019t reuse connections after an unsuccessful Expect: 100-continue . Fix: Handle either TLS_ or SSL_ prefixes for cipher suite names. This is necessary for IBM JVMs that use the SSL_ prefix exclusively. Fix: Reject HTTP/2 data frames if the stream ID is 0. New: Upgrade to Okio 1.12.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.12.0 </version> </dependency> com.squareup.okio:okio:1.12.0 New: Connection coalescing. OkHttp may reuse HTTP/2 connections across calls that share an IP address and HTTPS certificate, even if their domain names are different. New: MockWebServer\u2019s RecordedRequest exposes the requested HttpUrl with getRequestUrl() .","title":"Version 3.7.0"},{"location":"changelog_3x/#version-360","text":"2017-01-29 Fix: Don\u2019t crash with a \u201ccache is closed\u201d error when there is an error initializing the cache. Fix: Calling disconnect() on a connecting HttpUrlConnection could cause it to retry in an infinite loop! This regression was introduced in OkHttp 2.7.0. Fix: Drop cookies that contain ASCII NULL and other bad characters. Previously such cookies would cause OkHttp to crash when they were included in a request. Fix: Release duplicated multiplexed connections. If we concurrently establish connections to an HTTP/2 server, close all but the first connection. Fix: Fail the HTTP/2 connection if first frame isn\u2019t SETTINGS . Fix: Forbid spaces in header names. Fix: Don\u2019t offer to do gzip if the request is partial. Fix: MockWebServer is now usable with JUnit 5. That update broke the rules . New: Support Expect: 100-continue as a request header. Callers can use this header to pessimistically hold off on transmitting a request body until a server gives the go-ahead. New: Permit network interceptors to rewrite the host header for HTTP/2. This makes it possible to do domain fronting. New: charset support for Credentials.basic() .","title":"Version 3.6.0"},{"location":"changelog_3x/#version-350","text":"2016-11-30 Web Sockets are now a stable feature of OkHttp. Since being introduced as a beta feature in OkHttp 2.3 our web socket client has matured. Connect to a server\u2019s web socket with OkHttpClient.newWebSocket() , send messages with send() , and receive messages with the WebSocketListener . The okhttp-ws submodule is no longer available and okhttp-ws artifacts from previous releases of OkHttp are not compatible with OkHttp 3.5. When upgrading to the new package please note that the WebSocket and WebSocketCall classes have been merged. Sending messages is now asynchronous and they may be enqueued before the web socket is connected. OkHttp no longer attempts a direct connection if the system\u2019s HTTP proxy fails. This behavior was surprising because OkHttp was disregarding the user\u2019s specified configuration. If you need to customize proxy fallback behavior, implement your own java.net.ProxySelector . Fix: Support TLSv1.3 on devices that support it. Fix: Share pooled connections across equivalent OkHttpClient instances. Previous releases had a bug where a shared connection pool did not guarantee shared connections in some cases. Fix: Prefer the server\u2019s response body on all conditional cache misses. Previously we would return the cached response\u2019s body if it had a newer Last-Modified date. Fix: Update the stored timestamp on conditional cache hits. New: Optimized HTTP/2 request header encoding. More headers are HPACK-encoded and string literals are now Huffman-encoded. New: Expose Part headers and body in Multipart . New: Make ResponseBody.string() and ResponseBody.charStream() BOM-aware. If your HTTP response body begins with a byte order mark it will be consumed and used to select a charset for the remaining bytes. Most applications should not need a byte order mark. New: Upgrade to Okio 1.11.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.11.0 </version> </dependency> com.squareup.okio:okio:1.11.0 Fix: Avoid sending empty HTTP/2 data frames when there is no request body. Fix: Add a leading . for better domain matching in JavaNetCookieJar . Fix: Gracefully recover from HTTP/2 connection shutdowns at start of request. Fix: Be lenient if a MediaType \u2018s character set is 'single-quoted' . Fix: Allow horizontal tab characters in header values. Fix: When parsing HTTP authentication headers permit challenge parameters in any order.","title":"Version 3.5.0"},{"location":"changelog_3x/#version-342","text":"2016-11-03 Fix: Recover gracefully when an HTTP/2 connection is shutdown. We had a bug where shutdown HTTP/2 connections were considered usable. This caused infinite loops when calls attempted to recover.","title":"Version 3.4.2"},{"location":"changelog_3x/#version-341","text":"2016-07-10 Fix a major bug in encoding HTTP headers. In 3.4.0 and 3.4.0-RC1 OkHttp had an off-by-one bug in our HPACK encoder. This bug could have caused the wrong headers to be emitted after a sequence of HTTP/2 requests! Everyone who is using OkHttp 3.4.0 or 3.4.0-RC1 should upgrade for this bug fix.","title":"Version 3.4.1"},{"location":"changelog_3x/#version-340","text":"2016-07-08 New: Support dynamic table size changes to HPACK Encoder. Fix: Use TreeMap in Headers.toMultimap() . This makes string lookups on the returned map case-insensitive. Fix: Don\u2019t share the OkHttpClient\u2019s Dispatcher in HttpURLConnection .","title":"Version 3.4.0"},{"location":"changelog_3x/#version-340-rc1","text":"2016-07-02 We\u2019ve rewritten HttpURLConnection and HttpsURLConnection. Previously we shared a single HTTP engine between two frontend APIs: HttpURLConnection and Call . With this release we\u2019ve rearranged things so that the HttpURLConnection frontend now delegates to the Call APIs internally. This has enabled substantial simplifications and optimizations in the OkHttp core for both frontends. For most HTTP requests the consequences of this change will be negligible. If your application uses HttpURLConnection.connect() , setFixedLengthStreamingMode() , or setChunkedStreamingMode() , OkHttp will now use a async dispatcher thread to establish the HTTP connection. We don\u2019t expect this change to have any behavior or performance consequences. Regardless, please exercise your OkUrlFactory and HttpURLConnection code when applying this update. Cipher suites may now have arbitrary names. Previously CipherSuite was a Java enum and it was impossible to define new cipher suites without first upgrading OkHttp. With this change it is now a regular Java class with enum-like constants. Application code that uses enum methods on cipher suites ( ordinal() , name() , etc.) will break with this change. Fix: CertificatePinner now matches canonicalized hostnames. Previously this was case sensitive. This change should also make it easier to configure certificate pinning for internationalized domain names. Fix: Don\u2019t crash on non-ASCII ETag headers. Previously OkHttp would reject these headers when validating a cached response. Fix: Don\u2019t allow remote peer to arbitrarily size the HPACK decoder dynamic table. Fix: Honor per-host configuration in Android\u2019s network security config. Previously disabling cleartext for any host would disable cleartext for all hosts. Note that this setting is only available on Android 24+. New: HPACK compression is now dynamic. This should improve performance when transmitting request headers over HTTP/2. New: Dispatcher.setIdleCallback() can be used to signal when there are no calls in flight. This is useful for testing with Espresso . New: Upgrade to Okio 1.9.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.9.0 </version> </dependency>","title":"Version 3.4.0-RC1"},{"location":"changelog_3x/#version-331","text":"2016-05-28 Fix: The plaintext check in HttpLoggingInterceptor incorrectly classified newline characters as control characters. This is fixed. Fix: Don\u2019t crash reading non-ASCII characters in HTTP/2 headers or in cached HTTP headers. Fix: Retain the response body when an attempt to open a web socket returns a non-101 response code.","title":"Version 3.3.1"},{"location":"changelog_3x/#version-330","text":"2016-05-24 New: Response.sentRequestAtMillis() and receivedResponseAtMillis() methods track the system\u2019s local time when network calls are made. These replace the OkHttp-Sent-Millis and OkHttp-Received-Millis headers that were present in earlier versions of OkHttp. New: Accept user-provided trust managers in OkHttpClient.Builder . This allows OkHttp to satisfy its TLS requirements directly. Otherwise OkHttp will use reflection to extract the TrustManager from the SSLSocketFactory . New: Support prerelease Java 9. This gets ALPN from the platform rather than relying on the alpn-boot bootclasspath override. New: HttpLoggingInterceptor now logs connection failures. New: Upgrade to Okio 1.8.0. <dependency> <groupId> com.squareup.okio </groupId> <artifactId> okio </artifactId> <version> 1.8.0 </version> </dependency> Fix: Gracefully recover from a failure to rebuild the cache journal. Fix: Don\u2019t corrupt cache entries when a cache entry is evicted while it is being updated. Fix: Make logging more consistent throughout OkHttp. Fix: Log plaintext bodies only. This uses simple heuristics to differentiate text from other data. Fix: Recover from REFUSED_STREAM errors in HTTP/2. This should improve interoperability with Nginx 1.10.0, which refuses streams created before HTTP/2 settings have been acknowledged. Fix: Improve recovery from failed routes. Fix: Accommodate tunneling proxies that close the connection after an auth challenge. Fix: Use the proxy authenticator when authenticating HTTP proxies. This regression was introduced in OkHttp 3.0. Fix: Fail fast if network interceptors transform the response body such that closing it doesn\u2019t also close the underlying stream. We had a bug where OkHttp would attempt to reuse a connection but couldn\u2019t because it was still held by a prior request. Fix: Ensure network interceptors always have access to the underlying connection. Fix: Use X509TrustManagerExtensions on Android 17+. Fix: Unblock waiting dispatchers on MockWebServer shutdown.","title":"Version 3.3.0"},{"location":"changelog_3x/#version-320","text":"2016-02-25 Fix: Change the certificate pinner to always build full chains. This prevents a potential crash when using certificate pinning with the Google Play Services security provider. Fix: Make IPv6 request lines consistent with Firefox and Chrome. Fix: Recover gracefully when trimming the response cache fails. New: Add multiple path segments using a single string in HttpUrl.Builder . New: Support SHA-256 pins in certificate pinner.","title":"Version 3.2.0"},{"location":"changelog_3x/#version-312","text":"2016-02-10 Fix: Don\u2019t crash when finding the trust manager on Robolectric. We attempted to detect the host platform and got confused because Robolectric looks like Android but isn\u2019t! Fix: Change CertificatePinner to skip sanitizing the certificate chain when no certificates were pinned. This avoids an SSL failure in insecure \u201ctrust everyone\u201d configurations, such as when talking to a development HTTPS server that has a self-signed certificate.","title":"Version 3.1.2"},{"location":"changelog_3x/#version-311","text":"2016-02-07 Fix: Don\u2019t crash when finding the trust manager if the Play Services (GMS) security provider is installed. Fix: The previous release introduced a performance regression on Android, caused by looking up CA certificates. This is now fixed.","title":"Version 3.1.1"},{"location":"changelog_3x/#version-310","text":"2016-02-06 New: WebSockets now defer some writes. This should improve performance for some applications. New: Override equals() and hashCode() in our new cookie class. This class now defines equality by value rather than by reference. New: Handle 408 responses by retrying the request. This allows servers to direct clients to retry rather than failing permanently. New: Expose the framed protocol in Connection . Previously this would return the application-layer protocol (HTTP/1.1 or HTTP/1.0); now it always returns the wire-layer protocol (HTTP/2, SPDY/3.1, or HTTP/1.1). Fix: Permit the trusted CA root to be pinned by CertificatePinner . Fix: Silently ignore unknown HTTP/2 settings. Previously this would cause the entire connection to fail. Fix: Don\u2019t crash on unexpected charsets in the logging interceptor. Fix: OkHttpClient is now non-final for the benefit of mocking frameworks. Mocking sophisticated classes like OkHttpClient is fragile and you shouldn\u2019t do it. But if that\u2019s how you want to live your life we won\u2019t stand in your way!","title":"Version 3.1.0"},{"location":"changelog_3x/#version-301","text":"2016-01-14 Rollback OSGi support. This was causing library jars to include more classes than expected, which interfered with Gradle builds.","title":"Version 3.0.1"},{"location":"changelog_3x/#version-300","text":"2016-01-13 This release commits to a stable 3.0 API. Read the 3.0.0-RC1 changes for advice on upgrading from 2.x to 3.x. The Callback interface now takes a Call . This makes it easier to check if the call was canceled from within the callback. When migrating async calls to this new API, Call is now the first parameter for both onResponse() and onFailure() . Fix: handle multiple cookies in JavaNetCookieJar on Android. Fix: improve the default HTTP message in MockWebServer responses. Fix: don\u2019t leak file handles when a conditional GET throws. Fix: Use charset specified by the request body content type in OkHttp\u2019s logging interceptor. Fix: Don\u2019t eagerly release pools on cache hits. New: Make OkHttp OSGi ready. New: Add already-implemented interfaces Closeable and Flushable to the cache.","title":"Version 3.0.0"},{"location":"changelog_3x/#version-300-rc1","text":"2016-01-02 OkHttp 3 is a major release focused on API simplicity and consistency. The API changes are numerous but most are cosmetic. Applications should be able to upgrade from the 2.x API to the 3.x API mechanically and without risk. Because the release includes breaking API changes, we\u2019re changing the project\u2019s package name from com.squareup.okhttp to okhttp3 . This should make it possible for large applications to migrate incrementally. The Maven group ID is now com.squareup.okhttp3 . For an explanation of this strategy, see Jake Wharton\u2019s post, Java Interoperability Policy for Major Version Updates . This release obsoletes OkHttp 2.x, and all code that uses OkHttp\u2019s com.squareup.okhttp package should upgrade to the okhttp3 package. Libraries that depend on OkHttp should upgrade quickly to prevent applications from being stuck on the old version. There is no longer a global singleton connection pool. In OkHttp 2.x, all OkHttpClient instances shared a common connection pool by default. In OkHttp 3.x, each new OkHttpClient gets its own private connection pool. Applications should avoid creating many connection pools as doing so prevents connection reuse. Each connection pool holds its own set of connections alive so applications that have many pools also risk exhausting memory! The best practice in OkHttp 3 is to create a single OkHttpClient instance and share it throughout the application. Requests that needs a customized client should call OkHttpClient.newBuilder() on that shared instance. This allows customization without the drawbacks of separate connection pools. OkHttpClient is now stateless. In the 2.x API OkHttpClient had getters and setters. Internally each request was forced to make its own complete snapshot of the OkHttpClient instance to defend against racy configuration changes. In 3.x, OkHttpClient is now stateless and has a builder. Note that this class is not strictly immutable as it has stateful members like the connection pool and cache. Get and Set prefixes are now avoided. With ubiquitous builders throughout OkHttp these accessor prefixes aren\u2019t necessary. Previously OkHttp used get and set prefixes sporadically which make the API inconsistent and awkward to explore. OkHttpClient now implements the new Call.Factory interface. This interface will make your code easier to test. When you test code that makes HTTP requests, you can use this interface to replace the real OkHttpClient with your own mocks or fakes. The interface will also let you use OkHttp\u2019s API with another HTTP client\u2019s implementation. This is useful in sandboxed environments like Google App Engine. OkHttp now does cookies. We\u2019ve replaced java.net.CookieHandler with a new interface, CookieJar and added our own Cookie model class. This new cookie follows the latest RFC and supports the same cookie attributes as modern web browsers. Form and Multipart bodies are now modeled. We\u2019ve replaced the opaque FormEncodingBuilder with the more powerful FormBody and FormBody.Builder combo. Similarly we\u2019ve upgraded MultipartBuilder into MultipartBody , MultipartBody.Part , and MultipartBody.Builder . The Apache HTTP client and HttpURLConnection APIs are deprecated. They continue to work as they always have, but we\u2019re moving everything to the new OkHttp 3 API. The okhttp-apache and okhttp-urlconnection modules should be only be used to accelerate a transition to OkHttp\u2019s request/response API. These deprecated modules will be dropped in an upcoming OkHttp 3.x release. Canceling batches of calls is now the application\u2019s responsibility. The API to cancel calls by tag has been removed and replaced with a more general mechanism. The dispatcher now exposes all in-flight calls via its runningCalls() and queuedCalls() methods. You can write code that selects calls by tag, host, or whatever, and invokes Call.cancel() on the ones that are no longer necessary. OkHttp no longer uses the global java.net.Authenticator by default. We\u2019ve changed our Authenticator interface to authenticate web and proxy authentication failures through a single method. An adapter for the old authenticator is available in the okhttp-urlconnection module. Fix: Don\u2019t throw IOException on ResponseBody.contentLength() or close() . Fix: Never throw converting an HttpUrl to a java.net.URI . This changes the uri() method to handle malformed percent-escapes and characters forbidden by URI . Fix: When a connect times out, attempt an alternate route. Previously route selection was less efficient when differentiating failures. New: Response.peekBody() lets you access the response body without consuming it. This may be handy for interceptors! New: HttpUrl.newBuilder() resolves a link to a builder. New: Add the TLS version to the Handshake . New: Drop Request.uri() and Request#urlString() . Just use Request.url().uri() and Request.url().toString() . New: Add URL to HTTP response logging. New: Make HttpUrl the blessed URL method of Request .","title":"Version 3.0.0-RC1"},{"location":"changelog_3x/#version-2x","text":"Change log","title":"Version 2.x"},{"location":"code_of_conduct/","text":"Open Source Code of Conduct \u00b6 At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter. Diversity Statement \u00b6 We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities. Reporting Issues \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below. Thanks \u00b6 Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work. Reporting Guide \u00b6 If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Code of Conduct"},{"location":"code_of_conduct/#open-source-code-of-conduct","text":"At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone. This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored. Square\u2019s open source community strives to: Be open : We invite anyone to participate in any aspect of our projects. Our community is open, and any responsibility can be carried by a contributor who demonstrates the required capacity and competence. Be considerate : People use our work, and we depend on the work of others. Consider users and colleagues before taking action. For example, changes to code, infrastructure, policy, and documentation may negatively impact others. Be respectful : We expect people to work together to resolve conflict, assume good intentions, and act with empathy. Do not turn disagreements into personal attacks. Be collaborative : Collaboration reduces redundancy and improves the quality of our work. We strive for transparency within our open source community, and we work closely with upstream developers and others in the free software community to coordinate our efforts. Be pragmatic : Questions are encouraged and should be asked early in the process to avoid problems later. Be thoughtful and considerate when seeking out the appropriate forum for your questions. Those who are asked should be responsive and helpful. Step down considerately : Members of every project come and go. When somebody leaves or disengages from the project, they should make it known and take the proper steps to ensure that others can pick up where they left off. This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.","title":"Open Source Code of Conduct"},{"location":"code_of_conduct/#diversity-statement","text":"We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal. Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong. Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.","title":"Diversity Statement"},{"location":"code_of_conduct/#reporting-issues","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . For more details, please see our Reporting Guidelines below.","title":"Reporting Issues"},{"location":"code_of_conduct/#thanks","text":"Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter , Ubuntu , GDC , and Django communities. We are thankful for their work.","title":"Thanks"},{"location":"code_of_conduct/#reporting-guide","text":"If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com . All reports will be handled with discretion. In your report please include: Your contact information. Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional witnesses, please include them as well. Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly available record (e.g. a mailing list archive or a public IRC logger), please include a link. Any additional information that may be helpful. After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond. Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.","title":"Reporting Guide"},{"location":"concurrency/","text":"Concurrency \u00b6 This document describes the concurrency considerations for http/2 connections and the connection pool within OkHttp. HTTP/2 Connections \u00b6 The HttpURLConnection API is a blocking API. You make a blocking write to send a request, and a blocking read to receive the response. Blocking APIs \u00b6 Blocking APIs are convenient because you get top-to-bottom procedural code without indirection. Network calls work like regular method calls: ask for data and it is returned. If the request fails, you get a stacktrace right were the call was made. Blocking APIs may be inefficient because you hold a thread idle while waiting on the network. Threads are expensive because they have both a memory overhead and a context-switching overhead. Framed protocols \u00b6 Framed protocols like http/2 don\u2019t lend themselves to blocking APIs. Each application-layer thread wants to do blocking I/O for a specific stream, but the streams are multiplexed on the socket. You can\u2019t just talk to the socket, you need to cooperate with the other application-layer threads that you\u2019re sharing it with. Framing rules make it impractical to implement http/2 correctly on a single blocking thread. The flow-control features introduce feedback between reads and writes, requiring writes to acknowledge reads and reads to throttle writes. In OkHttp we expose a blocking API over a framed protocol. This document explains the code and policy that makes that work. Threads \u00b6 Application\u2019s calling thread \u00b6 The application-layer must block on writing I/O. We can\u2019t return from a write until we\u2019ve pushed its bytes onto the socket. Otherwise, if the write fails we are unable to deliver its IOException to the application. We would have told the application layer that the write succeeded, but it didn\u2019t! The application-layer can also do blocking reads. If the application asks to read and there\u2019s nothing available, we need to hold that thread until either the bytes arrive, the stream is closed, or a timeout elapses. If we get bytes but there\u2019s nobody asking for them, we buffer them. We don\u2019t consider bytes as delivered for flow control until they\u2019re consumed by the application. Consider an application streaming a video over http/2. Perhaps the user pauses the video and the application stops reading bytes from this stream. The buffer will fill up, and flow control prevents the server from sending more data on this stream. When the user unpauses her video the buffer drains, the read is acknowledged, and the server proceeds to stream data. Shared reader thread \u00b6 We can\u2019t rely on application threads to read data from the socket. Application threads are transient: sometimes they\u2019re reading and writing and sometimes they\u2019re off doing application-layer things. But the socket is permanent, and it needs constant attention: we dispatch all incoming frames so the connection is good-to-go when the application layer needs it. So we have a dedicated thread for every socket that just reads frames and dispatches them. The reader thread must never run application-layer code. Otherwise one slow stream can hold up the entire connection. Similarly, the reader thread must never block on writing because this can deadlock the connection. Consider a client and server that both violate this rule. If you get unlucky, they could fill up their TCP buffers (so that writes block) and then use their reader threads to write a frame. Nobody is reading on either end, and the buffers are never drained. Do-stuff-later pool \u00b6 Sometimes there\u2019s an action required like calling the application layer or responding to a ping, and the thread discovering the action is not the thread that should do the work. We enqueue a runnable on this executor and it gets handled by one of the executor\u2019s threads. Locks \u00b6 We have 3 different things that we synchronize on. Http2Connection \u00b6 This lock guards internal state of each connection. This lock is never held for blocking operations. That means that we acquire the lock, read or write a few fields and release the lock. No I/O and no application-layer callbacks. Http2Stream \u00b6 This lock guards the internal state of each stream. As above, it is never held for blocking operations. When we need to hold an application thread to block a read, we use wait/notify on this lock. This works because the lock is released while wait() is waiting. Http2Writer \u00b6 Socket writes are guarded by the Http2Writer. Only one stream can write at a time so that messages are not interleaved. Writes are either made by application-layer threads or the do-stuff-later pool. Holding multiple locks \u00b6 You\u2019re allowed to take the Http2Connection lock while holding the Http2Writer lock. But not vice-versa. Because taking the Http2Writer lock can block. This is necessary for bookkeeping when creating new streams. Correct framing requires that stream IDs are sequential on the socket, so we need to bundle assigning the ID with sending the SYN_STREAM frame. Connection Pool \u00b6 A primary responsibility for any HTTP client is to efficiently manage network connections. Creating and establishing new connections require a fair amount of overhead and added latency. OkHttp will make every effort to reuse existing connections to avoid this overhead and added latency. Every OkHttpClient uses a connection pool. Its job is to maintain a reference to all open connections. When an HTTP request is started, OkHttp will attempt to reuse an existing connection from the pool. If there are no existing connections, a new one is created and put into the connection pool. For HTTP/2, the connection can be reused immediately. For HTTP/1, the request must be completed before it can be reused. Since HTTP requests frequently happen in parallel, connection pooling must be thread-safe. These are the primary classes involved with establishing, sharing, and terminating connections: RealConnectionPool manages reuse of HTTP and HTTP/2 connections for reduced latency. Every OkHttpClient has one, and its lifetime spans the lifetime of the OkHttpClient. RealConnection is the socket and streams of an HTTP/1 or HTTP/2 connection. These are created on demand to fulfill HTTP requests. They may be reused for many HTTP request/response exchanges. Their lifetime is typically shorter than a connection pool. Exchange carries a single HTTP request/response pair. ExchangeFinder chooses which connection carries each exchange. Where possible it will use the same connection for all exchanges in a single call. It prefers reusing pooled connections over establishing new connections. Per-Connection Locks \u00b6 Each connection has its own lock. The connections in the pool are all in a ConcurrentLinkedQueue . Due to data races, iterators of this queue may return removed connections. Callers must check the connection\u2019s noNewExchanges property before using connections from the pool. The connection lock is never held while doing I/O (even closing a socket) to prevent contention. A lock-per-connection is used to maximize concurrency.","title":"Concurrency"},{"location":"concurrency/#concurrency","text":"This document describes the concurrency considerations for http/2 connections and the connection pool within OkHttp.","title":"Concurrency"},{"location":"concurrency/#http2-connections","text":"The HttpURLConnection API is a blocking API. You make a blocking write to send a request, and a blocking read to receive the response.","title":"HTTP/2 Connections"},{"location":"concurrency/#blocking-apis","text":"Blocking APIs are convenient because you get top-to-bottom procedural code without indirection. Network calls work like regular method calls: ask for data and it is returned. If the request fails, you get a stacktrace right were the call was made. Blocking APIs may be inefficient because you hold a thread idle while waiting on the network. Threads are expensive because they have both a memory overhead and a context-switching overhead.","title":"Blocking APIs"},{"location":"concurrency/#framed-protocols","text":"Framed protocols like http/2 don\u2019t lend themselves to blocking APIs. Each application-layer thread wants to do blocking I/O for a specific stream, but the streams are multiplexed on the socket. You can\u2019t just talk to the socket, you need to cooperate with the other application-layer threads that you\u2019re sharing it with. Framing rules make it impractical to implement http/2 correctly on a single blocking thread. The flow-control features introduce feedback between reads and writes, requiring writes to acknowledge reads and reads to throttle writes. In OkHttp we expose a blocking API over a framed protocol. This document explains the code and policy that makes that work.","title":"Framed protocols"},{"location":"concurrency/#threads","text":"","title":"Threads"},{"location":"concurrency/#applications-calling-thread","text":"The application-layer must block on writing I/O. We can\u2019t return from a write until we\u2019ve pushed its bytes onto the socket. Otherwise, if the write fails we are unable to deliver its IOException to the application. We would have told the application layer that the write succeeded, but it didn\u2019t! The application-layer can also do blocking reads. If the application asks to read and there\u2019s nothing available, we need to hold that thread until either the bytes arrive, the stream is closed, or a timeout elapses. If we get bytes but there\u2019s nobody asking for them, we buffer them. We don\u2019t consider bytes as delivered for flow control until they\u2019re consumed by the application. Consider an application streaming a video over http/2. Perhaps the user pauses the video and the application stops reading bytes from this stream. The buffer will fill up, and flow control prevents the server from sending more data on this stream. When the user unpauses her video the buffer drains, the read is acknowledged, and the server proceeds to stream data.","title":"Application's calling thread"},{"location":"concurrency/#shared-reader-thread","text":"We can\u2019t rely on application threads to read data from the socket. Application threads are transient: sometimes they\u2019re reading and writing and sometimes they\u2019re off doing application-layer things. But the socket is permanent, and it needs constant attention: we dispatch all incoming frames so the connection is good-to-go when the application layer needs it. So we have a dedicated thread for every socket that just reads frames and dispatches them. The reader thread must never run application-layer code. Otherwise one slow stream can hold up the entire connection. Similarly, the reader thread must never block on writing because this can deadlock the connection. Consider a client and server that both violate this rule. If you get unlucky, they could fill up their TCP buffers (so that writes block) and then use their reader threads to write a frame. Nobody is reading on either end, and the buffers are never drained.","title":"Shared reader thread"},{"location":"concurrency/#do-stuff-later-pool","text":"Sometimes there\u2019s an action required like calling the application layer or responding to a ping, and the thread discovering the action is not the thread that should do the work. We enqueue a runnable on this executor and it gets handled by one of the executor\u2019s threads.","title":"Do-stuff-later pool"},{"location":"concurrency/#locks","text":"We have 3 different things that we synchronize on.","title":"Locks"},{"location":"concurrency/#http2connection","text":"This lock guards internal state of each connection. This lock is never held for blocking operations. That means that we acquire the lock, read or write a few fields and release the lock. No I/O and no application-layer callbacks.","title":"Http2Connection"},{"location":"concurrency/#http2stream","text":"This lock guards the internal state of each stream. As above, it is never held for blocking operations. When we need to hold an application thread to block a read, we use wait/notify on this lock. This works because the lock is released while wait() is waiting.","title":"Http2Stream"},{"location":"concurrency/#http2writer","text":"Socket writes are guarded by the Http2Writer. Only one stream can write at a time so that messages are not interleaved. Writes are either made by application-layer threads or the do-stuff-later pool.","title":"Http2Writer"},{"location":"concurrency/#holding-multiple-locks","text":"You\u2019re allowed to take the Http2Connection lock while holding the Http2Writer lock. But not vice-versa. Because taking the Http2Writer lock can block. This is necessary for bookkeeping when creating new streams. Correct framing requires that stream IDs are sequential on the socket, so we need to bundle assigning the ID with sending the SYN_STREAM frame.","title":"Holding multiple locks"},{"location":"concurrency/#connection-pool","text":"A primary responsibility for any HTTP client is to efficiently manage network connections. Creating and establishing new connections require a fair amount of overhead and added latency. OkHttp will make every effort to reuse existing connections to avoid this overhead and added latency. Every OkHttpClient uses a connection pool. Its job is to maintain a reference to all open connections. When an HTTP request is started, OkHttp will attempt to reuse an existing connection from the pool. If there are no existing connections, a new one is created and put into the connection pool. For HTTP/2, the connection can be reused immediately. For HTTP/1, the request must be completed before it can be reused. Since HTTP requests frequently happen in parallel, connection pooling must be thread-safe. These are the primary classes involved with establishing, sharing, and terminating connections: RealConnectionPool manages reuse of HTTP and HTTP/2 connections for reduced latency. Every OkHttpClient has one, and its lifetime spans the lifetime of the OkHttpClient. RealConnection is the socket and streams of an HTTP/1 or HTTP/2 connection. These are created on demand to fulfill HTTP requests. They may be reused for many HTTP request/response exchanges. Their lifetime is typically shorter than a connection pool. Exchange carries a single HTTP request/response pair. ExchangeFinder chooses which connection carries each exchange. Where possible it will use the same connection for all exchanges in a single call. It prefers reusing pooled connections over establishing new connections.","title":"Connection Pool"},{"location":"concurrency/#per-connection-locks","text":"Each connection has its own lock. The connections in the pool are all in a ConcurrentLinkedQueue . Due to data races, iterators of this queue may return removed connections. Callers must check the connection\u2019s noNewExchanges property before using connections from the pool. The connection lock is never held while doing I/O (even closing a socket) to prevent contention. A lock-per-connection is used to maximize concurrency.","title":"Per-Connection Locks"},{"location":"connections/","text":"Connections \u00b6 Although you provide only the URL, OkHttp plans its connection to your webserver using three types: URL, Address, and Route. URLs \u00b6 URLs (like https://github.com/square/okhttp ) are fundamental to HTTP and the Internet. In addition to being a universal, decentralized naming scheme for everything on the web, they also specify how to access web resources. URLs are abstract: They specify that the call may be plaintext ( http ) or encrypted ( https ), but not which cryptographic algorithms should be used. Nor do they specify how to verify the peer\u2019s certificates (the HostnameVerifier ) or which certificates can be trusted (the SSLSocketFactory ). They don\u2019t specify whether a specific proxy server should be used or how to authenticate with that proxy server. They\u2019re also concrete: each URL identifies a specific path (like /square/okhttp ) and query (like ?q=sharks&lang=en ). Each webserver hosts many URLs. Addresses \u00b6 Addresses specify a webserver (like github.com ) and all of the static configuration necessary to connect to that server: the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY). URLs that share the same address may also share the same underlying TCP socket connection. Sharing a connection has substantial performance benefits: lower latency, higher throughput (due to TCP slow start ) and conserved battery. OkHttp uses a ConnectionPool that automatically reuses HTTP/1.x connections and multiplexes HTTP/2 and SPDY connections. In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the OkHttpClient . Routes \u00b6 Routes supply the dynamic information necessary to actually connect to a webserver. This is the specific IP address to attempt (as discovered by a DNS query), the exact proxy server to use (if a ProxySelector is in use), and which version of TLS to negotiate (for HTTPS connections). There may be many routes for a single address. For example, a webserver that is hosted in multiple datacenters may yield multiple IP addresses in its DNS response. Connections \u00b6 When you request a URL with OkHttp, here\u2019s what it does: It uses the URL and configured OkHttpClient to create an address . This address specifies how we\u2019ll connect to the webserver. It attempts to retrieve a connection with that address from the connection pool . If it doesn\u2019t find a connection in the pool, it selects a route to attempt. This usually means making a DNS request to get the server\u2019s IP addresses. It then selects a TLS version and proxy server if necessary. If it\u2019s a new route, it connects by building either a direct socket connection, a TLS tunnel (for HTTPS over an HTTP proxy), or a direct TLS connection. It does TLS handshakes as necessary. It sends the HTTP request and reads the response. If there\u2019s a problem with the connection, OkHttp will select another route and try again. This allows OkHttp to recover when a subset of a server\u2019s addresses are unreachable. It\u2019s also useful when a pooled connection is stale or if the attempted TLS version is unsupported. Once the response has been received, the connection will be returned to the pool so it can be reused for a future request. Connections are evicted from the pool after a period of inactivity.","title":"Connections"},{"location":"connections/#connections","text":"Although you provide only the URL, OkHttp plans its connection to your webserver using three types: URL, Address, and Route.","title":"Connections"},{"location":"connections/#urls","text":"URLs (like https://github.com/square/okhttp ) are fundamental to HTTP and the Internet. In addition to being a universal, decentralized naming scheme for everything on the web, they also specify how to access web resources. URLs are abstract: They specify that the call may be plaintext ( http ) or encrypted ( https ), but not which cryptographic algorithms should be used. Nor do they specify how to verify the peer\u2019s certificates (the HostnameVerifier ) or which certificates can be trusted (the SSLSocketFactory ). They don\u2019t specify whether a specific proxy server should be used or how to authenticate with that proxy server. They\u2019re also concrete: each URL identifies a specific path (like /square/okhttp ) and query (like ?q=sharks&lang=en ). Each webserver hosts many URLs.","title":"URLs"},{"location":"connections/#addresses","text":"Addresses specify a webserver (like github.com ) and all of the static configuration necessary to connect to that server: the port number, HTTPS settings, and preferred network protocols (like HTTP/2 or SPDY). URLs that share the same address may also share the same underlying TCP socket connection. Sharing a connection has substantial performance benefits: lower latency, higher throughput (due to TCP slow start ) and conserved battery. OkHttp uses a ConnectionPool that automatically reuses HTTP/1.x connections and multiplexes HTTP/2 and SPDY connections. In OkHttp some fields of the address come from the URL (scheme, hostname, port) and the rest come from the OkHttpClient .","title":"Addresses"},{"location":"connections/#routes","text":"Routes supply the dynamic information necessary to actually connect to a webserver. This is the specific IP address to attempt (as discovered by a DNS query), the exact proxy server to use (if a ProxySelector is in use), and which version of TLS to negotiate (for HTTPS connections). There may be many routes for a single address. For example, a webserver that is hosted in multiple datacenters may yield multiple IP addresses in its DNS response.","title":"Routes"},{"location":"connections/#connections_1","text":"When you request a URL with OkHttp, here\u2019s what it does: It uses the URL and configured OkHttpClient to create an address . This address specifies how we\u2019ll connect to the webserver. It attempts to retrieve a connection with that address from the connection pool . If it doesn\u2019t find a connection in the pool, it selects a route to attempt. This usually means making a DNS request to get the server\u2019s IP addresses. It then selects a TLS version and proxy server if necessary. If it\u2019s a new route, it connects by building either a direct socket connection, a TLS tunnel (for HTTPS over an HTTP proxy), or a direct TLS connection. It does TLS handshakes as necessary. It sends the HTTP request and reads the response. If there\u2019s a problem with the connection, OkHttp will select another route and try again. This allows OkHttp to recover when a subset of a server\u2019s addresses are unreachable. It\u2019s also useful when a pooled connection is stale or if the attempted TLS version is unsupported. Once the response has been received, the connection will be returned to the pool so it can be reused for a future request. Connections are evicted from the pool after a period of inactivity.","title":"Connections"},{"location":"debug_logging/","text":"Debug Logging \u00b6 OkHttp has internal APIs to enable debug logging. It uses the java.util.logging API which can be tricky to configure. As a shortcut, you can paste OkHttpDebugLogging.kt . Then enable debug logging for whichever features you need: OkHttpDebugLogging.enableHttp2() OkHttpDebugLogging.enableTaskRunner() Activating on Android \u00b6 $ adb shell setprop log.tag.okhttp.Http2 DEBUG $ adb shell setprop log.tag.okhttp.TaskRunner DEBUG $ adb logcat '*:E' 'okhttp.Http2:D' 'okhttp.TaskRunner:D' HTTP/2 Frame Logging \u00b6 This logs inbound ( << ) and outbound ( >> ) frames for HTTP/2 connections. [2020-01-01 00:00:00] >> CONNECTION 505249202a20485454502f322e300d0a0d0a534d0d0a0d0a [2020-01-01 00:00:00] >> 0x00000000 6 SETTINGS [2020-01-01 00:00:00] >> 0x00000000 4 WINDOW_UPDATE [2020-01-01 00:00:00] >> 0x00000003 47 HEADERS END_STREAM|END_HEADERS [2020-01-01 00:00:00] << 0x00000000 6 SETTINGS [2020-01-01 00:00:00] << 0x00000000 0 SETTINGS ACK [2020-01-01 00:00:00] << 0x00000000 4 WINDOW_UPDATE [2020-01-01 00:00:00] >> 0x00000000 0 SETTINGS ACK [2020-01-01 00:00:00] << 0x00000003 322 HEADERS END_HEADERS [2020-01-01 00:00:00] << 0x00000003 288 DATA [2020-01-01 00:00:00] << 0x00000003 0 DATA END_STREAM [2020-01-01 00:00:00] << 0x00000000 8 GOAWAY [2020-01-01 00:00:05] << 0x00000000 8 GOAWAY Task Runner Logging \u00b6 This logs task enqueues, starts, and finishes. [2020-01-01 00:00:00] Q10000 scheduled after 0 \u00b5s: OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 starting : OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 run again after 300 s : OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 finished run in 1 ms: OkHttp ConnectionPool [2020-01-01 00:00:00] Q10001 scheduled after 0 \u00b5s: OkHttp squareup.com applyAndAckSettings [2020-01-01 00:00:00] Q10001 starting : OkHttp squareup.com applyAndAckSettings [2020-01-01 00:00:00] Q10003 scheduled after 0 \u00b5s: OkHttp squareup.com onSettings [2020-01-01 00:00:00] Q10003 starting : OkHttp squareup.com onSettings [2020-01-01 00:00:00] Q10001 finished run in 3 ms: OkHttp squareup.com applyAndAckSettings [2020-01-01 00:00:00] Q10003 finished run in 528 \u00b5s: OkHttp squareup.com onSettings [2020-01-01 00:00:00] Q10000 scheduled after 0 \u00b5s: OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 starting : OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 run again after 300 s : OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 finished run in 739 \u00b5s: OkHttp ConnectionPool","title":"Debug logging"},{"location":"debug_logging/#debug-logging","text":"OkHttp has internal APIs to enable debug logging. It uses the java.util.logging API which can be tricky to configure. As a shortcut, you can paste OkHttpDebugLogging.kt . Then enable debug logging for whichever features you need: OkHttpDebugLogging.enableHttp2() OkHttpDebugLogging.enableTaskRunner()","title":"Debug Logging"},{"location":"debug_logging/#activating-on-android","text":"$ adb shell setprop log.tag.okhttp.Http2 DEBUG $ adb shell setprop log.tag.okhttp.TaskRunner DEBUG $ adb logcat '*:E' 'okhttp.Http2:D' 'okhttp.TaskRunner:D'","title":"Activating on Android"},{"location":"debug_logging/#http2-frame-logging","text":"This logs inbound ( << ) and outbound ( >> ) frames for HTTP/2 connections. [2020-01-01 00:00:00] >> CONNECTION 505249202a20485454502f322e300d0a0d0a534d0d0a0d0a [2020-01-01 00:00:00] >> 0x00000000 6 SETTINGS [2020-01-01 00:00:00] >> 0x00000000 4 WINDOW_UPDATE [2020-01-01 00:00:00] >> 0x00000003 47 HEADERS END_STREAM|END_HEADERS [2020-01-01 00:00:00] << 0x00000000 6 SETTINGS [2020-01-01 00:00:00] << 0x00000000 0 SETTINGS ACK [2020-01-01 00:00:00] << 0x00000000 4 WINDOW_UPDATE [2020-01-01 00:00:00] >> 0x00000000 0 SETTINGS ACK [2020-01-01 00:00:00] << 0x00000003 322 HEADERS END_HEADERS [2020-01-01 00:00:00] << 0x00000003 288 DATA [2020-01-01 00:00:00] << 0x00000003 0 DATA END_STREAM [2020-01-01 00:00:00] << 0x00000000 8 GOAWAY [2020-01-01 00:00:05] << 0x00000000 8 GOAWAY","title":"HTTP/2 Frame Logging"},{"location":"debug_logging/#task-runner-logging","text":"This logs task enqueues, starts, and finishes. [2020-01-01 00:00:00] Q10000 scheduled after 0 \u00b5s: OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 starting : OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 run again after 300 s : OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 finished run in 1 ms: OkHttp ConnectionPool [2020-01-01 00:00:00] Q10001 scheduled after 0 \u00b5s: OkHttp squareup.com applyAndAckSettings [2020-01-01 00:00:00] Q10001 starting : OkHttp squareup.com applyAndAckSettings [2020-01-01 00:00:00] Q10003 scheduled after 0 \u00b5s: OkHttp squareup.com onSettings [2020-01-01 00:00:00] Q10003 starting : OkHttp squareup.com onSettings [2020-01-01 00:00:00] Q10001 finished run in 3 ms: OkHttp squareup.com applyAndAckSettings [2020-01-01 00:00:00] Q10003 finished run in 528 \u00b5s: OkHttp squareup.com onSettings [2020-01-01 00:00:00] Q10000 scheduled after 0 \u00b5s: OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 starting : OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 run again after 300 s : OkHttp ConnectionPool [2020-01-01 00:00:00] Q10000 finished run in 739 \u00b5s: OkHttp ConnectionPool","title":"Task Runner Logging"},{"location":"events/","text":"Events \u00b6 Events allow you to capture metrics on your application\u2019s HTTP calls. Use events to monitor: The size and frequency of the HTTP calls your application makes. If you\u2019re making too many calls, or your calls are too large, you should know about it! The performance of these calls on the underlying network. If the network\u2019s performance isn\u2019t sufficient, you need to either improve the network or use less of it. EventListener \u00b6 Subclass EventListener and override methods for the events you are interested in. In a successful HTTP call with no redirects or retries the sequence of events is described by this flow. Here\u2019s a sample event listener that prints each event with a timestamp. class PrintingEventListener extends EventListener { private long callStartNanos ; private void printEvent ( String name ) { long nowNanos = System . nanoTime (); if ( name . equals ( \"callStart\" )) { callStartNanos = nowNanos ; } long elapsedNanos = nowNanos - callStartNanos ; System . out . printf ( \"%.3f %s%n\" , elapsedNanos / 1000000000 d , name ); } @Override public void callStart ( Call call ) { printEvent ( \"callStart\" ); } @Override public void callEnd ( Call call ) { printEvent ( \"callEnd\" ); } @Override public void dnsStart ( Call call , String domainName ) { printEvent ( \"dnsStart\" ); } @Override public void dnsEnd ( Call call , String domainName , List < InetAddress > inetAddressList ) { printEvent ( \"dnsEnd\" ); } ... } We make a couple calls: Request request = new Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build (); System . out . println ( \"REQUEST 1 (new connection)\" ); try ( Response response = client . newCall ( request ). execute ()) { // Consume and discard the response body. response . body (). source (). readByteString (); } System . out . println ( \"REQUEST 2 (pooled connection)\" ); try ( Response response = client . newCall ( request ). execute ()) { // Consume and discard the response body. response . body (). source (). readByteString (); } And the listener prints the corresponding events: REQUEST 1 (new connection) 0.000 callStart 0.010 dnsStart 0.017 dnsEnd 0.025 connectStart 0.117 secureConnectStart 0.586 secureConnectEnd 0.586 connectEnd 0.587 connectionAcquired 0.588 requestHeadersStart 0.590 requestHeadersEnd 0.591 responseHeadersStart 0.675 responseHeadersEnd 0.676 responseBodyStart 0.679 responseBodyEnd 0.679 connectionReleased 0.680 callEnd REQUEST 2 (pooled connection) 0.000 callStart 0.001 connectionAcquired 0.001 requestHeadersStart 0.001 requestHeadersEnd 0.002 responseHeadersStart 0.082 responseHeadersEnd 0.082 responseBodyStart 0.082 responseBodyEnd 0.083 connectionReleased 0.083 callEnd Notice how no connect events are fired for the second call. It reused the connection from the first request for dramatically better performance. EventListener.Factory \u00b6 In the preceding example we used a field, callStartNanos , to track the elapsed time of each event. This is handy, but it won\u2019t work if multiple calls are executing concurrently. To accommodate this, use a Factory to create a new EventListener instance for each Call . This allows each listener to keep call-specific state. This sample factory creates a unique ID for each call and uses that ID to differentiate calls in log messages. class PrintingEventListener extends EventListener { public static final Factory FACTORY = new Factory () { final AtomicLong nextCallId = new AtomicLong ( 1L ); @Override public EventListener create ( Call call ) { long callId = nextCallId . getAndIncrement (); System . out . printf ( \"%04d %s%n\" , callId , call . request (). url ()); return new PrintingEventListener ( callId , System . nanoTime ()); } }; final long callId ; final long callStartNanos ; public PrintingEventListener ( long callId , long callStartNanos ) { this . callId = callId ; this . callStartNanos = callStartNanos ; } private void printEvent ( String name ) { long elapsedNanos = System . nanoTime () - callStartNanos ; System . out . printf ( \"%04d %.3f %s%n\" , callId , elapsedNanos / 1000000000 d , name ); } @Override public void callStart ( Call call ) { printEvent ( \"callStart\" ); } @Override public void callEnd ( Call call ) { printEvent ( \"callEnd\" ); } ... } We can use this listener to race a pair of concurrent HTTP requests: Request washingtonPostRequest = new Request . Builder () . url ( \"https://www.washingtonpost.com/\" ) . build (); client . newCall ( washingtonPostRequest ). enqueue ( new Callback () { ... }); Request newYorkTimesRequest = new Request . Builder () . url ( \"https://www.nytimes.com/\" ) . build (); client . newCall ( newYorkTimesRequest ). enqueue ( new Callback () { ... }); Running this race over home WiFi shows the Times ( 0002 ) completes just slightly sooner than the Post ( 0001 ): 0001 https://www.washingtonpost.com/ 0001 0.000 callStart 0002 https://www.nytimes.com/ 0002 0.000 callStart 0002 0.010 dnsStart 0001 0.013 dnsStart 0001 0.022 dnsEnd 0002 0.019 dnsEnd 0001 0.028 connectStart 0002 0.025 connectStart 0002 0.072 secureConnectStart 0001 0.075 secureConnectStart 0001 0.386 secureConnectEnd 0002 0.390 secureConnectEnd 0002 0.400 connectEnd 0001 0.403 connectEnd 0002 0.401 connectionAcquired 0001 0.404 connectionAcquired 0001 0.406 requestHeadersStart 0002 0.403 requestHeadersStart 0001 0.414 requestHeadersEnd 0002 0.411 requestHeadersEnd 0002 0.412 responseHeadersStart 0001 0.415 responseHeadersStart 0002 0.474 responseHeadersEnd 0002 0.475 responseBodyStart 0001 0.554 responseHeadersEnd 0001 0.555 responseBodyStart 0002 0.554 responseBodyEnd 0002 0.554 connectionReleased 0002 0.554 callEnd 0001 0.624 responseBodyEnd 0001 0.624 connectionReleased 0001 0.624 callEnd The EventListener.Factory also makes it possible to limit metrics to a subset of calls. This one captures metrics on a random 10%: class MetricsEventListener extends EventListener { private static final Factory FACTORY = new Factory () { @Override public EventListener create ( Call call ) { if ( Math . random () < 0.10 ) { return new MetricsEventListener ( call ); } else { return EventListener . NONE ; } } }; ... } Events with Failures \u00b6 When an operation fails, a failure method is called. This is connectFailed() for failures while building a connection to the server, and callFailed() when the HTTP call fails permanently. When a failure happens it is possible that a start event won\u2019t have a corresponding end event. Events with Retries and Follow-Ups \u00b6 OkHttp is resilient and can automatically recover from some connectivity failures. In this case, the connectFailed() event is not terminal and not followed by callFailed() . Event listeners will receive multiple events of the same type when retries are attempted. A single HTTP call may require follow-up requests to be made to handle authentication challenges, redirects, and HTTP-layer timeouts. In such cases multiple connections, requests, and responses may be attempted. Follow-ups are another reason a single call may trigger multiple events of the same type. Availability \u00b6 Events is available as a public API in OkHttp 3.11. Future releases may introduce new event types; you will need to override the corresponding methods to handle them.","title":"Events"},{"location":"events/#events","text":"Events allow you to capture metrics on your application\u2019s HTTP calls. Use events to monitor: The size and frequency of the HTTP calls your application makes. If you\u2019re making too many calls, or your calls are too large, you should know about it! The performance of these calls on the underlying network. If the network\u2019s performance isn\u2019t sufficient, you need to either improve the network or use less of it.","title":"Events"},{"location":"events/#eventlistener","text":"Subclass EventListener and override methods for the events you are interested in. In a successful HTTP call with no redirects or retries the sequence of events is described by this flow. Here\u2019s a sample event listener that prints each event with a timestamp. class PrintingEventListener extends EventListener { private long callStartNanos ; private void printEvent ( String name ) { long nowNanos = System . nanoTime (); if ( name . equals ( \"callStart\" )) { callStartNanos = nowNanos ; } long elapsedNanos = nowNanos - callStartNanos ; System . out . printf ( \"%.3f %s%n\" , elapsedNanos / 1000000000 d , name ); } @Override public void callStart ( Call call ) { printEvent ( \"callStart\" ); } @Override public void callEnd ( Call call ) { printEvent ( \"callEnd\" ); } @Override public void dnsStart ( Call call , String domainName ) { printEvent ( \"dnsStart\" ); } @Override public void dnsEnd ( Call call , String domainName , List < InetAddress > inetAddressList ) { printEvent ( \"dnsEnd\" ); } ... } We make a couple calls: Request request = new Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build (); System . out . println ( \"REQUEST 1 (new connection)\" ); try ( Response response = client . newCall ( request ). execute ()) { // Consume and discard the response body. response . body (). source (). readByteString (); } System . out . println ( \"REQUEST 2 (pooled connection)\" ); try ( Response response = client . newCall ( request ). execute ()) { // Consume and discard the response body. response . body (). source (). readByteString (); } And the listener prints the corresponding events: REQUEST 1 (new connection) 0.000 callStart 0.010 dnsStart 0.017 dnsEnd 0.025 connectStart 0.117 secureConnectStart 0.586 secureConnectEnd 0.586 connectEnd 0.587 connectionAcquired 0.588 requestHeadersStart 0.590 requestHeadersEnd 0.591 responseHeadersStart 0.675 responseHeadersEnd 0.676 responseBodyStart 0.679 responseBodyEnd 0.679 connectionReleased 0.680 callEnd REQUEST 2 (pooled connection) 0.000 callStart 0.001 connectionAcquired 0.001 requestHeadersStart 0.001 requestHeadersEnd 0.002 responseHeadersStart 0.082 responseHeadersEnd 0.082 responseBodyStart 0.082 responseBodyEnd 0.083 connectionReleased 0.083 callEnd Notice how no connect events are fired for the second call. It reused the connection from the first request for dramatically better performance.","title":"EventListener"},{"location":"events/#eventlistenerfactory","text":"In the preceding example we used a field, callStartNanos , to track the elapsed time of each event. This is handy, but it won\u2019t work if multiple calls are executing concurrently. To accommodate this, use a Factory to create a new EventListener instance for each Call . This allows each listener to keep call-specific state. This sample factory creates a unique ID for each call and uses that ID to differentiate calls in log messages. class PrintingEventListener extends EventListener { public static final Factory FACTORY = new Factory () { final AtomicLong nextCallId = new AtomicLong ( 1L ); @Override public EventListener create ( Call call ) { long callId = nextCallId . getAndIncrement (); System . out . printf ( \"%04d %s%n\" , callId , call . request (). url ()); return new PrintingEventListener ( callId , System . nanoTime ()); } }; final long callId ; final long callStartNanos ; public PrintingEventListener ( long callId , long callStartNanos ) { this . callId = callId ; this . callStartNanos = callStartNanos ; } private void printEvent ( String name ) { long elapsedNanos = System . nanoTime () - callStartNanos ; System . out . printf ( \"%04d %.3f %s%n\" , callId , elapsedNanos / 1000000000 d , name ); } @Override public void callStart ( Call call ) { printEvent ( \"callStart\" ); } @Override public void callEnd ( Call call ) { printEvent ( \"callEnd\" ); } ... } We can use this listener to race a pair of concurrent HTTP requests: Request washingtonPostRequest = new Request . Builder () . url ( \"https://www.washingtonpost.com/\" ) . build (); client . newCall ( washingtonPostRequest ). enqueue ( new Callback () { ... }); Request newYorkTimesRequest = new Request . Builder () . url ( \"https://www.nytimes.com/\" ) . build (); client . newCall ( newYorkTimesRequest ). enqueue ( new Callback () { ... }); Running this race over home WiFi shows the Times ( 0002 ) completes just slightly sooner than the Post ( 0001 ): 0001 https://www.washingtonpost.com/ 0001 0.000 callStart 0002 https://www.nytimes.com/ 0002 0.000 callStart 0002 0.010 dnsStart 0001 0.013 dnsStart 0001 0.022 dnsEnd 0002 0.019 dnsEnd 0001 0.028 connectStart 0002 0.025 connectStart 0002 0.072 secureConnectStart 0001 0.075 secureConnectStart 0001 0.386 secureConnectEnd 0002 0.390 secureConnectEnd 0002 0.400 connectEnd 0001 0.403 connectEnd 0002 0.401 connectionAcquired 0001 0.404 connectionAcquired 0001 0.406 requestHeadersStart 0002 0.403 requestHeadersStart 0001 0.414 requestHeadersEnd 0002 0.411 requestHeadersEnd 0002 0.412 responseHeadersStart 0001 0.415 responseHeadersStart 0002 0.474 responseHeadersEnd 0002 0.475 responseBodyStart 0001 0.554 responseHeadersEnd 0001 0.555 responseBodyStart 0002 0.554 responseBodyEnd 0002 0.554 connectionReleased 0002 0.554 callEnd 0001 0.624 responseBodyEnd 0001 0.624 connectionReleased 0001 0.624 callEnd The EventListener.Factory also makes it possible to limit metrics to a subset of calls. This one captures metrics on a random 10%: class MetricsEventListener extends EventListener { private static final Factory FACTORY = new Factory () { @Override public EventListener create ( Call call ) { if ( Math . random () < 0.10 ) { return new MetricsEventListener ( call ); } else { return EventListener . NONE ; } } }; ... }","title":"EventListener.Factory"},{"location":"events/#events-with-failures","text":"When an operation fails, a failure method is called. This is connectFailed() for failures while building a connection to the server, and callFailed() when the HTTP call fails permanently. When a failure happens it is possible that a start event won\u2019t have a corresponding end event.","title":"Events with Failures"},{"location":"events/#events-with-retries-and-follow-ups","text":"OkHttp is resilient and can automatically recover from some connectivity failures. In this case, the connectFailed() event is not terminal and not followed by callFailed() . Event listeners will receive multiple events of the same type when retries are attempted. A single HTTP call may require follow-up requests to be made to handle authentication challenges, redirects, and HTTP-layer timeouts. In such cases multiple connections, requests, and responses may be attempted. Follow-ups are another reason a single call may trigger multiple events of the same type.","title":"Events with Retries and Follow-Ups"},{"location":"events/#availability","text":"Events is available as a public API in OkHttp 3.11. Future releases may introduce new event types; you will need to override the corresponding methods to handle them.","title":"Availability"},{"location":"https/","text":"HTTPS \u00b6 OkHttp attempts to balance two competing concerns: Connectivity to as many hosts as possible. That includes advanced hosts that run the latest versions of boringssl and less out of date hosts running older versions of OpenSSL . Security of the connection. This includes verification of the remote webserver with certificates and the privacy of data exchanged with strong ciphers. When negotiating a connection to an HTTPS server, OkHttp needs to know which TLS versions and cipher suites to offer. A client that wants to maximize connectivity would include obsolete TLS versions and weak-by-design cipher suites. A strict client that wants to maximize security would be limited to only the latest TLS version and strongest cipher suites. Specific security vs. connectivity decisions are implemented by ConnectionSpec . OkHttp includes four built-in connection specs: RESTRICTED_TLS is a secure configuration, intended to meet stricter compliance requirements. MODERN_TLS is a secure configuration that connects to modern HTTPS servers. COMPATIBLE_TLS is a secure configuration that connects to secure\u2013but not current\u2013HTTPS servers. CLEARTEXT is an insecure configuration that is used for http:// URLs. These loosely follow the model set in Google Cloud Policies . We track changes to this policy. By default, OkHttp will attempt a MODERN_TLS connection. However by configuring the client connectionSpecs you can allow a fall back to COMPATIBLE_TLS connection if the modern configuration fails. OkHttpClient client = new OkHttpClient . Builder () . connectionSpecs ( Arrays . asList ( ConnectionSpec . MODERN_TLS , ConnectionSpec . COMPATIBLE_TLS )) . build (); The TLS versions and cipher suites in each spec can change with each release. For example, in OkHttp 2.2 we dropped support for SSL 3.0 in response to the POODLE attack. And in OkHttp 2.3 we dropped support for RC4 . As with your desktop web browser, staying up-to-date with OkHttp is the best way to stay secure. You can build your own connection spec with a custom set of TLS versions and cipher suites. For example, this configuration is limited to three highly-regarded cipher suites. Its drawback is that it requires Android 5.0+ and a similarly current webserver. ConnectionSpec spec = new ConnectionSpec . Builder ( ConnectionSpec . MODERN_TLS ) . tlsVersions ( TlsVersion . TLS_1_2 ) . cipherSuites ( CipherSuite . TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 , CipherSuite . TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 , CipherSuite . TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 ) . build (); OkHttpClient client = new OkHttpClient . Builder () . connectionSpecs ( Collections . singletonList ( spec )) . build (); Debugging TLS Handshake Failures \u00b6 The TLS handshake requires clients and servers to share a common TLS version and cipher suite. This depends on the JVM or Android version, OkHttp version, and web server configuration. If there is no common cipher suite and TLS version, your call will fail like this: Caused by: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0x7f2719a89e80: Failure in SSL library, usually a protocol error error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure (external/openssl/ssl/s23_clnt.c:770 0x7f2728a53ea0:0x00000000) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) You can check a web server\u2019s configuration using Qualys SSL Labs . OkHttp\u2019s TLS configuration history is tracked here . Applications expected to be installed on older Android devices should consider adopting the Google Play Services\u2019 ProviderInstaller . This will increase security for users and increase connectivity with web servers. Certificate Pinning ( .kt , .java ) \u00b6 By default, OkHttp trusts the certificate authorities of the host platform. This strategy maximizes connectivity, but it is subject to certificate authority attacks such as the 2011 DigiNotar attack . It also assumes your HTTPS servers\u2019 certificates are signed by a certificate authority. Use CertificatePinner to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team\u2019s abilities to update their TLS certificates. Do not use certificate pinning without the blessing of your server\u2019s TLS administrator! Kotlin private val client = OkHttpClient . Builder () . certificatePinner ( CertificatePinner . Builder () . add ( \"publicobject.com\" , \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\" ) . build ()) . build () fun run () { val request = Request . Builder () . url ( \"https://publicobject.com/robots.txt\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) for ( certificate in response . handshake !! . peerCertificates ) { println ( CertificatePinner . pin ( certificate )) } } } Java private final OkHttpClient client = new OkHttpClient . Builder () . certificatePinner ( new CertificatePinner . Builder () . add ( \"publicobject.com\" , \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\" ) . build ()) . build (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://publicobject.com/robots.txt\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); for ( Certificate certificate : response . handshake (). peerCertificates ()) { System . out . println ( CertificatePinner . pin ( certificate )); } } } Customizing Trusted Certificates ( .kt , .java ) \u00b6 The full code sample shows how to replace the host platform\u2019s certificate authorities with your own set. As above, do not use custom certificates without the blessing of your server\u2019s TLS administrator! Kotlin private val client : OkHttpClient init { val trustManager = trustManagerForCertificates ( trustedCertificatesInputStream ()) val sslContext = SSLContext . getInstance ( \"TLS\" ) sslContext . init ( null , arrayOf < TrustManager >( trustManager ), null ) val sslSocketFactory = sslContext . socketFactory client = OkHttpClient . Builder () . sslSocketFactory ( sslSocketFactory , trustManager ) . build () } fun run () { val request = Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) for (( name , value ) in response . headers ) { println ( \"$name: $value\" ) } println ( response . body !! . string ()) } } /** * Returns an input stream containing one or more certificate PEM files. This implementation just * embeds the PEM files in Java strings; most applications will instead read this from a resource * file that gets bundled with the application. */ private fun trustedCertificatesInputStream (): InputStream { ... // Full source omitted. See sample. } private fun trustManagerForCertificates ( inputStream : InputStream ): X509TrustManager { ... // Full source omitted. See sample. } Java private final OkHttpClient client ; public CustomTrust () { X509TrustManager trustManager ; SSLSocketFactory sslSocketFactory ; try { trustManager = trustManagerForCertificates ( trustedCertificatesInputStream ()); SSLContext sslContext = SSLContext . getInstance ( \"TLS\" ); sslContext . init ( null , new TrustManager [] { trustManager }, null ); sslSocketFactory = sslContext . getSocketFactory (); } catch ( GeneralSecurityException e ) { throw new RuntimeException ( e ); } client = new OkHttpClient . Builder () . sslSocketFactory ( sslSocketFactory , trustManager ) . build (); } public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build (); Response response = client . newCall ( request ). execute (); System . out . println ( response . body (). string ()); } private InputStream trustedCertificatesInputStream () { ... // Full source omitted. See sample. } public SSLContext sslContextForTrustedCertificates ( InputStream in ) { ... // Full source omitted. See sample. }","title":"HTTPS"},{"location":"https/#https","text":"OkHttp attempts to balance two competing concerns: Connectivity to as many hosts as possible. That includes advanced hosts that run the latest versions of boringssl and less out of date hosts running older versions of OpenSSL . Security of the connection. This includes verification of the remote webserver with certificates and the privacy of data exchanged with strong ciphers. When negotiating a connection to an HTTPS server, OkHttp needs to know which TLS versions and cipher suites to offer. A client that wants to maximize connectivity would include obsolete TLS versions and weak-by-design cipher suites. A strict client that wants to maximize security would be limited to only the latest TLS version and strongest cipher suites. Specific security vs. connectivity decisions are implemented by ConnectionSpec . OkHttp includes four built-in connection specs: RESTRICTED_TLS is a secure configuration, intended to meet stricter compliance requirements. MODERN_TLS is a secure configuration that connects to modern HTTPS servers. COMPATIBLE_TLS is a secure configuration that connects to secure\u2013but not current\u2013HTTPS servers. CLEARTEXT is an insecure configuration that is used for http:// URLs. These loosely follow the model set in Google Cloud Policies . We track changes to this policy. By default, OkHttp will attempt a MODERN_TLS connection. However by configuring the client connectionSpecs you can allow a fall back to COMPATIBLE_TLS connection if the modern configuration fails. OkHttpClient client = new OkHttpClient . Builder () . connectionSpecs ( Arrays . asList ( ConnectionSpec . MODERN_TLS , ConnectionSpec . COMPATIBLE_TLS )) . build (); The TLS versions and cipher suites in each spec can change with each release. For example, in OkHttp 2.2 we dropped support for SSL 3.0 in response to the POODLE attack. And in OkHttp 2.3 we dropped support for RC4 . As with your desktop web browser, staying up-to-date with OkHttp is the best way to stay secure. You can build your own connection spec with a custom set of TLS versions and cipher suites. For example, this configuration is limited to three highly-regarded cipher suites. Its drawback is that it requires Android 5.0+ and a similarly current webserver. ConnectionSpec spec = new ConnectionSpec . Builder ( ConnectionSpec . MODERN_TLS ) . tlsVersions ( TlsVersion . TLS_1_2 ) . cipherSuites ( CipherSuite . TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 , CipherSuite . TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 , CipherSuite . TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 ) . build (); OkHttpClient client = new OkHttpClient . Builder () . connectionSpecs ( Collections . singletonList ( spec )) . build ();","title":"HTTPS"},{"location":"https/#debugging-tls-handshake-failures","text":"The TLS handshake requires clients and servers to share a common TLS version and cipher suite. This depends on the JVM or Android version, OkHttp version, and web server configuration. If there is no common cipher suite and TLS version, your call will fail like this: Caused by: javax.net.ssl.SSLProtocolException: SSL handshake aborted: ssl=0x7f2719a89e80: Failure in SSL library, usually a protocol error error:14077410:SSL routines:SSL23_GET_SERVER_HELLO:sslv3 alert handshake failure (external/openssl/ssl/s23_clnt.c:770 0x7f2728a53ea0:0x00000000) at com.android.org.conscrypt.NativeCrypto.SSL_do_handshake(Native Method) You can check a web server\u2019s configuration using Qualys SSL Labs . OkHttp\u2019s TLS configuration history is tracked here . Applications expected to be installed on older Android devices should consider adopting the Google Play Services\u2019 ProviderInstaller . This will increase security for users and increase connectivity with web servers.","title":"Debugging TLS Handshake Failures"},{"location":"https/#certificate-pinning-kt-java","text":"By default, OkHttp trusts the certificate authorities of the host platform. This strategy maximizes connectivity, but it is subject to certificate authority attacks such as the 2011 DigiNotar attack . It also assumes your HTTPS servers\u2019 certificates are signed by a certificate authority. Use CertificatePinner to restrict which certificates and certificate authorities are trusted. Certificate pinning increases security, but limits your server team\u2019s abilities to update their TLS certificates. Do not use certificate pinning without the blessing of your server\u2019s TLS administrator! Kotlin private val client = OkHttpClient . Builder () . certificatePinner ( CertificatePinner . Builder () . add ( \"publicobject.com\" , \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\" ) . build ()) . build () fun run () { val request = Request . Builder () . url ( \"https://publicobject.com/robots.txt\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) for ( certificate in response . handshake !! . peerCertificates ) { println ( CertificatePinner . pin ( certificate )) } } } Java private final OkHttpClient client = new OkHttpClient . Builder () . certificatePinner ( new CertificatePinner . Builder () . add ( \"publicobject.com\" , \"sha256/afwiKY3RxoMmLkuRW1l7QsPZTJPwDS2pdDROQjXw8ig=\" ) . build ()) . build (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://publicobject.com/robots.txt\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); for ( Certificate certificate : response . handshake (). peerCertificates ()) { System . out . println ( CertificatePinner . pin ( certificate )); } } }","title":"Certificate Pinning (.kt, .java)"},{"location":"https/#customizing-trusted-certificates-kt-java","text":"The full code sample shows how to replace the host platform\u2019s certificate authorities with your own set. As above, do not use custom certificates without the blessing of your server\u2019s TLS administrator! Kotlin private val client : OkHttpClient init { val trustManager = trustManagerForCertificates ( trustedCertificatesInputStream ()) val sslContext = SSLContext . getInstance ( \"TLS\" ) sslContext . init ( null , arrayOf < TrustManager >( trustManager ), null ) val sslSocketFactory = sslContext . socketFactory client = OkHttpClient . Builder () . sslSocketFactory ( sslSocketFactory , trustManager ) . build () } fun run () { val request = Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) for (( name , value ) in response . headers ) { println ( \"$name: $value\" ) } println ( response . body !! . string ()) } } /** * Returns an input stream containing one or more certificate PEM files. This implementation just * embeds the PEM files in Java strings; most applications will instead read this from a resource * file that gets bundled with the application. */ private fun trustedCertificatesInputStream (): InputStream { ... // Full source omitted. See sample. } private fun trustManagerForCertificates ( inputStream : InputStream ): X509TrustManager { ... // Full source omitted. See sample. } Java private final OkHttpClient client ; public CustomTrust () { X509TrustManager trustManager ; SSLSocketFactory sslSocketFactory ; try { trustManager = trustManagerForCertificates ( trustedCertificatesInputStream ()); SSLContext sslContext = SSLContext . getInstance ( \"TLS\" ); sslContext . init ( null , new TrustManager [] { trustManager }, null ); sslSocketFactory = sslContext . getSocketFactory (); } catch ( GeneralSecurityException e ) { throw new RuntimeException ( e ); } client = new OkHttpClient . Builder () . sslSocketFactory ( sslSocketFactory , trustManager ) . build (); } public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build (); Response response = client . newCall ( request ). execute (); System . out . println ( response . body (). string ()); } private InputStream trustedCertificatesInputStream () { ... // Full source omitted. See sample. } public SSLContext sslContextForTrustedCertificates ( InputStream in ) { ... // Full source omitted. See sample. }","title":"Customizing Trusted Certificates (.kt, .java)"},{"location":"interceptors/","text":"Interceptors \u00b6 Interceptors are a powerful mechanism that can monitor, rewrite, and retry calls. Here\u2019s a simple interceptor that logs the outgoing request and the incoming response. class LoggingInterceptor implements Interceptor { @Override public Response intercept ( Interceptor . Chain chain ) throws IOException { Request request = chain . request (); long t1 = System . nanoTime (); logger . info ( String . format ( \"Sending request %s on %s%n%s\" , request . url (), chain . connection (), request . headers ())); Response response = chain . proceed ( request ); long t2 = System . nanoTime (); logger . info ( String . format ( \"Received response for %s in %.1fms%n%s\" , response . request (). url (), ( t2 - t1 ) / 1e6d , response . headers ())); return response ; } } A call to chain.proceed(request) is a critical part of each interceptor\u2019s implementation. This simple-looking method is where all the HTTP work happens, producing a response to satisfy the request. If chain.proceed(request) is being called more than once previous response bodies must be closed. Interceptors can be chained. Suppose you have both a compressing interceptor and a checksumming interceptor: you\u2019ll need to decide whether data is compressed and then checksummed, or checksummed and then compressed. OkHttp uses lists to track interceptors, and interceptors are called in order. Application Interceptors \u00b6 Interceptors are registered as either application or network interceptors. We\u2019ll use the LoggingInterceptor defined above to show the difference. Register an application interceptor by calling addInterceptor() on OkHttpClient.Builder : OkHttpClient client = new OkHttpClient . Builder () . addInterceptor ( new LoggingInterceptor ()) . build (); Request request = new Request . Builder () . url ( \"http://www.publicobject.com/helloworld.txt\" ) . header ( \"User-Agent\" , \"OkHttp Example\" ) . build (); Response response = client . newCall ( request ). execute (); response . body (). close (); The URL http://www.publicobject.com/helloworld.txt redirects to https://publicobject.com/helloworld.txt , and OkHttp follows this redirect automatically. Our application interceptor is called once and the response returned from chain.proceed() has the redirected response: INFO: Sending request http://www.publicobject.com/helloworld.txt on null User-Agent: OkHttp Example INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms Server: nginx/1.4.6 (Ubuntu) Content-Type: text/plain Content-Length: 1759 Connection: keep-alive We can see that we were redirected because response.request().url() is different from request.url() . The two log statements log two different URLs. Network Interceptors \u00b6 Registering a network interceptor is quite similar. Call addNetworkInterceptor() instead of addInterceptor() : OkHttpClient client = new OkHttpClient . Builder () . addNetworkInterceptor ( new LoggingInterceptor ()) . build (); Request request = new Request . Builder () . url ( \"http://www.publicobject.com/helloworld.txt\" ) . header ( \"User-Agent\" , \"OkHttp Example\" ) . build (); Response response = client . newCall ( request ). execute (); response . body (). close (); When we run this code, the interceptor runs twice. Once for the initial request to http://www.publicobject.com/helloworld.txt , and another for the redirect to https://publicobject.com/helloworld.txt . INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1} User-Agent: OkHttp Example Host: www.publicobject.com Connection: Keep-Alive Accept-Encoding: gzip INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms Server: nginx/1.4.6 (Ubuntu) Content-Type: text/html Content-Length: 193 Connection: keep-alive Location: https://publicobject.com/helloworld.txt INFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1} User-Agent: OkHttp Example Host: publicobject.com Connection: Keep-Alive Accept-Encoding: gzip INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms Server: nginx/1.4.6 (Ubuntu) Content-Type: text/plain Content-Length: 1759 Connection: keep-alive The network requests also contain more data, such as the Accept-Encoding: gzip header added by OkHttp to advertise support for response compression. The network interceptor\u2019s Chain has a non-null Connection that can be used to interrogate the IP address and TLS configuration that were used to connect to the webserver. Choosing between application and network interceptors \u00b6 Each interceptor chain has relative merits. Application interceptors Don\u2019t need to worry about intermediate responses like redirects and retries. Are always invoked once, even if the HTTP response is served from the cache. Observe the application\u2019s original intent. Unconcerned with OkHttp-injected headers like If-None-Match . Permitted to short-circuit and not call Chain.proceed() . Permitted to retry and make multiple calls to Chain.proceed() . Can adjust Call timeouts using withConnectTimeout, withReadTimeout, withWriteTimeout. Network Interceptors Able to operate on intermediate responses like redirects and retries. Not invoked for cached responses that short-circuit the network. Observe the data just as it will be transmitted over the network. Access to the Connection that carries the request. Rewriting Requests \u00b6 Interceptors can add, remove, or replace request headers. They can also transform the body of those requests that have one. For example, you can use an application interceptor to add request body compression if you\u2019re connecting to a webserver known to support it. /** This interceptor compresses the HTTP request body. Many webservers can't handle this! */ final class GzipRequestInterceptor implements Interceptor { @Override public Response intercept ( Interceptor . Chain chain ) throws IOException { Request originalRequest = chain . request (); if ( originalRequest . body () == null || originalRequest . header ( \"Content-Encoding\" ) != null ) { return chain . proceed ( originalRequest ); } Request compressedRequest = originalRequest . newBuilder () . header ( \"Content-Encoding\" , \"gzip\" ) . method ( originalRequest . method (), gzip ( originalRequest . body ())) . build (); return chain . proceed ( compressedRequest ); } private RequestBody gzip ( final RequestBody body ) { return new RequestBody () { @Override public MediaType contentType () { return body . contentType (); } @Override public long contentLength () { return - 1 ; // We don't know the compressed length in advance! } @Override public void writeTo ( BufferedSink sink ) throws IOException { BufferedSink gzipSink = Okio . buffer ( new GzipSink ( sink )); body . writeTo ( gzipSink ); gzipSink . close (); } }; } } Rewriting Responses \u00b6 Symmetrically, interceptors can rewrite response headers and transform the response body. This is generally more dangerous than rewriting request headers because it may violate the webserver\u2019s expectations! If you\u2019re in a tricky situation and prepared to deal with the consequences, rewriting response headers is a powerful way to work around problems. For example, you can fix a server\u2019s misconfigured Cache-Control response header to enable better response caching: /** Dangerous interceptor that rewrites the server's cache-control header. */ private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor () { @Override public Response intercept ( Interceptor . Chain chain ) throws IOException { Response originalResponse = chain . proceed ( chain . request ()); return originalResponse . newBuilder () . header ( \"Cache-Control\" , \"max-age=60\" ) . build (); } }; Typically this approach works best when it complements a corresponding fix on the webserver!","title":"Interceptors"},{"location":"interceptors/#interceptors","text":"Interceptors are a powerful mechanism that can monitor, rewrite, and retry calls. Here\u2019s a simple interceptor that logs the outgoing request and the incoming response. class LoggingInterceptor implements Interceptor { @Override public Response intercept ( Interceptor . Chain chain ) throws IOException { Request request = chain . request (); long t1 = System . nanoTime (); logger . info ( String . format ( \"Sending request %s on %s%n%s\" , request . url (), chain . connection (), request . headers ())); Response response = chain . proceed ( request ); long t2 = System . nanoTime (); logger . info ( String . format ( \"Received response for %s in %.1fms%n%s\" , response . request (). url (), ( t2 - t1 ) / 1e6d , response . headers ())); return response ; } } A call to chain.proceed(request) is a critical part of each interceptor\u2019s implementation. This simple-looking method is where all the HTTP work happens, producing a response to satisfy the request. If chain.proceed(request) is being called more than once previous response bodies must be closed. Interceptors can be chained. Suppose you have both a compressing interceptor and a checksumming interceptor: you\u2019ll need to decide whether data is compressed and then checksummed, or checksummed and then compressed. OkHttp uses lists to track interceptors, and interceptors are called in order.","title":"Interceptors"},{"location":"interceptors/#application-interceptors","text":"Interceptors are registered as either application or network interceptors. We\u2019ll use the LoggingInterceptor defined above to show the difference. Register an application interceptor by calling addInterceptor() on OkHttpClient.Builder : OkHttpClient client = new OkHttpClient . Builder () . addInterceptor ( new LoggingInterceptor ()) . build (); Request request = new Request . Builder () . url ( \"http://www.publicobject.com/helloworld.txt\" ) . header ( \"User-Agent\" , \"OkHttp Example\" ) . build (); Response response = client . newCall ( request ). execute (); response . body (). close (); The URL http://www.publicobject.com/helloworld.txt redirects to https://publicobject.com/helloworld.txt , and OkHttp follows this redirect automatically. Our application interceptor is called once and the response returned from chain.proceed() has the redirected response: INFO: Sending request http://www.publicobject.com/helloworld.txt on null User-Agent: OkHttp Example INFO: Received response for https://publicobject.com/helloworld.txt in 1179.7ms Server: nginx/1.4.6 (Ubuntu) Content-Type: text/plain Content-Length: 1759 Connection: keep-alive We can see that we were redirected because response.request().url() is different from request.url() . The two log statements log two different URLs.","title":"Application Interceptors"},{"location":"interceptors/#network-interceptors","text":"Registering a network interceptor is quite similar. Call addNetworkInterceptor() instead of addInterceptor() : OkHttpClient client = new OkHttpClient . Builder () . addNetworkInterceptor ( new LoggingInterceptor ()) . build (); Request request = new Request . Builder () . url ( \"http://www.publicobject.com/helloworld.txt\" ) . header ( \"User-Agent\" , \"OkHttp Example\" ) . build (); Response response = client . newCall ( request ). execute (); response . body (). close (); When we run this code, the interceptor runs twice. Once for the initial request to http://www.publicobject.com/helloworld.txt , and another for the redirect to https://publicobject.com/helloworld.txt . INFO: Sending request http://www.publicobject.com/helloworld.txt on Connection{www.publicobject.com:80, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=none protocol=http/1.1} User-Agent: OkHttp Example Host: www.publicobject.com Connection: Keep-Alive Accept-Encoding: gzip INFO: Received response for http://www.publicobject.com/helloworld.txt in 115.6ms Server: nginx/1.4.6 (Ubuntu) Content-Type: text/html Content-Length: 193 Connection: keep-alive Location: https://publicobject.com/helloworld.txt INFO: Sending request https://publicobject.com/helloworld.txt on Connection{publicobject.com:443, proxy=DIRECT hostAddress=54.187.32.157 cipherSuite=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA protocol=http/1.1} User-Agent: OkHttp Example Host: publicobject.com Connection: Keep-Alive Accept-Encoding: gzip INFO: Received response for https://publicobject.com/helloworld.txt in 80.9ms Server: nginx/1.4.6 (Ubuntu) Content-Type: text/plain Content-Length: 1759 Connection: keep-alive The network requests also contain more data, such as the Accept-Encoding: gzip header added by OkHttp to advertise support for response compression. The network interceptor\u2019s Chain has a non-null Connection that can be used to interrogate the IP address and TLS configuration that were used to connect to the webserver.","title":"Network Interceptors"},{"location":"interceptors/#choosing-between-application-and-network-interceptors","text":"Each interceptor chain has relative merits. Application interceptors Don\u2019t need to worry about intermediate responses like redirects and retries. Are always invoked once, even if the HTTP response is served from the cache. Observe the application\u2019s original intent. Unconcerned with OkHttp-injected headers like If-None-Match . Permitted to short-circuit and not call Chain.proceed() . Permitted to retry and make multiple calls to Chain.proceed() . Can adjust Call timeouts using withConnectTimeout, withReadTimeout, withWriteTimeout. Network Interceptors Able to operate on intermediate responses like redirects and retries. Not invoked for cached responses that short-circuit the network. Observe the data just as it will be transmitted over the network. Access to the Connection that carries the request.","title":"Choosing between application and network interceptors"},{"location":"interceptors/#rewriting-requests","text":"Interceptors can add, remove, or replace request headers. They can also transform the body of those requests that have one. For example, you can use an application interceptor to add request body compression if you\u2019re connecting to a webserver known to support it. /** This interceptor compresses the HTTP request body. Many webservers can't handle this! */ final class GzipRequestInterceptor implements Interceptor { @Override public Response intercept ( Interceptor . Chain chain ) throws IOException { Request originalRequest = chain . request (); if ( originalRequest . body () == null || originalRequest . header ( \"Content-Encoding\" ) != null ) { return chain . proceed ( originalRequest ); } Request compressedRequest = originalRequest . newBuilder () . header ( \"Content-Encoding\" , \"gzip\" ) . method ( originalRequest . method (), gzip ( originalRequest . body ())) . build (); return chain . proceed ( compressedRequest ); } private RequestBody gzip ( final RequestBody body ) { return new RequestBody () { @Override public MediaType contentType () { return body . contentType (); } @Override public long contentLength () { return - 1 ; // We don't know the compressed length in advance! } @Override public void writeTo ( BufferedSink sink ) throws IOException { BufferedSink gzipSink = Okio . buffer ( new GzipSink ( sink )); body . writeTo ( gzipSink ); gzipSink . close (); } }; } }","title":"Rewriting Requests"},{"location":"interceptors/#rewriting-responses","text":"Symmetrically, interceptors can rewrite response headers and transform the response body. This is generally more dangerous than rewriting request headers because it may violate the webserver\u2019s expectations! If you\u2019re in a tricky situation and prepared to deal with the consequences, rewriting response headers is a powerful way to work around problems. For example, you can fix a server\u2019s misconfigured Cache-Control response header to enable better response caching: /** Dangerous interceptor that rewrites the server's cache-control header. */ private static final Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR = new Interceptor () { @Override public Response intercept ( Interceptor . Chain chain ) throws IOException { Response originalResponse = chain . proceed ( chain . request ()); return originalResponse . newBuilder () . header ( \"Cache-Control\" , \"max-age=60\" ) . build (); } }; Typically this approach works best when it complements a corresponding fix on the webserver!","title":"Rewriting Responses"},{"location":"r8_proguard/","text":"R8 / ProGuard \u00b6 If you use OkHttp as a dependency in an Android project which uses R8 as a default compiler you don\u2019t have to do anything. The specific rules are already bundled into the JAR which can be interpreted by R8 automatically. If you, however, don\u2019t use R8 you have to apply the rules from this file . You might also need rules from Okio which is a dependency of this library.","title":"R8 proguard"},{"location":"r8_proguard/#r8-proguard","text":"If you use OkHttp as a dependency in an Android project which uses R8 as a default compiler you don\u2019t have to do anything. The specific rules are already bundled into the JAR which can be interpreted by R8 automatically. If you, however, don\u2019t use R8 you have to apply the rules from this file . You might also need rules from Okio which is a dependency of this library.","title":"R8 / ProGuard"},{"location":"recipes/","text":"Recipes \u00b6 We\u2019ve written some recipes that demonstrate how to solve common problems with OkHttp. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that\u2019s what they\u2019re for. Synchronous Get ( .kt , .java ) \u00b6 Download a file, print its headers, and print its response body as a string. The string() method on response body is convenient and efficient for small documents. But if the response body is large (greater than 1 MiB), avoid string() because it will load the entire document into memory. In that case, prefer to process the body as a stream. Kotlin private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) for (( name , value ) in response . headers ) { println ( \"$name: $value\" ) } println ( response . body !! . string ()) } } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); Headers responseHeaders = response . headers (); for ( int i = 0 ; i < responseHeaders . size (); i ++ ) { System . out . println ( responseHeaders . name ( i ) + \": \" + responseHeaders . value ( i )); } System . out . println ( response . body (). string ()); } } Asynchronous Get ( .kt , .java ) \u00b6 Download a file on a worker thread, and get called back when the response is readable. The callback is made after the response headers are ready. Reading the response body may still block. OkHttp doesn\u2019t currently offer asynchronous APIs to receive a response body in parts. Kotlin private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"http://publicobject.com/helloworld.txt\" ) . build () client . newCall ( request ). enqueue ( object : Callback { override fun onFailure ( call : Call , e : IOException ) { e . printStackTrace () } override fun onResponse ( call : Call , response : Response ) { response . use { if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) for (( name , value ) in response . headers ) { println ( \"$name: $value\" ) } println ( response . body !! . string ()) } } }) } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://publicobject.com/helloworld.txt\" ) . build (); client . newCall ( request ). enqueue ( new Callback () { @Override public void onFailure ( Call call , IOException e ) { e . printStackTrace (); } @Override public void onResponse ( Call call , Response response ) throws IOException { try ( ResponseBody responseBody = response . body ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); Headers responseHeaders = response . headers (); for ( int i = 0 , size = responseHeaders . size (); i < size ; i ++ ) { System . out . println ( responseHeaders . name ( i ) + \": \" + responseHeaders . value ( i )); } System . out . println ( responseBody . string ()); } } }); } Accessing Headers ( .kt , .java ) \u00b6 Typically HTTP headers work like a Map<String, String> : each field has one value or none. But some headers permit multiple values, like Guava\u2019s Multimap . For example, it\u2019s legal and common for an HTTP response to supply multiple Vary headers. OkHttp\u2019s APIs attempt to make both cases comfortable. When writing request headers, use header(name, value) to set the only occurrence of name to value . If there are existing values, they will be removed before the new value is added. Use addHeader(name, value) to add a header without removing the headers already present. When reading response a header, use header(name) to return the last occurrence of the named value. Usually this is also the only occurrence! If no value is present, header(name) will return null. To read all of a field\u2019s values as a list, use headers(name) . To visit all headers, use the Headers class which supports access by index. Kotlin private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"https://api.github.com/repos/square/okhttp/issues\" ) . header ( \"User-Agent\" , \"OkHttp Headers.java\" ) . addHeader ( \"Accept\" , \"application/json; q=0.5\" ) . addHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( \"Server: ${response.header(\" Server \")}\" ) println ( \"Date: ${response.header(\" Date \")}\" ) println ( \"Vary: ${response.headers(\" Vary \")}\" ) } } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://api.github.com/repos/square/okhttp/issues\" ) . header ( \"User-Agent\" , \"OkHttp Headers.java\" ) . addHeader ( \"Accept\" , \"application/json; q=0.5\" ) . addHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( \"Server: \" + response . header ( \"Server\" )); System . out . println ( \"Date: \" + response . header ( \"Date\" )); System . out . println ( \"Vary: \" + response . headers ( \"Vary\" )); } } Posting a String ( .kt , .java ) \u00b6 Use an HTTP POST to send a request body to a service. This example posts a markdown document to a web service that renders markdown as HTML. Because the entire request body is in memory simultaneously, avoid posting large (greater than 1 MiB) documents using this API. Kotlin private val client = OkHttpClient () fun run () { val postBody = \"\"\" |Releases |-------- | | * _1.0_ May 6, 2013 | * _1.1_ June 15, 2013 | * _1.2_ August 11, 2013 |\"\"\" . trimMargin () val request = Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( postBody . toRequestBody ( MEDIA_TYPE_MARKDOWN )) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } companion object { val MEDIA_TYPE_MARKDOWN = \"text/x-markdown; charset=utf-8\" . toMediaType () } Java public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType . parse ( \"text/x-markdown; charset=utf-8\" ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { String postBody = \"\" + \"Releases\\n\" + \"--------\\n\" + \"\\n\" + \" * _1.0_ May 6, 2013\\n\" + \" * _1.1_ June 15, 2013\\n\" + \" * _1.2_ August 11, 2013\\n\" ; Request request = new Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( RequestBody . create ( MEDIA_TYPE_MARKDOWN , postBody )) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } } Post Streaming ( .kt , .java ) \u00b6 Here we POST a request body as a stream. The content of this request body is being generated as it\u2019s being written. This example streams directly into the Okio buffered sink. Your programs may prefer an OutputStream , which you can get from BufferedSink.outputStream() . Kotlin private val client = OkHttpClient () fun run () { val requestBody = object : RequestBody () { override fun contentType () = MEDIA_TYPE_MARKDOWN override fun writeTo ( sink : BufferedSink ) { sink . writeUtf8 ( \"Numbers\\n\" ) sink . writeUtf8 ( \"-------\\n\" ) for ( i in 2. . 997 ) { sink . writeUtf8 ( String . format ( \" * $i = ${factor(i)}\\n\" )) } } private fun factor ( n : Int ): String { for ( i in 2 until n ) { val x = n / i if ( x * i == n ) return \"${factor(x)} \u00d7 $i\" } return n . toString () } } val request = Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( requestBody ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } companion object { val MEDIA_TYPE_MARKDOWN = \"text/x-markdown; charset=utf-8\" . toMediaType () } Java public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType . parse ( \"text/x-markdown; charset=utf-8\" ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { RequestBody requestBody = new RequestBody () { @Override public MediaType contentType () { return MEDIA_TYPE_MARKDOWN ; } @Override public void writeTo ( BufferedSink sink ) throws IOException { sink . writeUtf8 ( \"Numbers\\n\" ); sink . writeUtf8 ( \"-------\\n\" ); for ( int i = 2 ; i <= 997 ; i ++ ) { sink . writeUtf8 ( String . format ( \" * %s = %s\\n\" , i , factor ( i ))); } } private String factor ( int n ) { for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( x * i == n ) return factor ( x ) + \" \u00d7 \" + i ; } return Integer . toString ( n ); } }; Request request = new Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( requestBody ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } } Posting a File ( .kt , .java ) \u00b6 It\u2019s easy to use a file as a request body. Kotlin private val client = OkHttpClient () fun run () { val file = File ( \"README.md\" ) val request = Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( file . asRequestBody ( MEDIA_TYPE_MARKDOWN )) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } companion object { val MEDIA_TYPE_MARKDOWN = \"text/x-markdown; charset=utf-8\" . toMediaType () } Java public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType . parse ( \"text/x-markdown; charset=utf-8\" ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { File file = new File ( \"README.md\" ); Request request = new Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( RequestBody . create ( MEDIA_TYPE_MARKDOWN , file )) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } } Posting form parameters ( .kt , .java ) \u00b6 Use FormBody.Builder to build a request body that works like an HTML <form> tag. Names and values will be encoded using an HTML-compatible form URL encoding. Kotlin private val client = OkHttpClient () fun run () { val formBody = FormBody . Builder () . add ( \"search\" , \"Jurassic Park\" ) . build () val request = Request . Builder () . url ( \"https://en.wikipedia.org/w/index.php\" ) . post ( formBody ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { RequestBody formBody = new FormBody . Builder () . add ( \"search\" , \"Jurassic Park\" ) . build (); Request request = new Request . Builder () . url ( \"https://en.wikipedia.org/w/index.php\" ) . post ( formBody ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } } Posting a multipart request ( .kt , .java ) \u00b6 MultipartBody.Builder can build sophisticated request bodies compatible with HTML file upload forms. Each part of a multipart request body is itself a request body, and can define its own headers. If present, these headers should describe the part body, such as its Content-Disposition . The Content-Length and Content-Type headers are added automatically if they\u2019re available. Kotlin private val client = OkHttpClient () fun run () { // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image val requestBody = MultipartBody . Builder () . setType ( MultipartBody . FORM ) . addFormDataPart ( \"title\" , \"Square Logo\" ) . addFormDataPart ( \"image\" , \"logo-square.png\" , File ( \"docs/images/logo-square.png\" ). asRequestBody ( MEDIA_TYPE_PNG )) . build () val request = Request . Builder () . header ( \"Authorization\" , \"Client-ID $IMGUR_CLIENT_ID\" ) . url ( \"https://api.imgur.com/3/image\" ) . post ( requestBody ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } companion object { /** * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running * these examples, please request your own client ID! https://api.imgur.com/oauth2 */ private val IMGUR_CLIENT_ID = \"9199fdef135c122\" private val MEDIA_TYPE_PNG = \"image/png\" . toMediaType () } Java /** * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running * these examples, please request your own client ID! https://api.imgur.com/oauth2 */ private static final String IMGUR_CLIENT_ID = \"...\" ; private static final MediaType MEDIA_TYPE_PNG = MediaType . parse ( \"image/png\" ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBody . Builder () . setType ( MultipartBody . FORM ) . addFormDataPart ( \"title\" , \"Square Logo\" ) . addFormDataPart ( \"image\" , \"logo-square.png\" , RequestBody . create ( MEDIA_TYPE_PNG , new File ( \"website/static/logo-square.png\" ))) . build (); Request request = new Request . Builder () . header ( \"Authorization\" , \"Client-ID \" + IMGUR_CLIENT_ID ) . url ( \"https://api.imgur.com/3/image\" ) . post ( requestBody ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } } Parse a JSON Response With Moshi ( .kt , .java ) \u00b6 Moshi is a handy API for converting between JSON and Java objects. Here we\u2019re using it to decode a JSON response from a GitHub API. Note that ResponseBody.charStream() uses the Content-Type response header to select which charset to use when decoding the response body. It defaults to UTF-8 if no charset is specified. Kotlin private val client = OkHttpClient () private val moshi = Moshi . Builder (). build () private val gistJsonAdapter = moshi . adapter ( Gist :: class . java ) fun run () { val request = Request . Builder () . url ( \"https://api.github.com/gists/c2a7c39532239ff261be\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) val gist = gistJsonAdapter . fromJson ( response . body !! . source ()) for (( key , value ) in gist !! . files !! ) { println ( key ) println ( value . content ) } } } @JsonClass ( generateAdapter = true ) data class Gist ( var files : Map < String , GistFile >?) @JsonClass ( generateAdapter = true ) data class GistFile ( var content : String ?) Java private final OkHttpClient client = new OkHttpClient (); private final Moshi moshi = new Moshi . Builder (). build (); private final JsonAdapter < Gist > gistJsonAdapter = moshi . adapter ( Gist . class ); public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://api.github.com/gists/c2a7c39532239ff261be\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); Gist gist = gistJsonAdapter . fromJson ( response . body (). source ()); for ( Map . Entry < String , GistFile > entry : gist . files . entrySet ()) { System . out . println ( entry . getKey ()); System . out . println ( entry . getValue (). content ); } } } static class Gist { Map < String , GistFile > files ; } static class GistFile { String content ; } Response Caching ( .kt , .java ) \u00b6 To cache responses, you\u2019ll need a cache directory that you can read and write to, and a limit on the cache\u2019s size. The cache directory should be private, and untrusted applications should not be able to read its contents! It is an error to have multiple caches accessing the same cache directory simultaneously. Most applications should call new OkHttpClient() exactly once, configure it with their cache, and use that same instance everywhere. Otherwise the two cache instances will stomp on each other, corrupt the response cache, and possibly crash your program. Response caching uses HTTP headers for all configuration. You can add request headers like Cache-Control: max-stale=3600 and OkHttp\u2019s cache will honor them. Your webserver configures how long responses are cached with its own response headers, like Cache-Control: max-age=9600 . There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET. Kotlin private val client : OkHttpClient = OkHttpClient . Builder () . cache ( Cache ( directory = cacheDirectory , maxSize = 10L * 1024L * 1024L // 10 MiB )) . build () fun run () { val request = Request . Builder () . url ( \"http://publicobject.com/helloworld.txt\" ) . build () val response1Body = client . newCall ( request ). execute (). use { if (! it . isSuccessful ) throw IOException ( \"Unexpected code $it\" ) println ( \"Response 1 response: $it\" ) println ( \"Response 1 cache response: ${it.cacheResponse}\" ) println ( \"Response 1 network response: ${it.networkResponse}\" ) return @use it . body !! . string () } val response2Body = client . newCall ( request ). execute (). use { if (! it . isSuccessful ) throw IOException ( \"Unexpected code $it\" ) println ( \"Response 2 response: $it\" ) println ( \"Response 2 cache response: ${it.cacheResponse}\" ) println ( \"Response 2 network response: ${it.networkResponse}\" ) return @use it . body !! . string () } println ( \"Response 2 equals Response 1? \" + ( response1Body == response2Body )) } Java private final OkHttpClient client ; public CacheResponse ( File cacheDirectory ) throws Exception { int cacheSize = 10 * 1024 * 1024 ; // 10 MiB Cache cache = new Cache ( cacheDirectory , cacheSize ); client = new OkHttpClient . Builder () . cache ( cache ) . build (); } public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://publicobject.com/helloworld.txt\" ) . build (); String response1Body ; try ( Response response1 = client . newCall ( request ). execute ()) { if ( ! response1 . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response1 ); response1Body = response1 . body (). string (); System . out . println ( \"Response 1 response: \" + response1 ); System . out . println ( \"Response 1 cache response: \" + response1 . cacheResponse ()); System . out . println ( \"Response 1 network response: \" + response1 . networkResponse ()); } String response2Body ; try ( Response response2 = client . newCall ( request ). execute ()) { if ( ! response2 . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response2 ); response2Body = response2 . body (). string (); System . out . println ( \"Response 2 response: \" + response2 ); System . out . println ( \"Response 2 cache response: \" + response2 . cacheResponse ()); System . out . println ( \"Response 2 network response: \" + response2 . networkResponse ()); } System . out . println ( \"Response 2 equals Response 1? \" + response1Body . equals ( response2Body )); } To prevent a response from using the cache, use CacheControl.FORCE_NETWORK . To prevent it from using the network, use CacheControl.FORCE_CACHE . Be warned: if you use FORCE_CACHE and the response requires the network, OkHttp will return a 504 Unsatisfiable Request response. Canceling a Call ( .kt , .java ) \u00b6 Use Call.cancel() to stop an ongoing call immediately. If a thread is currently writing a request or reading a response, it will receive an IOException . Use this to conserve the network when a call is no longer necessary; for example when your user navigates away from an application. Both synchronous and asynchronous calls can be canceled. Kotlin private val executor = Executors . newScheduledThreadPool ( 1 ) private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"http://httpbin.org/delay/2\" ) // This URL is served with a 2 second delay. . build () val startNanos = System . nanoTime () val call = client . newCall ( request ) // Schedule a job to cancel the call in 1 second. executor . schedule ({ System . out . printf ( \"%.2f Canceling call.%n\" , ( System . nanoTime () - startNanos ) / 1 e9f ) call . cancel () System . out . printf ( \"%.2f Canceled call.%n\" , ( System . nanoTime () - startNanos ) / 1 e9f ) }, 1 , TimeUnit . SECONDS ) System . out . printf ( \"%.2f Executing call.%n\" , ( System . nanoTime () - startNanos ) / 1 e9f ) try { call . execute (). use { response -> System . out . printf ( \"%.2f Call was expected to fail, but completed: %s%n\" , ( System . nanoTime () - startNanos ) / 1 e9f , response ) } } catch ( e : IOException ) { System . out . printf ( \"%.2f Call failed as expected: %s%n\" , ( System . nanoTime () - startNanos ) / 1 e9f , e ) } } Java private final ScheduledExecutorService executor = Executors . newScheduledThreadPool ( 1 ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://httpbin.org/delay/2\" ) // This URL is served with a 2 second delay. . build (); final long startNanos = System . nanoTime (); final Call call = client . newCall ( request ); // Schedule a job to cancel the call in 1 second. executor . schedule ( new Runnable () { @Override public void run () { System . out . printf ( \"%.2f Canceling call.%n\" , ( System . nanoTime () - startNanos ) / 1e9f ); call . cancel (); System . out . printf ( \"%.2f Canceled call.%n\" , ( System . nanoTime () - startNanos ) / 1e9f ); } }, 1 , TimeUnit . SECONDS ); System . out . printf ( \"%.2f Executing call.%n\" , ( System . nanoTime () - startNanos ) / 1e9f ); try ( Response response = call . execute ()) { System . out . printf ( \"%.2f Call was expected to fail, but completed: %s%n\" , ( System . nanoTime () - startNanos ) / 1e9f , response ); } catch ( IOException e ) { System . out . printf ( \"%.2f Call failed as expected: %s%n\" , ( System . nanoTime () - startNanos ) / 1e9f , e ); } } Timeouts ( .kt , .java ) \u00b6 Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, write, read, and full call timeouts. Kotlin private val client : OkHttpClient = OkHttpClient . Builder () . connectTimeout ( 5 , TimeUnit . SECONDS ) . writeTimeout ( 5 , TimeUnit . SECONDS ) . readTimeout ( 5 , TimeUnit . SECONDS ) . callTimeout ( 10 , TimeUnit . SECONDS ) . build () fun run () { val request = Request . Builder () . url ( \"http://httpbin.org/delay/2\" ) // This URL is served with a 2 second delay. . build () client . newCall ( request ). execute (). use { response -> println ( \"Response completed: $response\" ) } } Java private final OkHttpClient client ; public ConfigureTimeouts () throws Exception { client = new OkHttpClient . Builder () . connectTimeout ( 10 , TimeUnit . SECONDS ) . writeTimeout ( 10 , TimeUnit . SECONDS ) . readTimeout ( 30 , TimeUnit . SECONDS ) . build (); } public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://httpbin.org/delay/2\" ) // This URL is served with a 2 second delay. . build (); try ( Response response = client . newCall ( request ). execute ()) { System . out . println ( \"Response completed: \" + response ); } } Per-call Configuration ( .kt , .java ) \u00b6 All the HTTP client configuration lives in OkHttpClient including proxy settings, timeouts, and caches. When you need to change the configuration of a single call, call OkHttpClient.newBuilder() . This returns a builder that shares the same connection pool, dispatcher, and configuration with the original client. In the example below, we make one request with a 500 ms timeout and another with a 3000 ms timeout. Kotlin private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"http://httpbin.org/delay/1\" ) // This URL is served with a 1 second delay. . build () // Copy to customize OkHttp for this request. val client1 = client . newBuilder () . readTimeout ( 500 , TimeUnit . MILLISECONDS ) . build () try { client1 . newCall ( request ). execute (). use { response -> println ( \"Response 1 succeeded: $response\" ) } } catch ( e : IOException ) { println ( \"Response 1 failed: $e\" ) } // Copy to customize OkHttp for this request. val client2 = client . newBuilder () . readTimeout ( 3000 , TimeUnit . MILLISECONDS ) . build () try { client2 . newCall ( request ). execute (). use { response -> println ( \"Response 2 succeeded: $response\" ) } } catch ( e : IOException ) { println ( \"Response 2 failed: $e\" ) } } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://httpbin.org/delay/1\" ) // This URL is served with a 1 second delay. . build (); // Copy to customize OkHttp for this request. OkHttpClient client1 = client . newBuilder () . readTimeout ( 500 , TimeUnit . MILLISECONDS ) . build (); try ( Response response = client1 . newCall ( request ). execute ()) { System . out . println ( \"Response 1 succeeded: \" + response ); } catch ( IOException e ) { System . out . println ( \"Response 1 failed: \" + e ); } // Copy to customize OkHttp for this request. OkHttpClient client2 = client . newBuilder () . readTimeout ( 3000 , TimeUnit . MILLISECONDS ) . build (); try ( Response response = client2 . newCall ( request ). execute ()) { System . out . println ( \"Response 2 succeeded: \" + response ); } catch ( IOException e ) { System . out . println ( \"Response 2 failed: \" + e ); } } Handling authentication ( .kt , .java ) \u00b6 OkHttp can automatically retry unauthenticated requests. When a response is 401 Not Authorized , an Authenticator is asked to supply credentials. Implementations should build a new request that includes the missing credentials. If no credentials are available, return null to skip the retry. Use Response.challenges() to get the schemes and realms of any authentication challenges. When fulfilling a Basic challenge, use Credentials.basic(username, password) to encode the request header. Kotlin private val client = OkHttpClient . Builder () . authenticator ( object : Authenticator { @Throws ( IOException :: class ) override fun authenticate ( route : Route ?, response : Response ): Request ? { if ( response . request . header ( \"Authorization\" ) != null ) { return null // Give up, we've already attempted to authenticate. } println ( \"Authenticating for response: $response\" ) println ( \"Challenges: ${response.challenges()}\" ) val credential = Credentials . basic ( \"jesse\" , \"password1\" ) return response . request . newBuilder () . header ( \"Authorization\" , credential ) . build () } }) . build () fun run () { val request = Request . Builder () . url ( \"http://publicobject.com/secrets/hellosecret.txt\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } Java private final OkHttpClient client ; public Authenticate () { client = new OkHttpClient . Builder () . authenticator ( new Authenticator () { @Override public Request authenticate ( Route route , Response response ) throws IOException { if ( response . request (). header ( \"Authorization\" ) != null ) { return null ; // Give up, we've already attempted to authenticate. } System . out . println ( \"Authenticating for response: \" + response ); System . out . println ( \"Challenges: \" + response . challenges ()); String credential = Credentials . basic ( \"jesse\" , \"password1\" ); return response . request (). newBuilder () . header ( \"Authorization\" , credential ) . build (); } }) . build (); } public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://publicobject.com/secrets/hellosecret.txt\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } } To avoid making many retries when authentication isn\u2019t working, you can return null to give up. For example, you may want to skip the retry when these exact credentials have already been attempted: if ( credential . equals ( response . request (). header ( \"Authorization\" ))) { return null ; // If we already failed with these credentials, don't retry. } You may also skip the retry when you\u2019ve hit an application-defined attempt limit: if ( responseCount ( response ) >= 3 ) { return null ; // If we've failed 3 times, give up. } This above code relies on this responseCount() method: private int responseCount ( Response response ) { int result = 1 ; while (( response = response . priorResponse ()) != null ) { result ++ ; } return result ; }","title":"Recipes"},{"location":"recipes/#recipes","text":"We\u2019ve written some recipes that demonstrate how to solve common problems with OkHttp. Read through them to learn about how everything works together. Cut-and-paste these examples freely; that\u2019s what they\u2019re for.","title":"Recipes"},{"location":"recipes/#synchronous-get-kt-java","text":"Download a file, print its headers, and print its response body as a string. The string() method on response body is convenient and efficient for small documents. But if the response body is large (greater than 1 MiB), avoid string() because it will load the entire document into memory. In that case, prefer to process the body as a stream. Kotlin private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) for (( name , value ) in response . headers ) { println ( \"$name: $value\" ) } println ( response . body !! . string ()) } } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://publicobject.com/helloworld.txt\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); Headers responseHeaders = response . headers (); for ( int i = 0 ; i < responseHeaders . size (); i ++ ) { System . out . println ( responseHeaders . name ( i ) + \": \" + responseHeaders . value ( i )); } System . out . println ( response . body (). string ()); } }","title":"Synchronous Get (.kt, .java)"},{"location":"recipes/#asynchronous-get-kt-java","text":"Download a file on a worker thread, and get called back when the response is readable. The callback is made after the response headers are ready. Reading the response body may still block. OkHttp doesn\u2019t currently offer asynchronous APIs to receive a response body in parts. Kotlin private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"http://publicobject.com/helloworld.txt\" ) . build () client . newCall ( request ). enqueue ( object : Callback { override fun onFailure ( call : Call , e : IOException ) { e . printStackTrace () } override fun onResponse ( call : Call , response : Response ) { response . use { if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) for (( name , value ) in response . headers ) { println ( \"$name: $value\" ) } println ( response . body !! . string ()) } } }) } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://publicobject.com/helloworld.txt\" ) . build (); client . newCall ( request ). enqueue ( new Callback () { @Override public void onFailure ( Call call , IOException e ) { e . printStackTrace (); } @Override public void onResponse ( Call call , Response response ) throws IOException { try ( ResponseBody responseBody = response . body ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); Headers responseHeaders = response . headers (); for ( int i = 0 , size = responseHeaders . size (); i < size ; i ++ ) { System . out . println ( responseHeaders . name ( i ) + \": \" + responseHeaders . value ( i )); } System . out . println ( responseBody . string ()); } } }); }","title":"Asynchronous Get (.kt, .java)"},{"location":"recipes/#accessing-headers-kt-java","text":"Typically HTTP headers work like a Map<String, String> : each field has one value or none. But some headers permit multiple values, like Guava\u2019s Multimap . For example, it\u2019s legal and common for an HTTP response to supply multiple Vary headers. OkHttp\u2019s APIs attempt to make both cases comfortable. When writing request headers, use header(name, value) to set the only occurrence of name to value . If there are existing values, they will be removed before the new value is added. Use addHeader(name, value) to add a header without removing the headers already present. When reading response a header, use header(name) to return the last occurrence of the named value. Usually this is also the only occurrence! If no value is present, header(name) will return null. To read all of a field\u2019s values as a list, use headers(name) . To visit all headers, use the Headers class which supports access by index. Kotlin private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"https://api.github.com/repos/square/okhttp/issues\" ) . header ( \"User-Agent\" , \"OkHttp Headers.java\" ) . addHeader ( \"Accept\" , \"application/json; q=0.5\" ) . addHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( \"Server: ${response.header(\" Server \")}\" ) println ( \"Date: ${response.header(\" Date \")}\" ) println ( \"Vary: ${response.headers(\" Vary \")}\" ) } } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://api.github.com/repos/square/okhttp/issues\" ) . header ( \"User-Agent\" , \"OkHttp Headers.java\" ) . addHeader ( \"Accept\" , \"application/json; q=0.5\" ) . addHeader ( \"Accept\" , \"application/vnd.github.v3+json\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( \"Server: \" + response . header ( \"Server\" )); System . out . println ( \"Date: \" + response . header ( \"Date\" )); System . out . println ( \"Vary: \" + response . headers ( \"Vary\" )); } }","title":"Accessing Headers (.kt, .java)"},{"location":"recipes/#posting-a-string-kt-java","text":"Use an HTTP POST to send a request body to a service. This example posts a markdown document to a web service that renders markdown as HTML. Because the entire request body is in memory simultaneously, avoid posting large (greater than 1 MiB) documents using this API. Kotlin private val client = OkHttpClient () fun run () { val postBody = \"\"\" |Releases |-------- | | * _1.0_ May 6, 2013 | * _1.1_ June 15, 2013 | * _1.2_ August 11, 2013 |\"\"\" . trimMargin () val request = Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( postBody . toRequestBody ( MEDIA_TYPE_MARKDOWN )) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } companion object { val MEDIA_TYPE_MARKDOWN = \"text/x-markdown; charset=utf-8\" . toMediaType () } Java public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType . parse ( \"text/x-markdown; charset=utf-8\" ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { String postBody = \"\" + \"Releases\\n\" + \"--------\\n\" + \"\\n\" + \" * _1.0_ May 6, 2013\\n\" + \" * _1.1_ June 15, 2013\\n\" + \" * _1.2_ August 11, 2013\\n\" ; Request request = new Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( RequestBody . create ( MEDIA_TYPE_MARKDOWN , postBody )) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } }","title":"Posting a String (.kt, .java)"},{"location":"recipes/#post-streaming-kt-java","text":"Here we POST a request body as a stream. The content of this request body is being generated as it\u2019s being written. This example streams directly into the Okio buffered sink. Your programs may prefer an OutputStream , which you can get from BufferedSink.outputStream() . Kotlin private val client = OkHttpClient () fun run () { val requestBody = object : RequestBody () { override fun contentType () = MEDIA_TYPE_MARKDOWN override fun writeTo ( sink : BufferedSink ) { sink . writeUtf8 ( \"Numbers\\n\" ) sink . writeUtf8 ( \"-------\\n\" ) for ( i in 2. . 997 ) { sink . writeUtf8 ( String . format ( \" * $i = ${factor(i)}\\n\" )) } } private fun factor ( n : Int ): String { for ( i in 2 until n ) { val x = n / i if ( x * i == n ) return \"${factor(x)} \u00d7 $i\" } return n . toString () } } val request = Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( requestBody ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } companion object { val MEDIA_TYPE_MARKDOWN = \"text/x-markdown; charset=utf-8\" . toMediaType () } Java public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType . parse ( \"text/x-markdown; charset=utf-8\" ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { RequestBody requestBody = new RequestBody () { @Override public MediaType contentType () { return MEDIA_TYPE_MARKDOWN ; } @Override public void writeTo ( BufferedSink sink ) throws IOException { sink . writeUtf8 ( \"Numbers\\n\" ); sink . writeUtf8 ( \"-------\\n\" ); for ( int i = 2 ; i <= 997 ; i ++ ) { sink . writeUtf8 ( String . format ( \" * %s = %s\\n\" , i , factor ( i ))); } } private String factor ( int n ) { for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( x * i == n ) return factor ( x ) + \" \u00d7 \" + i ; } return Integer . toString ( n ); } }; Request request = new Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( requestBody ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } }","title":"Post Streaming (.kt, .java)"},{"location":"recipes/#posting-a-file-kt-java","text":"It\u2019s easy to use a file as a request body. Kotlin private val client = OkHttpClient () fun run () { val file = File ( \"README.md\" ) val request = Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( file . asRequestBody ( MEDIA_TYPE_MARKDOWN )) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } companion object { val MEDIA_TYPE_MARKDOWN = \"text/x-markdown; charset=utf-8\" . toMediaType () } Java public static final MediaType MEDIA_TYPE_MARKDOWN = MediaType . parse ( \"text/x-markdown; charset=utf-8\" ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { File file = new File ( \"README.md\" ); Request request = new Request . Builder () . url ( \"https://api.github.com/markdown/raw\" ) . post ( RequestBody . create ( MEDIA_TYPE_MARKDOWN , file )) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } }","title":"Posting a File (.kt, .java)"},{"location":"recipes/#posting-form-parameters-kt-java","text":"Use FormBody.Builder to build a request body that works like an HTML <form> tag. Names and values will be encoded using an HTML-compatible form URL encoding. Kotlin private val client = OkHttpClient () fun run () { val formBody = FormBody . Builder () . add ( \"search\" , \"Jurassic Park\" ) . build () val request = Request . Builder () . url ( \"https://en.wikipedia.org/w/index.php\" ) . post ( formBody ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { RequestBody formBody = new FormBody . Builder () . add ( \"search\" , \"Jurassic Park\" ) . build (); Request request = new Request . Builder () . url ( \"https://en.wikipedia.org/w/index.php\" ) . post ( formBody ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } }","title":"Posting form parameters (.kt, .java)"},{"location":"recipes/#posting-a-multipart-request-kt-java","text":"MultipartBody.Builder can build sophisticated request bodies compatible with HTML file upload forms. Each part of a multipart request body is itself a request body, and can define its own headers. If present, these headers should describe the part body, such as its Content-Disposition . The Content-Length and Content-Type headers are added automatically if they\u2019re available. Kotlin private val client = OkHttpClient () fun run () { // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image val requestBody = MultipartBody . Builder () . setType ( MultipartBody . FORM ) . addFormDataPart ( \"title\" , \"Square Logo\" ) . addFormDataPart ( \"image\" , \"logo-square.png\" , File ( \"docs/images/logo-square.png\" ). asRequestBody ( MEDIA_TYPE_PNG )) . build () val request = Request . Builder () . header ( \"Authorization\" , \"Client-ID $IMGUR_CLIENT_ID\" ) . url ( \"https://api.imgur.com/3/image\" ) . post ( requestBody ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } companion object { /** * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running * these examples, please request your own client ID! https://api.imgur.com/oauth2 */ private val IMGUR_CLIENT_ID = \"9199fdef135c122\" private val MEDIA_TYPE_PNG = \"image/png\" . toMediaType () } Java /** * The imgur client ID for OkHttp recipes. If you're using imgur for anything other than running * these examples, please request your own client ID! https://api.imgur.com/oauth2 */ private static final String IMGUR_CLIENT_ID = \"...\" ; private static final MediaType MEDIA_TYPE_PNG = MediaType . parse ( \"image/png\" ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { // Use the imgur image upload API as documented at https://api.imgur.com/endpoints/image RequestBody requestBody = new MultipartBody . Builder () . setType ( MultipartBody . FORM ) . addFormDataPart ( \"title\" , \"Square Logo\" ) . addFormDataPart ( \"image\" , \"logo-square.png\" , RequestBody . create ( MEDIA_TYPE_PNG , new File ( \"website/static/logo-square.png\" ))) . build (); Request request = new Request . Builder () . header ( \"Authorization\" , \"Client-ID \" + IMGUR_CLIENT_ID ) . url ( \"https://api.imgur.com/3/image\" ) . post ( requestBody ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } }","title":"Posting a multipart request (.kt, .java)"},{"location":"recipes/#parse-a-json-response-with-moshi-kt-java","text":"Moshi is a handy API for converting between JSON and Java objects. Here we\u2019re using it to decode a JSON response from a GitHub API. Note that ResponseBody.charStream() uses the Content-Type response header to select which charset to use when decoding the response body. It defaults to UTF-8 if no charset is specified. Kotlin private val client = OkHttpClient () private val moshi = Moshi . Builder (). build () private val gistJsonAdapter = moshi . adapter ( Gist :: class . java ) fun run () { val request = Request . Builder () . url ( \"https://api.github.com/gists/c2a7c39532239ff261be\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) val gist = gistJsonAdapter . fromJson ( response . body !! . source ()) for (( key , value ) in gist !! . files !! ) { println ( key ) println ( value . content ) } } } @JsonClass ( generateAdapter = true ) data class Gist ( var files : Map < String , GistFile >?) @JsonClass ( generateAdapter = true ) data class GistFile ( var content : String ?) Java private final OkHttpClient client = new OkHttpClient (); private final Moshi moshi = new Moshi . Builder (). build (); private final JsonAdapter < Gist > gistJsonAdapter = moshi . adapter ( Gist . class ); public void run () throws Exception { Request request = new Request . Builder () . url ( \"https://api.github.com/gists/c2a7c39532239ff261be\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); Gist gist = gistJsonAdapter . fromJson ( response . body (). source ()); for ( Map . Entry < String , GistFile > entry : gist . files . entrySet ()) { System . out . println ( entry . getKey ()); System . out . println ( entry . getValue (). content ); } } } static class Gist { Map < String , GistFile > files ; } static class GistFile { String content ; }","title":"Parse a JSON Response With Moshi (.kt, .java)"},{"location":"recipes/#response-caching-kt-java","text":"To cache responses, you\u2019ll need a cache directory that you can read and write to, and a limit on the cache\u2019s size. The cache directory should be private, and untrusted applications should not be able to read its contents! It is an error to have multiple caches accessing the same cache directory simultaneously. Most applications should call new OkHttpClient() exactly once, configure it with their cache, and use that same instance everywhere. Otherwise the two cache instances will stomp on each other, corrupt the response cache, and possibly crash your program. Response caching uses HTTP headers for all configuration. You can add request headers like Cache-Control: max-stale=3600 and OkHttp\u2019s cache will honor them. Your webserver configures how long responses are cached with its own response headers, like Cache-Control: max-age=9600 . There are cache headers to force a cached response, force a network response, or force the network response to be validated with a conditional GET. Kotlin private val client : OkHttpClient = OkHttpClient . Builder () . cache ( Cache ( directory = cacheDirectory , maxSize = 10L * 1024L * 1024L // 10 MiB )) . build () fun run () { val request = Request . Builder () . url ( \"http://publicobject.com/helloworld.txt\" ) . build () val response1Body = client . newCall ( request ). execute (). use { if (! it . isSuccessful ) throw IOException ( \"Unexpected code $it\" ) println ( \"Response 1 response: $it\" ) println ( \"Response 1 cache response: ${it.cacheResponse}\" ) println ( \"Response 1 network response: ${it.networkResponse}\" ) return @use it . body !! . string () } val response2Body = client . newCall ( request ). execute (). use { if (! it . isSuccessful ) throw IOException ( \"Unexpected code $it\" ) println ( \"Response 2 response: $it\" ) println ( \"Response 2 cache response: ${it.cacheResponse}\" ) println ( \"Response 2 network response: ${it.networkResponse}\" ) return @use it . body !! . string () } println ( \"Response 2 equals Response 1? \" + ( response1Body == response2Body )) } Java private final OkHttpClient client ; public CacheResponse ( File cacheDirectory ) throws Exception { int cacheSize = 10 * 1024 * 1024 ; // 10 MiB Cache cache = new Cache ( cacheDirectory , cacheSize ); client = new OkHttpClient . Builder () . cache ( cache ) . build (); } public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://publicobject.com/helloworld.txt\" ) . build (); String response1Body ; try ( Response response1 = client . newCall ( request ). execute ()) { if ( ! response1 . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response1 ); response1Body = response1 . body (). string (); System . out . println ( \"Response 1 response: \" + response1 ); System . out . println ( \"Response 1 cache response: \" + response1 . cacheResponse ()); System . out . println ( \"Response 1 network response: \" + response1 . networkResponse ()); } String response2Body ; try ( Response response2 = client . newCall ( request ). execute ()) { if ( ! response2 . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response2 ); response2Body = response2 . body (). string (); System . out . println ( \"Response 2 response: \" + response2 ); System . out . println ( \"Response 2 cache response: \" + response2 . cacheResponse ()); System . out . println ( \"Response 2 network response: \" + response2 . networkResponse ()); } System . out . println ( \"Response 2 equals Response 1? \" + response1Body . equals ( response2Body )); } To prevent a response from using the cache, use CacheControl.FORCE_NETWORK . To prevent it from using the network, use CacheControl.FORCE_CACHE . Be warned: if you use FORCE_CACHE and the response requires the network, OkHttp will return a 504 Unsatisfiable Request response.","title":"Response Caching (.kt, .java)"},{"location":"recipes/#canceling-a-call-kt-java","text":"Use Call.cancel() to stop an ongoing call immediately. If a thread is currently writing a request or reading a response, it will receive an IOException . Use this to conserve the network when a call is no longer necessary; for example when your user navigates away from an application. Both synchronous and asynchronous calls can be canceled. Kotlin private val executor = Executors . newScheduledThreadPool ( 1 ) private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"http://httpbin.org/delay/2\" ) // This URL is served with a 2 second delay. . build () val startNanos = System . nanoTime () val call = client . newCall ( request ) // Schedule a job to cancel the call in 1 second. executor . schedule ({ System . out . printf ( \"%.2f Canceling call.%n\" , ( System . nanoTime () - startNanos ) / 1 e9f ) call . cancel () System . out . printf ( \"%.2f Canceled call.%n\" , ( System . nanoTime () - startNanos ) / 1 e9f ) }, 1 , TimeUnit . SECONDS ) System . out . printf ( \"%.2f Executing call.%n\" , ( System . nanoTime () - startNanos ) / 1 e9f ) try { call . execute (). use { response -> System . out . printf ( \"%.2f Call was expected to fail, but completed: %s%n\" , ( System . nanoTime () - startNanos ) / 1 e9f , response ) } } catch ( e : IOException ) { System . out . printf ( \"%.2f Call failed as expected: %s%n\" , ( System . nanoTime () - startNanos ) / 1 e9f , e ) } } Java private final ScheduledExecutorService executor = Executors . newScheduledThreadPool ( 1 ); private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://httpbin.org/delay/2\" ) // This URL is served with a 2 second delay. . build (); final long startNanos = System . nanoTime (); final Call call = client . newCall ( request ); // Schedule a job to cancel the call in 1 second. executor . schedule ( new Runnable () { @Override public void run () { System . out . printf ( \"%.2f Canceling call.%n\" , ( System . nanoTime () - startNanos ) / 1e9f ); call . cancel (); System . out . printf ( \"%.2f Canceled call.%n\" , ( System . nanoTime () - startNanos ) / 1e9f ); } }, 1 , TimeUnit . SECONDS ); System . out . printf ( \"%.2f Executing call.%n\" , ( System . nanoTime () - startNanos ) / 1e9f ); try ( Response response = call . execute ()) { System . out . printf ( \"%.2f Call was expected to fail, but completed: %s%n\" , ( System . nanoTime () - startNanos ) / 1e9f , response ); } catch ( IOException e ) { System . out . printf ( \"%.2f Call failed as expected: %s%n\" , ( System . nanoTime () - startNanos ) / 1e9f , e ); } }","title":"Canceling a Call (.kt, .java)"},{"location":"recipes/#timeouts-kt-java","text":"Use timeouts to fail a call when its peer is unreachable. Network partitions can be due to client connectivity problems, server availability problems, or anything between. OkHttp supports connect, write, read, and full call timeouts. Kotlin private val client : OkHttpClient = OkHttpClient . Builder () . connectTimeout ( 5 , TimeUnit . SECONDS ) . writeTimeout ( 5 , TimeUnit . SECONDS ) . readTimeout ( 5 , TimeUnit . SECONDS ) . callTimeout ( 10 , TimeUnit . SECONDS ) . build () fun run () { val request = Request . Builder () . url ( \"http://httpbin.org/delay/2\" ) // This URL is served with a 2 second delay. . build () client . newCall ( request ). execute (). use { response -> println ( \"Response completed: $response\" ) } } Java private final OkHttpClient client ; public ConfigureTimeouts () throws Exception { client = new OkHttpClient . Builder () . connectTimeout ( 10 , TimeUnit . SECONDS ) . writeTimeout ( 10 , TimeUnit . SECONDS ) . readTimeout ( 30 , TimeUnit . SECONDS ) . build (); } public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://httpbin.org/delay/2\" ) // This URL is served with a 2 second delay. . build (); try ( Response response = client . newCall ( request ). execute ()) { System . out . println ( \"Response completed: \" + response ); } }","title":"Timeouts (.kt, .java)"},{"location":"recipes/#per-call-configuration-kt-java","text":"All the HTTP client configuration lives in OkHttpClient including proxy settings, timeouts, and caches. When you need to change the configuration of a single call, call OkHttpClient.newBuilder() . This returns a builder that shares the same connection pool, dispatcher, and configuration with the original client. In the example below, we make one request with a 500 ms timeout and another with a 3000 ms timeout. Kotlin private val client = OkHttpClient () fun run () { val request = Request . Builder () . url ( \"http://httpbin.org/delay/1\" ) // This URL is served with a 1 second delay. . build () // Copy to customize OkHttp for this request. val client1 = client . newBuilder () . readTimeout ( 500 , TimeUnit . MILLISECONDS ) . build () try { client1 . newCall ( request ). execute (). use { response -> println ( \"Response 1 succeeded: $response\" ) } } catch ( e : IOException ) { println ( \"Response 1 failed: $e\" ) } // Copy to customize OkHttp for this request. val client2 = client . newBuilder () . readTimeout ( 3000 , TimeUnit . MILLISECONDS ) . build () try { client2 . newCall ( request ). execute (). use { response -> println ( \"Response 2 succeeded: $response\" ) } } catch ( e : IOException ) { println ( \"Response 2 failed: $e\" ) } } Java private final OkHttpClient client = new OkHttpClient (); public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://httpbin.org/delay/1\" ) // This URL is served with a 1 second delay. . build (); // Copy to customize OkHttp for this request. OkHttpClient client1 = client . newBuilder () . readTimeout ( 500 , TimeUnit . MILLISECONDS ) . build (); try ( Response response = client1 . newCall ( request ). execute ()) { System . out . println ( \"Response 1 succeeded: \" + response ); } catch ( IOException e ) { System . out . println ( \"Response 1 failed: \" + e ); } // Copy to customize OkHttp for this request. OkHttpClient client2 = client . newBuilder () . readTimeout ( 3000 , TimeUnit . MILLISECONDS ) . build (); try ( Response response = client2 . newCall ( request ). execute ()) { System . out . println ( \"Response 2 succeeded: \" + response ); } catch ( IOException e ) { System . out . println ( \"Response 2 failed: \" + e ); } }","title":"Per-call Configuration (.kt, .java)"},{"location":"recipes/#handling-authentication-kt-java","text":"OkHttp can automatically retry unauthenticated requests. When a response is 401 Not Authorized , an Authenticator is asked to supply credentials. Implementations should build a new request that includes the missing credentials. If no credentials are available, return null to skip the retry. Use Response.challenges() to get the schemes and realms of any authentication challenges. When fulfilling a Basic challenge, use Credentials.basic(username, password) to encode the request header. Kotlin private val client = OkHttpClient . Builder () . authenticator ( object : Authenticator { @Throws ( IOException :: class ) override fun authenticate ( route : Route ?, response : Response ): Request ? { if ( response . request . header ( \"Authorization\" ) != null ) { return null // Give up, we've already attempted to authenticate. } println ( \"Authenticating for response: $response\" ) println ( \"Challenges: ${response.challenges()}\" ) val credential = Credentials . basic ( \"jesse\" , \"password1\" ) return response . request . newBuilder () . header ( \"Authorization\" , credential ) . build () } }) . build () fun run () { val request = Request . Builder () . url ( \"http://publicobject.com/secrets/hellosecret.txt\" ) . build () client . newCall ( request ). execute (). use { response -> if (! response . isSuccessful ) throw IOException ( \"Unexpected code $response\" ) println ( response . body !! . string ()) } } Java private final OkHttpClient client ; public Authenticate () { client = new OkHttpClient . Builder () . authenticator ( new Authenticator () { @Override public Request authenticate ( Route route , Response response ) throws IOException { if ( response . request (). header ( \"Authorization\" ) != null ) { return null ; // Give up, we've already attempted to authenticate. } System . out . println ( \"Authenticating for response: \" + response ); System . out . println ( \"Challenges: \" + response . challenges ()); String credential = Credentials . basic ( \"jesse\" , \"password1\" ); return response . request (). newBuilder () . header ( \"Authorization\" , credential ) . build (); } }) . build (); } public void run () throws Exception { Request request = new Request . Builder () . url ( \"http://publicobject.com/secrets/hellosecret.txt\" ) . build (); try ( Response response = client . newCall ( request ). execute ()) { if ( ! response . isSuccessful ()) throw new IOException ( \"Unexpected code \" + response ); System . out . println ( response . body (). string ()); } } To avoid making many retries when authentication isn\u2019t working, you can return null to give up. For example, you may want to skip the retry when these exact credentials have already been attempted: if ( credential . equals ( response . request (). header ( \"Authorization\" ))) { return null ; // If we already failed with these credentials, don't retry. } You may also skip the retry when you\u2019ve hit an application-defined attempt limit: if ( responseCount ( response ) >= 3 ) { return null ; // If we've failed 3 times, give up. } This above code relies on this responseCount() method: private int responseCount ( Response response ) { int result = 1 ; while (( response = response . priorResponse ()) != null ) { result ++ ; } return result ; }","title":"Handling authentication (.kt, .java)"},{"location":"releasing/","text":"Releasing \u00b6 Prerequisite: Sonatype (Maven Central) Account \u00b6 Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for com.squareup projects. Prerequisite: GPG Keys \u00b6 Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@squareup.com> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX Prerequisite: Gradle Properties \u00b6 Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jbarber/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg Cutting a Release \u00b6 Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/version = '.*'/version = '$RELEASE_VERSION'/g\" \\ build.gradle sed -i \"\" \\ \"s/\\\"com.squareup.okhttp3:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.okhttp3:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` sed -i \"\" \\ \"s/\\/com.squareup.okhttp3\\/\\([^\\:]*\\)\\/[^\\/]*\\//\\/com.squareup.okhttp3\\/\\1\\/$RELEASE_VERSION\\//g\" \\ `find . -name \"README.md\"` ./gradlew clean publishAllPublicationsToMavencentralRepository Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a parent-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/version = '.*'/version = '$NEXT_VERSION'/g\" \\ build.gradle git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Releasing"},{"location":"releasing/#releasing","text":"","title":"Releasing"},{"location":"releasing/#prerequisite-sonatype-maven-central-account","text":"Create an account on the Sonatype issues site . Ask an existing publisher to open an issue requesting publishing permissions for com.squareup projects.","title":"Prerequisite: Sonatype (Maven Central) Account"},{"location":"releasing/#prerequisite-gpg-keys","text":"Generate a GPG key (RSA, 4096 bit, 3650 day) expiry, or use an existing one. You should leave the password empty for this key. $ gpg --full-generate-key Upload the GPG keys to public servers: $ gpg --list-keys --keyid-format LONG /Users/johnbarber/.gnupg/pubring.kbx ------------------------------ pub rsa4096/XXXXXXXXXXXXXXXX 2019-07-16 [SC] [expires: 2029-07-13] YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY uid [ultimate] John Barber <jbarber@squareup.com> sub rsa4096/ZZZZZZZZZZZZZZZZ 2019-07-16 [E] [expires: 2029-07-13] $ gpg --send-keys --keyserver keyserver.ubuntu.com XXXXXXXXXXXXXXXX","title":"Prerequisite: GPG Keys"},{"location":"releasing/#prerequisite-gradle-properties","text":"Define publishing properties in ~/.gradle/gradle.properties : signing.keyId=1A2345F8 signing.password= signing.secretKeyRingFile=/Users/jbarber/.gnupg/secring.gpg signing.keyId is the GPG key\u2019s ID. Get it with this: $ gpg --list-keys --keyid-format SHORT signing.password is the password for this key. This might be empty! signing.secretKeyRingFile is the absolute path for secring.gpg . You may need to export this file manually with the following command where XXXXXXXX is the keyId above: $ gpg --keyring secring.gpg --export-secret-key XXXXXXXX > ~/.gnupg/secring.gpg","title":"Prerequisite: Gradle Properties"},{"location":"releasing/#cutting-a-release","text":"Update CHANGELOG.md . Set versions: export RELEASE_VERSION=X.Y.Z export NEXT_VERSION=X.Y.Z-SNAPSHOT Set environment variables with your Sonatype credentials . export SONATYPE_NEXUS_USERNAME=johnbarber export SONATYPE_NEXUS_PASSWORD=`pbpaste` Update, build, and upload: sed -i \"\" \\ \"s/version = '.*'/version = '$RELEASE_VERSION'/g\" \\ build.gradle sed -i \"\" \\ \"s/\\\"com.squareup.okhttp3:\\([^\\:]*\\):[^\\\"]*\\\"/\\\"com.squareup.okhttp3:\\1:$RELEASE_VERSION\\\"/g\" \\ `find . -name \"README.md\"` sed -i \"\" \\ \"s/\\/com.squareup.okhttp3\\/\\([^\\:]*\\)\\/[^\\/]*\\//\\/com.squareup.okhttp3\\/\\1\\/$RELEASE_VERSION\\//g\" \\ `find . -name \"README.md\"` ./gradlew clean publishAllPublicationsToMavencentralRepository Visit Sonatype Nexus to promote (close then release) the artifact. Or drop it if there is a problem! Tag the release, prepare for the next one, and push to GitHub. git commit -am \"Prepare for release $RELEASE_VERSION.\" git tag -a parent-$RELEASE_VERSION -m \"Version $RELEASE_VERSION\" sed -i \"\" \\ \"s/version = '.*'/version = '$NEXT_VERSION'/g\" \\ build.gradle git commit -am \"Prepare next development version.\" git push && git push --tags","title":"Cutting a Release"},{"location":"security/","text":"Security Policy \u00b6 Supported Versions \u00b6 Version Supported Notes 4.x \u2705 Android 5.0+ (API level 21+) and on Java 8+. 3.12.x Until 2021-12-31 Android 2.3+ (API level 9+) and Java 7+. Platforms may not support TLSv1.2. Reporting a Vulnerability \u00b6 Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository. If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource","title":"Security"},{"location":"security/#security-policy","text":"","title":"Security Policy"},{"location":"security/#supported-versions","text":"Version Supported Notes 4.x \u2705 Android 5.0+ (API level 21+) and on Java 8+. 3.12.x Until 2021-12-31 Android 2.3+ (API level 9+) and Java 7+. Platforms may not support TLSv1.2.","title":"Supported Versions"},{"location":"security/#reporting-a-vulnerability","text":"Square recognizes the important contributions the security research community can make. We therefore encourage reporting security issues with the code contained in this repository. If you believe you have discovered a security vulnerability, please follow the guidelines at https://bugcrowd.com/squareopensource","title":"Reporting a Vulnerability"},{"location":"security_providers/","text":"Security Providers \u00b6 Provider Status \u00b6 Provider HTTP/2 TLSv1.3 Powered By Notes JVM default Java 9+ Java 11+ OpenJDK Android default \u2705 Android 10+ BoringSSL Bouncy Castle \u2705 Bouncy Castle Tracking bug. Conscrypt \u2705 \u2705 BoringSSL Activated if Conscrypt is first registered provider. OpenJSSE \u2705 OpenJDK OpenJDK backport. Corretto \u2705 \u2705 OpenSSL Amazon\u2019s high-performance provider. Tracking bug. All providers support HTTP/1.1 and TLSv1.2.","title":"Security Providers"},{"location":"security_providers/#security-providers","text":"","title":"Security Providers"},{"location":"security_providers/#provider-status","text":"Provider HTTP/2 TLSv1.3 Powered By Notes JVM default Java 9+ Java 11+ OpenJDK Android default \u2705 Android 10+ BoringSSL Bouncy Castle \u2705 Bouncy Castle Tracking bug. Conscrypt \u2705 \u2705 BoringSSL Activated if Conscrypt is first registered provider. OpenJSSE \u2705 OpenJDK OpenJDK backport. Corretto \u2705 \u2705 OpenSSL Amazon\u2019s high-performance provider. Tracking bug. All providers support HTTP/1.1 and TLSv1.2.","title":"Provider Status"},{"location":"tls_configuration_history/","text":"TLS Configuration History \u00b6 OkHttp tracks the dynamic TLS ecosystem to balance connectivity and security. This page is a log of changes we\u2019ve made over time to OkHttp\u2019s default TLS options. OkHttp 3.14 \u00b6 2019-03-14 Remove 2 TLSv1.3 cipher suites that are neither available on OkHttp\u2019s host platforms nor enabled in releases of Chrome and Firefox. RESTRICTED_TLS cipher suites \u00b6 TLS_AES_128_GCM_SHA256 \u00b9 TLS_AES_256_GCM_SHA384 \u00b9 TLS_CHACHA20_POLY1305_SHA256 \u00b9 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 REMOVED: TLS_AES_128_CCM_SHA256 \u00b9 REMOVED: TLS_AES_128_CCM_8_SHA256 \u00b9 MODERN_TLS / COMPATIBLE_TLS cipher suites \u00b6 TLS_AES_128_GCM_SHA256 \u00b9 TLS_AES_256_GCM_SHA384 \u00b9 TLS_CHACHA20_POLY1305_SHA256 \u00b9 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 TLS_RSA_WITH_AES_256_GCM_SHA384 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2 REMOVED: TLS_AES_128_CCM_SHA256 \u00b9 REMOVED: TLS_AES_128_CCM_8_SHA256 \u00b9 OkHttp 3.13 \u00b6 2019-02-04 Remove TLSv1.1 and TLSv1 from MODERN_TLS. Change COMPATIBLE_TLS to support all TLS versions. RESTRICTED_TLS versions \u00b6 TLSv1.3 TLSv1.2 MODERN_TLS versions \u00b6 TLSv1.3 TLSv1.2 REMOVED: TLSv1.1 REMOVED: TLSv1 COMPATIBLE_TLS versions \u00b6 NEW: TLSv1.3 NEW: TLSv1.2 NEW: TLSv1.1 TLSv1 OkHttp 3.12 \u00b6 2018-11-16 Added support for TLSv1.3. RESTRICTED_TLS cipher suites \u00b6 NEW: TLS_AES_128_GCM_SHA256 \u00b9 NEW: TLS_AES_256_GCM_SHA384 \u00b9 NEW: TLS_CHACHA20_POLY1305_SHA256 \u00b9 NEW: TLS_AES_128_CCM_SHA256 \u00b9 NEW: TLS_AES_128_CCM_8_SHA256 \u00b9 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 MODERN_TLS / COMPATIBLE_TLS cipher suites \u00b6 NEW: TLS_AES_128_GCM_SHA256 \u00b9 NEW: TLS_AES_256_GCM_SHA384 \u00b9 NEW: TLS_CHACHA20_POLY1305_SHA256 \u00b9 NEW: TLS_AES_128_CCM_SHA256 \u00b9 NEW: TLS_AES_128_CCM_8_SHA256 \u00b9 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 TLS_RSA_WITH_AES_256_GCM_SHA384 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2 RESTRICTED_TLS versions \u00b6 NEW: TLSv1.3 TLSv1.2 MODERN_TLS versions \u00b6 NEW: TLSv1.3 TLSv1.2 TLSv1.1 TLSv1 COMPATIBLE_TLS versions \u00b6 TLSv1 OkHttp 3.11 \u00b6 2018-07-12 Added a new extra strict RESTRICTED_TLS configuration inspired by Google Cloud\u2019s similar policy . It is appropriate when both the host platform (JVM/Conscrypt/Android) and target webserver are current. RESTRICTED_TLS cipher suites \u00b6 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 RESTRICTED_TLS versions \u00b6 TLSv1.2 OkHttp 3.10 \u00b6 2018-02-24 Remove two rarely-used cipher suites from the default set. This tracks a Chromium change to remove these cipher suites because they are fragile and rarely-used. MODERN_TLS / COMPATIBLE_TLS cipher suites \u00b6 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 TLS_RSA_WITH_AES_256_GCM_SHA384 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2 REMOVED: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA REMOVED: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA OkHttp 3.5 \u00b6 2016-11-30 Remove three old cipher suites and add five new ones. This tracks changes in what\u2019s available on Android and Java, and also what cipher suites recent releases of Chrome and Firefox support by default. MODERN_TLS / COMPATIBLE_TLS cipher suites \u00b6 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 NEW: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 NEW: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 NEW: TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 NEW: TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 NEW: TLS_RSA_WITH_AES_256_GCM_SHA384 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2 REMOVED: TLS_DHE_RSA_WITH_AES_128_CBC_SHA REMOVED: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 REMOVED: TLS_DHE_RSA_WITH_AES_256_CBC_SHA OkHttp 3.0 \u00b6 2016-01-13 MODERN_TLS / COMPATIBLE_TLS cipher suites \u00b6 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA \u00b2 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_DHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_DHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2 MODERN_TLS versions \u00b6 TLSv1.2 TLSv1.1 TLSv1 COMPATIBLE_TLS versions \u00b6 TLSv1 \u00b9 TLSv1.3 Only \u00b6 Cipher suites that are only available with TLSv1.3. \u00b2 HTTP/2 Cipher Suite Denylist \u00b6 Cipher suites that are discouraged for use with HTTP/2. OkHttp includes them because better suites are not commonly available. For example, none of the better cipher suites listed above shipped with Android 4.4 or Java 7.","title":"Tls configuration history"},{"location":"tls_configuration_history/#tls-configuration-history","text":"OkHttp tracks the dynamic TLS ecosystem to balance connectivity and security. This page is a log of changes we\u2019ve made over time to OkHttp\u2019s default TLS options.","title":"TLS Configuration History"},{"location":"tls_configuration_history/#okhttp-314","text":"2019-03-14 Remove 2 TLSv1.3 cipher suites that are neither available on OkHttp\u2019s host platforms nor enabled in releases of Chrome and Firefox.","title":"OkHttp 3.14"},{"location":"tls_configuration_history/#restricted_tls-cipher-suites","text":"TLS_AES_128_GCM_SHA256 \u00b9 TLS_AES_256_GCM_SHA384 \u00b9 TLS_CHACHA20_POLY1305_SHA256 \u00b9 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 REMOVED: TLS_AES_128_CCM_SHA256 \u00b9 REMOVED: TLS_AES_128_CCM_8_SHA256 \u00b9","title":"RESTRICTED_TLS cipher suites"},{"location":"tls_configuration_history/#modern_tls-compatible_tls-cipher-suites","text":"TLS_AES_128_GCM_SHA256 \u00b9 TLS_AES_256_GCM_SHA384 \u00b9 TLS_CHACHA20_POLY1305_SHA256 \u00b9 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 TLS_RSA_WITH_AES_256_GCM_SHA384 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2 REMOVED: TLS_AES_128_CCM_SHA256 \u00b9 REMOVED: TLS_AES_128_CCM_8_SHA256 \u00b9","title":"MODERN_TLS / COMPATIBLE_TLS cipher suites"},{"location":"tls_configuration_history/#okhttp-313","text":"2019-02-04 Remove TLSv1.1 and TLSv1 from MODERN_TLS. Change COMPATIBLE_TLS to support all TLS versions.","title":"OkHttp 3.13"},{"location":"tls_configuration_history/#restricted_tls-versions","text":"TLSv1.3 TLSv1.2","title":"RESTRICTED_TLS versions"},{"location":"tls_configuration_history/#modern_tls-versions","text":"TLSv1.3 TLSv1.2 REMOVED: TLSv1.1 REMOVED: TLSv1","title":"MODERN_TLS versions"},{"location":"tls_configuration_history/#compatible_tls-versions","text":"NEW: TLSv1.3 NEW: TLSv1.2 NEW: TLSv1.1 TLSv1","title":"COMPATIBLE_TLS versions"},{"location":"tls_configuration_history/#okhttp-312","text":"2018-11-16 Added support for TLSv1.3.","title":"OkHttp 3.12"},{"location":"tls_configuration_history/#restricted_tls-cipher-suites_1","text":"NEW: TLS_AES_128_GCM_SHA256 \u00b9 NEW: TLS_AES_256_GCM_SHA384 \u00b9 NEW: TLS_CHACHA20_POLY1305_SHA256 \u00b9 NEW: TLS_AES_128_CCM_SHA256 \u00b9 NEW: TLS_AES_128_CCM_8_SHA256 \u00b9 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256","title":"RESTRICTED_TLS cipher suites"},{"location":"tls_configuration_history/#modern_tls-compatible_tls-cipher-suites_1","text":"NEW: TLS_AES_128_GCM_SHA256 \u00b9 NEW: TLS_AES_256_GCM_SHA384 \u00b9 NEW: TLS_CHACHA20_POLY1305_SHA256 \u00b9 NEW: TLS_AES_128_CCM_SHA256 \u00b9 NEW: TLS_AES_128_CCM_8_SHA256 \u00b9 TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 TLS_RSA_WITH_AES_256_GCM_SHA384 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2","title":"MODERN_TLS / COMPATIBLE_TLS cipher suites"},{"location":"tls_configuration_history/#restricted_tls-versions_1","text":"NEW: TLSv1.3 TLSv1.2","title":"RESTRICTED_TLS versions"},{"location":"tls_configuration_history/#modern_tls-versions_1","text":"NEW: TLSv1.3 TLSv1.2 TLSv1.1 TLSv1","title":"MODERN_TLS versions"},{"location":"tls_configuration_history/#compatible_tls-versions_1","text":"TLSv1","title":"COMPATIBLE_TLS versions"},{"location":"tls_configuration_history/#okhttp-311","text":"2018-07-12 Added a new extra strict RESTRICTED_TLS configuration inspired by Google Cloud\u2019s similar policy . It is appropriate when both the host platform (JVM/Conscrypt/Android) and target webserver are current.","title":"OkHttp 3.11"},{"location":"tls_configuration_history/#restricted_tls-cipher-suites_2","text":"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256","title":"RESTRICTED_TLS cipher suites"},{"location":"tls_configuration_history/#restricted_tls-versions_2","text":"TLSv1.2","title":"RESTRICTED_TLS versions"},{"location":"tls_configuration_history/#okhttp-310","text":"2018-02-24 Remove two rarely-used cipher suites from the default set. This tracks a Chromium change to remove these cipher suites because they are fragile and rarely-used.","title":"OkHttp 3.10"},{"location":"tls_configuration_history/#modern_tls-compatible_tls-cipher-suites_2","text":"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 TLS_RSA_WITH_AES_256_GCM_SHA384 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2 REMOVED: TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA REMOVED: TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA","title":"MODERN_TLS / COMPATIBLE_TLS cipher suites"},{"location":"tls_configuration_history/#okhttp-35","text":"2016-11-30 Remove three old cipher suites and add five new ones. This tracks changes in what\u2019s available on Android and Java, and also what cipher suites recent releases of Chrome and Firefox support by default.","title":"OkHttp 3.5"},{"location":"tls_configuration_history/#modern_tls-compatible_tls-cipher-suites_3","text":"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 NEW: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 NEW: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 NEW: TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 NEW: TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 NEW: TLS_RSA_WITH_AES_256_GCM_SHA384 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2 REMOVED: TLS_DHE_RSA_WITH_AES_128_CBC_SHA REMOVED: TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 REMOVED: TLS_DHE_RSA_WITH_AES_256_CBC_SHA","title":"MODERN_TLS / COMPATIBLE_TLS cipher suites"},{"location":"tls_configuration_history/#okhttp-30","text":"2016-01-13","title":"OkHttp 3.0"},{"location":"tls_configuration_history/#modern_tls-compatible_tls-cipher-suites_4","text":"TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA \u00b2 TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_DHE_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_DHE_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_AES_128_GCM_SHA256 \u00b2 TLS_RSA_WITH_AES_128_CBC_SHA \u00b2 TLS_RSA_WITH_AES_256_CBC_SHA \u00b2 TLS_RSA_WITH_3DES_EDE_CBC_SHA \u00b2","title":"MODERN_TLS / COMPATIBLE_TLS cipher suites"},{"location":"tls_configuration_history/#modern_tls-versions_2","text":"TLSv1.2 TLSv1.1 TLSv1","title":"MODERN_TLS versions"},{"location":"tls_configuration_history/#compatible_tls-versions_2","text":"TLSv1","title":"COMPATIBLE_TLS versions"},{"location":"tls_configuration_history/#1-tlsv13-only","text":"Cipher suites that are only available with TLSv1.3.","title":"\u00b9 TLSv1.3 Only"},{"location":"tls_configuration_history/#2-http2-cipher-suite-denylist","text":"Cipher suites that are discouraged for use with HTTP/2. OkHttp includes them because better suites are not commonly available. For example, none of the better cipher suites listed above shipped with Android 4.4 or Java 7.","title":"\u00b2 HTTP/2 Cipher Suite Denylist"},{"location":"upgrading_to_okhttp_4/","text":"Upgrading to OkHttp 4 \u00b6 OkHttp 4.x upgrades our implementation language from Java to Kotlin and keeps everything else the same. We\u2019ve chosen Kotlin because it gives us powerful new capabilities while integrating closely with Java. We spent a lot of time and energy on retaining strict compatibility with OkHttp 3.x. We\u2019re even keeping the package name the same: okhttp3 ! There are three kinds of compatibility we\u2019re tracking: Binary compatibility is the ability to compile a program against OkHttp 3.x, and then to run it against OkHttp 4.x. We\u2019re using the excellent japicmp library via its Gradle plugin to enforce binary compatibility. Java source compatibility is the ability to upgrade Java uses of OkHttp 3.x to 4.x without changing .java files. Kotlin source compatibility is the ability to upgrade Kotlin uses of OkHttp 3.x to 4.x without changing .kt files. With a few small exceptions (below), OkHttp 4.x is both binary- and Java source-compatible with OkHttp 3.x. You can use an OkHttp 4.x .jar file with applications or libraries built for OkHttp 3.x. OkHttp is not source-compatible for Kotlin callers, but upgrading should be automatic thanks to Kotlin\u2019s powerful deprecation features. Most developers should be able to use IntelliJ\u2019s Code Cleanup for a safe and fast upgrade. Backwards-Incompatible Changes \u00b6 OkHttpClient final methods \u00b6 OkHttpClient has 26 accessors like interceptors() and writeTimeoutMillis() that were non-final in OkHttp 3.x and are final in 4.x. These were made non-final for use with mocking frameworks like Mockito . We believe subtyping OkHttpClient is the wrong way to test with OkHttp. If you must, mock Call.Factory which is the interface that OkHttpClient implements. Internal API changes \u00b6 The okhttp3.internal package is not a published API and we change it frequently without warning. Depending on code in this package is bad and will cause you problems with any upgrade! But the 4.x will be particularly painful to naughty developers that import from this package! We changed a lot to take advantage of sweet Kotlin features. Credentials.basic() \u00b6 The username and password parameters to Credentials.basic() are now non-null strings. In OkHttp 3.x, null would yield a username or password of \u201cnull\u201d. HttpUrl.queryParameterValues() \u00b6 The return type of HttpUrl.queryParameterValues() is List<String?> . Lists that may contain null are uncommon and Kotlin callers may have incorrectly assigned the result to List<String> . Code Cleanup \u00b6 IntelliJ and Android Studio offer a Code Cleanup feature that will automatically update deprecated APIs with their replacements. Access this feature from the Search Anywhere dialog (double-press shift) or under the Analyze menu. We\u2019ve included deprecated APIs in OkHttp 4.0 because they make migration easy. We will remove them in a future release! If you\u2019re skipping releases, it\u2019ll be much easier if you upgrade to OkHttp 4.0 as an intermediate step. Vars and Vals \u00b6 Java doesn\u2019t have language support for properties so developers make do with getters and setters. Kotlin does have properties and we take advantage of them in OkHttp. Address : certificatePinner, connectionSpecs, dns, hostnameVerifier, protocols, proxy, proxyAuthenticator, proxySelector, socketFactory, sslSocketFactory, url Cache : directory CacheControl : immutable, maxAgeSeconds, maxStaleSeconds, minFreshSeconds, mustRevalidate, noCache, noStore, noTransform, onlyIfCached, sMaxAgeSeconds Challenge : authParams, charset, realm, scheme CipherSuite : javaName ConnectionSpec : cipherSuites, supportsTlsExtensions, tlsVersions Cookie : domain, expiresAt, hostOnly, httpOnly, name, path, persistent, value Dispatcher : executorService FormBody : size Handshake : cipherSuite, localCertificates, localPrincipal, peerCertificates, peerPrincipal, tlsVersion HandshakeCertificates : keyManager, trustManager Headers : size HeldCertificate : certificate, keyPair HttpLoggingInterceptor : level HttpUrl : encodedFragment, encodedPassword, encodedPath, encodedPathSegments, encodedQuery, encodedUsername, fragment, host, password, pathSegments, pathSize, port, query, queryParameterNames, querySize, scheme, username MockResponse : headers, http2ErrorCode, socketPolicy, status, trailers MockWebServer : bodyLimit, port, protocolNegotiationEnabled, protocols, requestCount, serverSocketFactory MultipartBody.Part : body, headers MultipartBody. : boundary, parts, size, type OkHttpClient : authenticator, cache, callTimeoutMillis, certificatePinner, connectTimeoutMillis, connectionPool, connectionSpecs, cookieJar, dispatcher, dns, eventListenerFactory, followRedirects, followSslRedirects, hostnameVerifier, interceptors, networkInterceptors, pingIntervalMillis, protocols, proxy, proxyAuthenticator, proxySelector, readTimeoutMillis, retryOnConnectionFailure, socketFactory, sslSocketFactory, writeTimeoutMillis PushPromise : headers, method, path, response Request : body, cacheControl, headers, method, url Response : body, cacheControl, cacheResponse, code, handshake, headers, message, networkResponse, priorResponse, protocol, receivedResponseAtMillis, request, sentRequestAtMillis Route : address, proxy, socketAddress TlsVersion : javaName Renamed Functions \u00b6 Headers.of() : for symmetry with listOf() , setOf() , etc., we\u2019ve replaced Headers.of(String...) with headersOf(vararg String) . Extension Functions \u00b6 We\u2019ve migrated from static functions to extension functions where we think they fit. Java Kotlin Handshake.get(SSLSession) SSLSession.handshake() Headers.of(Map ) Map .toHeaders() HttpUrl.get(String) String.toHttpUrl() HttpUrl.get(URI) URI.toHttpUrlOrNull() HttpUrl.get(URL) URL.toHttpUrlOrNull() HttpUrl.parse(String) String.toHttpUrlOrNull() HttpUrl.uri() HttpUrl.toUri() HttpUrl.url() HttpUrl.toUrl() MediaType.get(String) String.toMediaType() MediaType.parse(String) String.toMediaTypeOrNull() RequestBody.create(ByteArray) ByteArray.toRequestBody() RequestBody.create(ByteString) ByteString.toRequestBody() RequestBody.create(File) File.asRequestBody() RequestBody.create(String) String.toRequestBody() ResponseBody.create(BufferedSource) BufferedSource.asResponseBody() ResponseBody.create(ByteArray) ByteArray.toResponseBody() ResponseBody.create(ByteString) ByteString.toResponseBody() ResponseBody.create(String) String.toResponseBody() SAM Conversions \u00b6 When you use Java APIs from Kotlin you can operate on Java interfaces as if they were Kotlin lambdas. The feature is available for interfaces that define a Single Abstract Method (SAM). But when you use Kotlin APIs from Kotlin there\u2019s no automatic conversion. Code that used SAM lambdas with OkHttp 3.x: must use object : with OkHttp 4.x: Kotlin calling OkHttp 3.x: val client = OkHttpClient . Builder () . dns { hostname -> InetAddress . getAllByName ( hostname ). toList () } . build () Kotlin calling OkHttp 4.x: val client = OkHttpClient . Builder () . dns ( object : Dns { override fun lookup ( hostname : String ) = InetAddress . getAllByName ( hostname ). toList () }) . build () SAM conversion impacts these APIs: Authenticator Dispatcher.setIdleCallback(Runnable) Dns EventListener.Factory HttpLoggingInterceptor.Logger LoggingEventListener.Factory OkHttpClient.Builder.hostnameVerifier(HostnameVerifier) JetBrains is working on SAM conversions of Kotlin interfaces. Expect it in a future release of the Kotlin language. Companion Imports \u00b6 The equivalent of static methods in Java is companion object functions in Kotlin. The bytecode is the same but .kt files now need Companion in the import. This works with OkHttp 3.x: import okhttp3.CipherSuite.forJavaName But OkHttp 4.x needs a Companion : import okhttp3.CipherSuite.Companion.forJavaName In the unlikely event that you have a lot of these, run this: sed -i \"\" \\ 's/^\\(import okhttp3\\.[^.]*\\)\\.\\([a-z][a-zA-Z]*\\)$/\\1.Companion.\\2/g' \\ ` find . -name \"*.kt\" ` Advanced Profiling \u00b6 Android Studio\u2019s Advanced Profiling feature rewrites OkHttp bytecode for instrumentation. Unfortunately it crashes on OkHttp 4.x\u2019s bytecode. Until Google\u2019s bug is fixed you must disable advanced profiling in Android Studio. R8 / ProGuard \u00b6 R8 and ProGuard are both code optimizers for .class files. R8 is the default optimizer in Android Studio 3.4 and newer. It works well with all releases of OkHttp. ProGuard was the previous default. We\u2019re tracking problems with interactions between ProGuard, OkHttp 4.x, and Kotlin-originated .class files. Make sure you\u2019re on the latest release if you\u2019re using ProGuard, Gradle \u00b6 OkHttp 4\u2019s minimum requirements are Java 8+ and Android 5+. These requirements were first introduced with OkHttp 3.13. Here\u2019s what you need in build.gradle to target Java 8 byte code for Kotlin, Java, and Android plugins respectively. compileKotlin { kotlinOptions { jvmTarget = \"1.8\" } } compileTestKotlin { kotlinOptions { jvmTarget = \"1.8\" } } compileJava { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } }","title":"Upgrading to OkHttp 4"},{"location":"upgrading_to_okhttp_4/#upgrading-to-okhttp-4","text":"OkHttp 4.x upgrades our implementation language from Java to Kotlin and keeps everything else the same. We\u2019ve chosen Kotlin because it gives us powerful new capabilities while integrating closely with Java. We spent a lot of time and energy on retaining strict compatibility with OkHttp 3.x. We\u2019re even keeping the package name the same: okhttp3 ! There are three kinds of compatibility we\u2019re tracking: Binary compatibility is the ability to compile a program against OkHttp 3.x, and then to run it against OkHttp 4.x. We\u2019re using the excellent japicmp library via its Gradle plugin to enforce binary compatibility. Java source compatibility is the ability to upgrade Java uses of OkHttp 3.x to 4.x without changing .java files. Kotlin source compatibility is the ability to upgrade Kotlin uses of OkHttp 3.x to 4.x without changing .kt files. With a few small exceptions (below), OkHttp 4.x is both binary- and Java source-compatible with OkHttp 3.x. You can use an OkHttp 4.x .jar file with applications or libraries built for OkHttp 3.x. OkHttp is not source-compatible for Kotlin callers, but upgrading should be automatic thanks to Kotlin\u2019s powerful deprecation features. Most developers should be able to use IntelliJ\u2019s Code Cleanup for a safe and fast upgrade.","title":"Upgrading to OkHttp 4"},{"location":"upgrading_to_okhttp_4/#backwards-incompatible-changes","text":"","title":"Backwards-Incompatible Changes"},{"location":"upgrading_to_okhttp_4/#okhttpclient-final-methods","text":"OkHttpClient has 26 accessors like interceptors() and writeTimeoutMillis() that were non-final in OkHttp 3.x and are final in 4.x. These were made non-final for use with mocking frameworks like Mockito . We believe subtyping OkHttpClient is the wrong way to test with OkHttp. If you must, mock Call.Factory which is the interface that OkHttpClient implements.","title":"OkHttpClient final methods"},{"location":"upgrading_to_okhttp_4/#internal-api-changes","text":"The okhttp3.internal package is not a published API and we change it frequently without warning. Depending on code in this package is bad and will cause you problems with any upgrade! But the 4.x will be particularly painful to naughty developers that import from this package! We changed a lot to take advantage of sweet Kotlin features.","title":"Internal API changes"},{"location":"upgrading_to_okhttp_4/#credentialsbasic","text":"The username and password parameters to Credentials.basic() are now non-null strings. In OkHttp 3.x, null would yield a username or password of \u201cnull\u201d.","title":"Credentials.basic()"},{"location":"upgrading_to_okhttp_4/#httpurlqueryparametervalues","text":"The return type of HttpUrl.queryParameterValues() is List<String?> . Lists that may contain null are uncommon and Kotlin callers may have incorrectly assigned the result to List<String> .","title":"HttpUrl.queryParameterValues()"},{"location":"upgrading_to_okhttp_4/#code-cleanup","text":"IntelliJ and Android Studio offer a Code Cleanup feature that will automatically update deprecated APIs with their replacements. Access this feature from the Search Anywhere dialog (double-press shift) or under the Analyze menu. We\u2019ve included deprecated APIs in OkHttp 4.0 because they make migration easy. We will remove them in a future release! If you\u2019re skipping releases, it\u2019ll be much easier if you upgrade to OkHttp 4.0 as an intermediate step.","title":"Code Cleanup"},{"location":"upgrading_to_okhttp_4/#vars-and-vals","text":"Java doesn\u2019t have language support for properties so developers make do with getters and setters. Kotlin does have properties and we take advantage of them in OkHttp. Address : certificatePinner, connectionSpecs, dns, hostnameVerifier, protocols, proxy, proxyAuthenticator, proxySelector, socketFactory, sslSocketFactory, url Cache : directory CacheControl : immutable, maxAgeSeconds, maxStaleSeconds, minFreshSeconds, mustRevalidate, noCache, noStore, noTransform, onlyIfCached, sMaxAgeSeconds Challenge : authParams, charset, realm, scheme CipherSuite : javaName ConnectionSpec : cipherSuites, supportsTlsExtensions, tlsVersions Cookie : domain, expiresAt, hostOnly, httpOnly, name, path, persistent, value Dispatcher : executorService FormBody : size Handshake : cipherSuite, localCertificates, localPrincipal, peerCertificates, peerPrincipal, tlsVersion HandshakeCertificates : keyManager, trustManager Headers : size HeldCertificate : certificate, keyPair HttpLoggingInterceptor : level HttpUrl : encodedFragment, encodedPassword, encodedPath, encodedPathSegments, encodedQuery, encodedUsername, fragment, host, password, pathSegments, pathSize, port, query, queryParameterNames, querySize, scheme, username MockResponse : headers, http2ErrorCode, socketPolicy, status, trailers MockWebServer : bodyLimit, port, protocolNegotiationEnabled, protocols, requestCount, serverSocketFactory MultipartBody.Part : body, headers MultipartBody. : boundary, parts, size, type OkHttpClient : authenticator, cache, callTimeoutMillis, certificatePinner, connectTimeoutMillis, connectionPool, connectionSpecs, cookieJar, dispatcher, dns, eventListenerFactory, followRedirects, followSslRedirects, hostnameVerifier, interceptors, networkInterceptors, pingIntervalMillis, protocols, proxy, proxyAuthenticator, proxySelector, readTimeoutMillis, retryOnConnectionFailure, socketFactory, sslSocketFactory, writeTimeoutMillis PushPromise : headers, method, path, response Request : body, cacheControl, headers, method, url Response : body, cacheControl, cacheResponse, code, handshake, headers, message, networkResponse, priorResponse, protocol, receivedResponseAtMillis, request, sentRequestAtMillis Route : address, proxy, socketAddress TlsVersion : javaName","title":"Vars and Vals"},{"location":"upgrading_to_okhttp_4/#renamed-functions","text":"Headers.of() : for symmetry with listOf() , setOf() , etc., we\u2019ve replaced Headers.of(String...) with headersOf(vararg String) .","title":"Renamed Functions"},{"location":"upgrading_to_okhttp_4/#extension-functions","text":"We\u2019ve migrated from static functions to extension functions where we think they fit. Java Kotlin Handshake.get(SSLSession) SSLSession.handshake() Headers.of(Map ) Map .toHeaders() HttpUrl.get(String) String.toHttpUrl() HttpUrl.get(URI) URI.toHttpUrlOrNull() HttpUrl.get(URL) URL.toHttpUrlOrNull() HttpUrl.parse(String) String.toHttpUrlOrNull() HttpUrl.uri() HttpUrl.toUri() HttpUrl.url() HttpUrl.toUrl() MediaType.get(String) String.toMediaType() MediaType.parse(String) String.toMediaTypeOrNull() RequestBody.create(ByteArray) ByteArray.toRequestBody() RequestBody.create(ByteString) ByteString.toRequestBody() RequestBody.create(File) File.asRequestBody() RequestBody.create(String) String.toRequestBody() ResponseBody.create(BufferedSource) BufferedSource.asResponseBody() ResponseBody.create(ByteArray) ByteArray.toResponseBody() ResponseBody.create(ByteString) ByteString.toResponseBody() ResponseBody.create(String) String.toResponseBody()","title":"Extension Functions"},{"location":"upgrading_to_okhttp_4/#sam-conversions","text":"When you use Java APIs from Kotlin you can operate on Java interfaces as if they were Kotlin lambdas. The feature is available for interfaces that define a Single Abstract Method (SAM). But when you use Kotlin APIs from Kotlin there\u2019s no automatic conversion. Code that used SAM lambdas with OkHttp 3.x: must use object : with OkHttp 4.x: Kotlin calling OkHttp 3.x: val client = OkHttpClient . Builder () . dns { hostname -> InetAddress . getAllByName ( hostname ). toList () } . build () Kotlin calling OkHttp 4.x: val client = OkHttpClient . Builder () . dns ( object : Dns { override fun lookup ( hostname : String ) = InetAddress . getAllByName ( hostname ). toList () }) . build () SAM conversion impacts these APIs: Authenticator Dispatcher.setIdleCallback(Runnable) Dns EventListener.Factory HttpLoggingInterceptor.Logger LoggingEventListener.Factory OkHttpClient.Builder.hostnameVerifier(HostnameVerifier) JetBrains is working on SAM conversions of Kotlin interfaces. Expect it in a future release of the Kotlin language.","title":"SAM Conversions"},{"location":"upgrading_to_okhttp_4/#companion-imports","text":"The equivalent of static methods in Java is companion object functions in Kotlin. The bytecode is the same but .kt files now need Companion in the import. This works with OkHttp 3.x: import okhttp3.CipherSuite.forJavaName But OkHttp 4.x needs a Companion : import okhttp3.CipherSuite.Companion.forJavaName In the unlikely event that you have a lot of these, run this: sed -i \"\" \\ 's/^\\(import okhttp3\\.[^.]*\\)\\.\\([a-z][a-zA-Z]*\\)$/\\1.Companion.\\2/g' \\ ` find . -name \"*.kt\" `","title":"Companion Imports"},{"location":"upgrading_to_okhttp_4/#advanced-profiling","text":"Android Studio\u2019s Advanced Profiling feature rewrites OkHttp bytecode for instrumentation. Unfortunately it crashes on OkHttp 4.x\u2019s bytecode. Until Google\u2019s bug is fixed you must disable advanced profiling in Android Studio.","title":"Advanced Profiling"},{"location":"upgrading_to_okhttp_4/#r8-proguard","text":"R8 and ProGuard are both code optimizers for .class files. R8 is the default optimizer in Android Studio 3.4 and newer. It works well with all releases of OkHttp. ProGuard was the previous default. We\u2019re tracking problems with interactions between ProGuard, OkHttp 4.x, and Kotlin-originated .class files. Make sure you\u2019re on the latest release if you\u2019re using ProGuard,","title":"R8 / ProGuard"},{"location":"upgrading_to_okhttp_4/#gradle","text":"OkHttp 4\u2019s minimum requirements are Java 8+ and Android 5+. These requirements were first introduced with OkHttp 3.13. Here\u2019s what you need in build.gradle to target Java 8 byte code for Kotlin, Java, and Android plugins respectively. compileKotlin { kotlinOptions { jvmTarget = \"1.8\" } } compileTestKotlin { kotlinOptions { jvmTarget = \"1.8\" } } compileJava { sourceCompatibility = JavaVersion . VERSION_1_8 targetCompatibility = JavaVersion . VERSION_1_8 } android { compileOptions { sourceCompatibility JavaVersion . VERSION_1_8 targetCompatibility JavaVersion . VERSION_1_8 } }","title":"Gradle"},{"location":"works_with_okhttp/","text":"Works with OkHttp \u00b6 Here\u2019s some libraries that work nicely with OkHttp. Chucker : An in-app HTTP inspector for Android OkHttp clients. Coil : An image loading library for Android backed by Kotlin Coroutines. Communicator : An OkHttp wrapper for Scala built with Android in mind. CWAC-NetSecurity : Simplifying Secure Internet Access. Flipper : A desktop debugging platform for mobile developers. Fresco : An Android library for managing images and the memory they use. Glide : An image loading and caching library for Android focused on smooth scrolling. GoogleAppEngineOkHttp : An OkHttp Call that works on Google App Engine. Hunter : Configure all OkHttpClients centrally. \u2b1c\ufe0f Moshi : A modern JSON library for Android and Java. Ok2Curl : Convert OkHttp requests into curl logs. OkHttp AWS Signer : AWS V4 signing algorithm for OkHttp requests okhttp-digest : A digest authenticator for OkHttp. OkHttp Idling Resource : An Espresso IdlingResource for OkHttp. okhttp-client-mock : A simple OKHttp client mock, using a programmable request interceptor. OkHttp Profiler : An IntelliJ plugin for monitoring OkHttp calls. OkReplay : Record and replay OkHttp network interaction in your tests. okhttp-signpost : OAuth signing with signpost and OkHttp. okhttp-staleiferror-interceptor : serve stale responses when the server isn\u2019t reachable. okhttp-stats : Get stats like average network speed. \u2b1c\ufe0f Okio : A modern I/O API for Java. OkLog : Response logging interceptor for OkHttp. Logs a URL link with URL-encoded response for every OkHttp call. Okurl A curl-like client for social networks and other APIs. PersistentCookieJar : A persistent CookieJar . \u2b1c\ufe0f Picasso : A powerful image downloading and caching library for Android. \u2b1c\ufe0f Retrofit : Type-safe HTTP client for Android and Java by Square. Stetho : Stetho is a debug bridge for Android applications. Thrifty : An implementation of Apache Thrift for Android. \u2b1c\ufe0f Wire : Clean, lightweight protocol buffers for Android and Java.","title":"Works with OkHttp"},{"location":"works_with_okhttp/#works-with-okhttp","text":"Here\u2019s some libraries that work nicely with OkHttp. Chucker : An in-app HTTP inspector for Android OkHttp clients. Coil : An image loading library for Android backed by Kotlin Coroutines. Communicator : An OkHttp wrapper for Scala built with Android in mind. CWAC-NetSecurity : Simplifying Secure Internet Access. Flipper : A desktop debugging platform for mobile developers. Fresco : An Android library for managing images and the memory they use. Glide : An image loading and caching library for Android focused on smooth scrolling. GoogleAppEngineOkHttp : An OkHttp Call that works on Google App Engine. Hunter : Configure all OkHttpClients centrally. \u2b1c\ufe0f Moshi : A modern JSON library for Android and Java. Ok2Curl : Convert OkHttp requests into curl logs. OkHttp AWS Signer : AWS V4 signing algorithm for OkHttp requests okhttp-digest : A digest authenticator for OkHttp. OkHttp Idling Resource : An Espresso IdlingResource for OkHttp. okhttp-client-mock : A simple OKHttp client mock, using a programmable request interceptor. OkHttp Profiler : An IntelliJ plugin for monitoring OkHttp calls. OkReplay : Record and replay OkHttp network interaction in your tests. okhttp-signpost : OAuth signing with signpost and OkHttp. okhttp-staleiferror-interceptor : serve stale responses when the server isn\u2019t reachable. okhttp-stats : Get stats like average network speed. \u2b1c\ufe0f Okio : A modern I/O API for Java. OkLog : Response logging interceptor for OkHttp. Logs a URL link with URL-encoded response for every OkHttp call. Okurl A curl-like client for social networks and other APIs. PersistentCookieJar : A persistent CookieJar . \u2b1c\ufe0f Picasso : A powerful image downloading and caching library for Android. \u2b1c\ufe0f Retrofit : Type-safe HTTP client for Android and Java by Square. Stetho : Stetho is a debug bridge for Android applications. Thrifty : An implementation of Apache Thrift for Android. \u2b1c\ufe0f Wire : Clean, lightweight protocol buffers for Android and Java.","title":"Works with OkHttp"}]}